<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This text is a brief description of the features that are present in
the Bash shell (version 5.3, 18 May 2025).

This is Edition 5.3, last updated 18 May 2025,
of The GNU Bash Reference Manual,
for Bash, Version 5.3.

Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled
"GNU Free Documentation License". -->
<title>Programmable Completion</title>

<meta name="description" content="Programmable Completion (Bash Reference Manual)">
<meta name="keywords" content="Programmable Completion (Bash Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Indexes.html" rel="index" title="Indexes">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Command-Line-Editing.html" rel="up" title="Command Line Editing">
<link href="Programmable-Completion-Builtins.html" rel="next" title="Programmable Completion Builtins">
<link href="Readline-vi-Mode.html" rel="prev" title="Readline vi Mode">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="">


</head>

<body lang="en">
<div class="section-level-extent" id="Programmable-Completion">
<div class="nav-panel">
<p>
Next: <a href="Programmable-Completion-Builtins.html" accesskey="n" rel="next">Programmable Completion Builtins</a>, Previous: <a href="Readline-vi-Mode.html" accesskey="p" rel="prev">Readline vi Mode</a>, Up: <a href="Command-Line-Editing.html" accesskey="u" rel="up">Command Line Editing</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Indexes.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Programmable-Completion-1"><span>8.6 Programmable Completion<a class="copiable-link" href="#Programmable-Completion-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-programmable-completion"></a>

<p>When the user attempts word completion
for a command or an argument to a command for which a
completion specification (a <em class="dfn">compspec</em>) has been defined
using the <code class="code">complete</code> builtin
(see <a class="pxref" href="Programmable-Completion-Builtins.html">Programmable Completion Builtins</a>),
Readline invokes the programmable completion facilities. 
</p>
<p>First, Bash identifies the command name.
If a compspec has been defined for that command, the
compspec is used to generate the list of possible completions for the word.
If the command word is the empty string (completion attempted at the
beginning of an empty line), Bash uses any compspec defined with
the <samp class="option">-E</samp> option to <code class="code">complete</code>.
The <samp class="option">-I</samp> option to <code class="code">complete</code>
indicates that the command word is the first non-assignment word
on the line, or after a command delimiter such as
&lsquo;<samp class="samp">;</samp>&rsquo; or &lsquo;<samp class="samp">|</samp>&rsquo;.
This usually indicates command name completion.
</p>
<p>If the command word is a full pathname, Bash
searches for a compspec for the full pathname first.
If there is no compspec for the full pathname, Bash attempts to
find a compspec for the portion following the final slash.
If those searches do not result in a compspec,
or if there is no compspec for the command word,
Bash uses any compspec defined with
the <samp class="option">-D</samp> option to <code class="code">complete</code> as the default.
If there is no default compspec, Bash performs alias expansion
on the command word as a final resort,
and attempts to find a compspec for the command word
resulting from any successful expansion.
</p>
<p>If a compspec is not found, Bash performs its default completion
described above (see <a class="pxref" href="Commands-For-Completion.html">Letting Readline Type For You</a>).
Otherwise, once a compspec has been found, Bash uses it to generate
the list of matching words.
</p>
<p>First, Bash performs the <var class="var">actions</var> specified by the compspec.
This only returns matches which are prefixes
of the word being completed.
When the <samp class="option">-f</samp> or <samp class="option">-d</samp> option is used for filename or
directory name completion, Bash uses shell the variable <code class="env">FIGNORE</code>
to filter the matches.
See <a class="xref" href="Bash-Variables.html">Bash Variables</a>, for a description of <code class="env">FIGNORE</code>.
</p>
<p>Next, programmable completion generates matches
specified by a pathname expansion pattern
supplied as an argument to the
<samp class="option">-G</samp> option.
The words generated by the pattern need not match the word being completed.
Bash uses the <code class="env">FIGNORE</code> 
variable to filter the matches, but does not use the
<code class="env">GLOBIGNORE</code> shell variable.
</p>
<p>Next, completion considers
the string specified as the argument to the <samp class="option">-W</samp> option.
The string is first split using the characters in the <code class="env">IFS</code>
special variable as delimiters.
This honors shell quoting within the string, in order to provide a
mechanism for the words to contain shell metacharacters or characters
in the value of <code class="env">IFS</code>.
Each word is then expanded using
brace expansion, tilde expansion, parameter and variable expansion,
command substitution, and arithmetic expansion,
as described above (see <a class="pxref" href="Shell-Expansions.html">Shell Expansions</a>).
The results are split using the rules described above
(see <a class="pxref" href="Word-Splitting.html">Word Splitting</a>).
The results of the expansion are prefix-matched against the word being
completed, and the matching words become possible completions.
</p>
<p>After these matches have been generated,
Bash executes any shell function or command
specified with the <samp class="option">-F</samp> and <samp class="option">-C</samp> options.
When the command or function is invoked, Bash
assigns values to the
<code class="env">COMP_LINE</code>,
<code class="env">COMP_POINT</code>,
<code class="env">COMP_KEY</code>,
and
<code class="env">COMP_TYPE</code>
variables as described above
(see <a class="pxref" href="Bash-Variables.html">Bash Variables</a>).
If a shell function is being invoked, Bash
also sets the
<code class="env">COMP_WORDS</code>
and
<code class="env">COMP_CWORD</code>
variables.
When the function or command is invoked,
the first argument ($1) is the name of the command whose arguments
are being completed,
the second argument ($2) is the word being completed,
and the third argument ($3) is the word preceding the word being
completed on the current command line.
There is no filtering of the generated completions against the 
word being completed;
the function or command has complete freedom in generating the matches
and they do not need to match a prefix of the word.
</p>
<p>Any function specified with <samp class="option">-F</samp> is invoked first.
The function may use any of the shell facilities, including the
<code class="code">compgen</code> and <code class="code">compopt</code> builtins described below
(see <a class="pxref" href="Programmable-Completion-Builtins.html">Programmable Completion Builtins</a>), to generate the matches.
It must put the possible completions in the <code class="env">COMPREPLY</code> array
variable, one per array element.
</p>
<p>Next, any command specified with the <samp class="option">-C</samp> option is invoked
in an environment equivalent to command substitution.
It should print a list of completions, one per line, to
the standard output.
Backslash will escape a newline, if necessary.
These are added to the set of possible completions.
</p>
<p>After generating all of the possible completions,
Bash applies any filter
specified with the <samp class="option">-X</samp> option to the completions in the list.
The filter is a pattern as used for pathname expansion; a &lsquo;<samp class="samp">&amp;</samp>&rsquo;
in the pattern is replaced with the text of the word being completed.
A literal &lsquo;<samp class="samp">&amp;</samp>&rsquo; may be escaped with a backslash; the backslash
is removed before attempting a match.
Any completion that matches the pattern is removed from the list.
A leading &lsquo;<samp class="samp">!</samp>&rsquo; negates the pattern;
in this case Bash removes
any completion that does not match the pattern.
If the <code class="code">nocasematch</code> shell option is enabled
(see the description of <code class="code">shopt</code> in <a class="ref" href="The-Shopt-Builtin.html">The Shopt Builtin</a>),
Bash performs the match without regard to the case
of alphabetic characters.
</p>
<p>Finally, programmable completion adds
any prefix and suffix specified with the
<samp class="option">-P</samp> and <samp class="option">-S</samp>
options, respectively, to each completion,
and returns the result
to Readline as the list of possible completions.
</p>
<p>If the previously-applied actions do not generate any matches, and the
<samp class="option">-o dirnames</samp> option was supplied to <code class="code">complete</code> when the
compspec was defined, Bash attempts directory name completion. 
</p>
<p>If the <samp class="option">-o plusdirs</samp> option was supplied to <code class="code">complete</code> when
the compspec was defined, Bash attempts directory name completion
and adds any  matches to the set of possible completions.
</p>
<p>By default, if a compspec is found, whatever it generates is returned to
the completion code as the full set of possible completions.
The default Bash completions and the Readline default
of filename completion are disabled.
If the <samp class="option">-o bashdefault</samp> option was supplied to <code class="code">complete</code> when
the compspec was defined, and the compspec generates no matches,
Bash attempts its default completions.
If the compspec and, if attempted, the default Bash completions
generate no matches,
and the <samp class="option">-o default</samp> option was supplied to
<code class="code">complete</code> when the compspec was defined,
programmable completion performs Readline&rsquo;s default completion.
</p>
<p>The options supplied to <code class="code">complete</code> and <code class="code">compopt</code>
can control how Readline treats the completions.
For instance, the <samp class="option">-o fullquote</samp> option tells Readline
to quote the matches as if they were filenames.
See the description of <code class="code">complete</code>
(see <a class="pxref" href="Programmable-Completion-Builtins.html">Programmable Completion Builtins</a>)
for details.
</p>
<p>When a compspec indicates that it wants directory name completion,
the programmable completion functions force Readline
to append a slash to completed names which are symbolic links
to directories, subject to the value of the
<var class="var">mark-directories</var> Readline variable,
regardless of the setting of the
<var class="var">mark-symlinked-directories</var> Readline variable.
</p>
<p>There is some support for dynamically modifying completions.
This is most useful when used in combination with a default completion
specified with <samp class="option">-D</samp>.
It&rsquo;s possible for shell functions executed as completion functions
to indicate that completion should be retried by returning an
exit status of 124.
If a shell function returns 124, and changes
the compspec associated with the command on which completion is being
attempted (supplied as the first argument when the function is executed),
programmable completion restarts from the beginning, with an
attempt to find a new compspec for that command.
This can be used to build a set of completions dynamically
as completion is attempted, rather than loading them all at once.
</p>
<p>For instance, assuming that there is a library of compspecs, each kept in a
file corresponding to the name of the command, the following default
completion function would load completions dynamically:
</p>
<div class="example">
<pre class="example-preformatted">_completion_loader()
{
    . &quot;/etc/bash_completion.d/$1.sh&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; return 124
}
complete -D -F _completion_loader -o bashdefault -o default
</pre></div>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Programmable-Completion-Builtins.html">Programmable Completion Builtins</a>, Previous: <a href="Readline-vi-Mode.html">Readline vi Mode</a>, Up: <a href="Command-Line-Editing.html">Command Line Editing</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Indexes.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
