<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This text is a brief description of the features that are present in
the Bash shell (version 5.3, 18 May 2025).

This is Edition 5.3, last updated 18 May 2025,
of The GNU Bash Reference Manual,
for Bash, Version 5.3.

Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled
"GNU Free Documentation License". -->
<title>Shell Parameter Expansion</title>

<meta name="description" content="Shell Parameter Expansion (Bash Reference Manual)">
<meta name="keywords" content="Shell Parameter Expansion (Bash Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Indexes.html" rel="index" title="Indexes">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Shell-Expansions.html" rel="up" title="Shell Expansions">
<link href="Command-Substitution.html" rel="next" title="Command Substitution">
<link href="Tilde-Expansion.html" rel="prev" title="Tilde Expansion">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Shell-Parameter-Expansion">
<div class="nav-panel">
<p>
Next: <a href="Command-Substitution.html" accesskey="n" rel="next">Command Substitution</a>, Previous: <a href="Tilde-Expansion.html" accesskey="p" rel="prev">Tilde Expansion</a>, Up: <a href="Shell-Expansions.html" accesskey="u" rel="up">Shell Expansions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Indexes.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Shell-Parameter-Expansion-1"><span>3.5.3 Shell Parameter Expansion<a class="copiable-link" href="#Shell-Parameter-Expansion-1"> &para;</a></span></h4>
<a class="index-entry-id" id="index-parameter-expansion"></a>
<a class="index-entry-id" id="index-expansion_002c-parameter"></a>

<p>The &lsquo;<samp class="samp">$</samp>&rsquo; character introduces parameter expansion,
command substitution, or arithmetic expansion.
The parameter name
or symbol to be expanded may be enclosed in braces, which
are optional but serve to protect the variable to be expanded from
characters immediately following it which could be
interpreted as part of the name.
For example, if the first positional parameter has the value &lsquo;<samp class="samp">a</samp>&rsquo;,
then <code class="code">${11}</code> expands to the value of the eleventh positional
parameter, while <code class="code">$11</code> expands to &lsquo;<samp class="samp">a1</samp>&rsquo;.
</p>
<p>When braces are used, the matching ending brace is the first &lsquo;<samp class="samp">}</samp>&rsquo;
not escaped by a backslash or within a quoted string, and not within an
embedded arithmetic expansion, command substitution, or parameter
expansion.
</p>
<p>The basic form of parameter expansion is ${<var class="var">parameter</var>},
which substitutes the value of <var class="var">parameter</var>.
The <var class="var">parameter</var> is a shell parameter as described above
(see <a class="pxref" href="Shell-Parameters.html">Shell Parameters</a>) or an array reference (see <a class="pxref" href="Arrays.html">Arrays</a>).
The braces are required when <var class="var">parameter</var>
is a positional parameter with more than one digit,
or when <var class="var">parameter</var> is followed by a character that is not to be
interpreted as part of its name.
</p>
<p>If the first character of <var class="var">parameter</var> is an exclamation point (!),
and <var class="var">parameter</var> is not a nameref,
it introduces a level of indirection.
Bash uses the value formed by expanding the rest of
<var class="var">parameter</var> as the new <var class="var">parameter</var>;
this new parameter is then
expanded and that value is used
in the rest of the expansion, rather
than the expansion of the original <var class="var">parameter</var>.
This is known as <code class="code">indirect expansion</code>.
The value is subject to tilde expansion,
parameter expansion, command substitution, and arithmetic expansion.
If <var class="var">parameter</var> is a nameref, this expands to the name of the
variable referenced by <var class="var">parameter</var> instead of performing the
complete indirect expansion, for compatibility.
The exceptions to this are the expansions of ${!<var class="var">prefix</var>*}
and ${!<var class="var">name</var>[@]}
described below.
The exclamation point must immediately follow the left brace in order to
introduce indirection.
</p>
<p>In each of the cases below, <var class="var">word</var> is subject to tilde expansion,
parameter expansion, command substitution, and arithmetic expansion.
</p>
<p>When not performing substring expansion, using the forms described
below (e.g., &lsquo;<samp class="samp">:-</samp>&rsquo;), Bash tests for a parameter that is unset or null.
Omitting the colon results in a test only for a parameter that is unset.
Put another way, if the colon is included,
the operator tests for both <var class="var">parameter</var>&rsquo;s existence and that its value
is not null; if the colon is omitted, the operator tests only for existence.
</p>
<dl class="table">
<dt><code class="code">${<var class="var">parameter</var>:&minus;<var class="var">word</var>}</code></dt>
<dd><p>If <var class="var">parameter</var> is unset or null, the expansion of
<var class="var">word</var> is substituted.
Otherwise, the value of <var class="var">parameter</var> is substituted.
</p>
<div class="example">
<pre class="example-preformatted">$ v=123
$ echo ${v-unset}
123
$ echo ${v:-unset-or-null}
123
$ unset v
$ echo ${v-unset}
unset
$ v=
$ echo ${v-unset}

$ echo ${v:-unset-or-null}
unset-or-null
</pre></div>

</dd>
<dt><code class="code">${<var class="var">parameter</var>:=<var class="var">word</var>}</code></dt>
<dd><p>If <var class="var">parameter</var> is unset or null, the expansion of <var class="var">word</var>
is assigned to <var class="var">parameter</var>,
and the result of the expansion
is the final value of <var class="var">parameter</var>.
Positional parameters and special parameters may not be assigned
in this way.
</p>
<div class="example">
<pre class="example-preformatted">$ unset var
$ : ${var=DEFAULT}
$ echo $var
DEFAULT
$ var=
$ : ${var=DEFAULT}
$ echo $var

$ var=
$ : ${var:=DEFAULT}
$ echo $var
DEFAULT
$ unset var
$ : ${var:=DEFAULT}
$ echo $var
DEFAULT
</pre></div>

</dd>
<dt><code class="code">${<var class="var">parameter</var>:?<var class="var">word</var>}</code></dt>
<dd><p>If <var class="var">parameter</var>
is null or unset, the shell writes
the expansion of <var class="var">word</var> (or a message
to that effect if <var class="var">word</var>
is not present) to the standard error and, if it
is not interactive, exits with a non-zero status.
An interactive shell does not exit, but does not execute the command
associated with the expansion.
Otherwise, the value of <var class="var">parameter</var> is substituted.
</p>
<div class="example">
<pre class="example-preformatted">$ var=
$ : ${var:?var is unset or null}
bash: var: var is unset or null
$ echo ${var?var is unset}

$ unset var
$ : ${var?var is unset}
bash: var: var is unset
$ : ${var:?var is unset or null}
bash: var: var is unset or null
$ var=123
$ echo ${var:?var is unset or null}
123
</pre></div>

</dd>
<dt><code class="code">${<var class="var">parameter</var>:+<var class="var">word</var>}</code></dt>
<dd><p>If <var class="var">parameter</var>
is null or unset, nothing is substituted, otherwise the expansion of
<var class="var">word</var> is substituted.
The value of <var class="var">parameter</var> is not used.
</p>
<div class="example">
<pre class="example-preformatted">$ var=123
$ echo ${var:+var is set and not null}
var is set and not null
$ echo ${var+var is set}
var is set
$ var=
$ echo ${var:+var is set and not null}

$ echo ${var+var is set}
var is set
$ unset var
$ echo ${var+var is set}

$ echo ${var:+var is set and not null}

$ 
</pre></div>

</dd>
<dt><code class="code">${<var class="var">parameter</var>:<var class="var">offset</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>:<var class="var">offset</var>:<var class="var">length</var>}</code></dt>
<dd><p>This is referred to as Substring Expansion.
It expands to up to <var class="var">length</var> characters of the value of <var class="var">parameter</var>
starting at the character specified by <var class="var">offset</var>.
If <var class="var">parameter</var> is &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;, an indexed array subscripted by
&lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;, or an associative array name, the results differ as
described below.
If :<var class="var">length</var> is omitted (the first form above), this
expands to the substring of the value of
<var class="var">parameter</var> starting at the character specified by <var class="var">offset</var>
and extending to the end of the value.
If <var class="var">offset</var> is omitted,
it is treated as 0.
If <var class="var">length</var> is omitted,
but the colon after <var class="var">offset</var> is present,
it is treated as 0.
<var class="var">length</var> and <var class="var">offset</var> are arithmetic expressions
(see <a class="pxref" href="Shell-Arithmetic.html">Shell Arithmetic</a>).
</p>
<p>If <var class="var">offset</var> evaluates to a number less than zero, the value
is used as an offset in characters
from the end of the value of <var class="var">parameter</var>.
If <var class="var">length</var> evaluates to a number less than zero,
it is interpreted as an offset in characters
from the end of the value of <var class="var">parameter</var> rather than
a number of characters, and the expansion is the characters between
<var class="var">offset</var> and that result.
</p>
<p>Note that a negative offset must be separated from the colon by at least
one space to avoid being confused with the &lsquo;<samp class="samp">:-</samp>&rsquo; expansion.
</p>
<p>Here are some examples illustrating substring expansion on parameters and
subscripted arrays:
</p>
<pre class="verbatim">$ string=01234567890abcdefgh
$ echo ${string:7}
7890abcdefgh
$ echo ${string:7:0}

$ echo ${string:7:2}
78
$ echo ${string:7:-2}
7890abcdef
$ echo ${string: -7}
bcdefgh
$ echo ${string: -7:0}

$ echo ${string: -7:2}
bc
$ echo ${string: -7:-2}
bcdef
$ set -- 01234567890abcdefgh
$ echo ${1:7}
7890abcdefgh
$ echo ${1:7:0}

$ echo ${1:7:2}
78
$ echo ${1:7:-2}
7890abcdef
$ echo ${1: -7}
bcdefgh
$ echo ${1: -7:0}

$ echo ${1: -7:2}
bc
$ echo ${1: -7:-2}
bcdef
$ array[0]=01234567890abcdefgh
$ echo ${array[0]:7}
7890abcdefgh
$ echo ${array[0]:7:0}

$ echo ${array[0]:7:2}
78
$ echo ${array[0]:7:-2}
7890abcdef
$ echo ${array[0]: -7}
bcdefgh
$ echo ${array[0]: -7:0}

$ echo ${array[0]: -7:2}
bc
$ echo ${array[0]: -7:-2}
bcdef
</pre>
<p>If <var class="var">parameter</var> is &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;, the result is <var class="var">length</var>
positional parameters beginning at <var class="var">offset</var>.
A negative <var class="var">offset</var> is taken relative to one greater than the greatest
positional parameter, so an offset of -1 evaluates to the last positional
parameter (or 0 if there are no positional parameters).
It is an expansion error if <var class="var">length</var> evaluates to a number less than zero.
</p>
<p>The following examples illustrate substring expansion using positional
parameters:
</p>
<pre class="verbatim">$ set -- 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
$ echo ${@:7}
7 8 9 0 a b c d e f g h
$ echo ${@:7:0}

$ echo ${@:7:2}
7 8
$ echo ${@:7:-2}
bash: -2: substring expression &lt; 0
$ echo ${@: -7:2}
b c
$ echo ${@:0}
./bash 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
$ echo ${@:0:2}
./bash 1
$ echo ${@: -7:0}

</pre>
<p>If <var class="var">parameter</var> is an indexed array name subscripted
by &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;, the result is the <var class="var">length</var>
members of the array beginning with <code class="code">${<var class="var">parameter</var>[<var class="var">offset</var>]}</code>.
A negative <var class="var">offset</var> is taken relative to one greater than the maximum
index of the specified array.
It is an expansion error if <var class="var">length</var> evaluates to a number less than zero.
</p>
<p>These examples show how you can use substring expansion with indexed
arrays:
</p>
<pre class="verbatim">$ array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h)
$ echo ${array[@]:7}
7 8 9 0 a b c d e f g h
$ echo ${array[@]:7:2}
7 8
$ echo ${array[@]: -7:2}
b c
$ echo ${array[@]: -7:-2}
bash: -2: substring expression &lt; 0
$ echo ${array[@]:0}
0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
$ echo ${array[@]:0:2}
0 1
$ echo ${array[@]: -7:0}

</pre>
<p>Substring expansion applied to an associative array produces undefined
results.
</p>
<p>Substring indexing is zero-based unless the positional parameters
are used, in which case the indexing starts at 1 by default.
If <var class="var">offset</var> is 0, and the positional parameters are used, <code class="code">$0</code> is
prefixed to the list.
</p>
</dd>
<dt><code class="code">${!<var class="var">prefix</var>*}</code></dt>
<dt><code class="code">${!<var class="var">prefix</var>@}</code></dt>
<dd><p>Expands to the names of variables whose names begin with <var class="var">prefix</var>,
separated by the first character of the <code class="env">IFS</code> special variable.
When &lsquo;<samp class="samp">@</samp>&rsquo; is used and the expansion appears within double quotes, each
variable name expands to a separate word.
</p>
</dd>
<dt><code class="code">${!<var class="var">name</var>[@]}</code></dt>
<dt><code class="code">${!<var class="var">name</var>[*]}</code></dt>
<dd><p>If <var class="var">name</var> is an array variable, expands to the list of array indices
(keys) assigned in <var class="var">name</var>.
If <var class="var">name</var> is not an array, expands to 0 if <var class="var">name</var> is set and null
otherwise.
When &lsquo;<samp class="samp">@</samp>&rsquo; is used and the expansion appears within double quotes, each
key expands to a separate word.
</p>
</dd>
<dt><code class="code">${#<var class="var">parameter</var>}</code></dt>
<dd><p>Substitutes the length in characters of the value of <var class="var">parameter</var>.
If <var class="var">parameter</var> is &lsquo;<samp class="samp">*</samp>&rsquo; or &lsquo;<samp class="samp">@</samp>&rsquo;, the value substituted
is the number of positional parameters.
If <var class="var">parameter</var> is an array name subscripted by &lsquo;<samp class="samp">*</samp>&rsquo; or &lsquo;<samp class="samp">@</samp>&rsquo;, 
the value substituted is the number of elements in the array.
If <var class="var">parameter</var>
is an indexed array name subscripted by a negative number, that number is
interpreted as relative to one greater than the maximum index of
<var class="var">parameter</var>, so negative indices count back from the end of the
array, and an index of -1 references the last element.
</p>
</dd>
<dt><code class="code">${<var class="var">parameter</var>#<var class="var">word</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>##<var class="var">word</var>}</code></dt>
<dd><p>The <var class="var">word</var>
is expanded to produce a pattern and matched
against the expanded value of <var class="var">parameter</var>
according to the rules
described below (see <a class="pxref" href="Pattern-Matching.html">Pattern Matching</a>).
If the pattern matches
the beginning of the expanded value of <var class="var">parameter</var>,
then the result of the expansion is the expanded value of <var class="var">parameter</var>
with the shortest matching pattern (the &lsquo;<samp class="samp">#</samp>&rsquo; case) or the
longest matching pattern (the &lsquo;<samp class="samp">##</samp>&rsquo; case) deleted.
If <var class="var">parameter</var> is &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the pattern removal operation is applied to each positional
parameter in turn, and the expansion is the resultant list.
If <var class="var">parameter</var> is an array variable subscripted with
&lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the pattern removal operation is applied to each member of the
array in turn, and the expansion is the resultant list.
</p>
</dd>
<dt><code class="code">${<var class="var">parameter</var>%<var class="var">word</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>%%<var class="var">word</var>}</code></dt>
<dd><p>The <var class="var">word</var>
is expanded to produce a pattern and matched
against the expanded value of <var class="var">parameter</var>
according to the rules
described below (see <a class="pxref" href="Pattern-Matching.html">Pattern Matching</a>).
If the pattern matches a trailing portion of the expanded value of
<var class="var">parameter</var>, then the result of the expansion is the value of
<var class="var">parameter</var> with the shortest matching pattern (the &lsquo;<samp class="samp">%</samp>&rsquo; case)
or the longest matching pattern (the &lsquo;<samp class="samp">%%</samp>&rsquo; case) deleted.
If <var class="var">parameter</var> is &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the pattern removal operation is applied to each positional
parameter in turn, and the expansion is the resultant list.
If <var class="var">parameter</var>
is an array variable subscripted with &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the pattern removal operation is applied to each member of the
array in turn, and the expansion is the resultant list.
</p>
</dd>
<dt><code class="code">${<var class="var">parameter</var>/<var class="var">pattern</var>/<var class="var">string</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>//<var class="var">pattern</var>/<var class="var">string</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>/#<var class="var">pattern</var>/<var class="var">string</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>/%<var class="var">pattern</var>/<var class="var">string</var>}</code></dt>
<dd><p>The <var class="var">pattern</var> is expanded to produce a pattern
and matched against the expanded value of <var class="var">parameter</var>
as described below (see <a class="pxref" href="Pattern-Matching.html">Pattern Matching</a>).
The longest match of <var class="var">pattern</var>
in the expanded value is replaced with <var class="var">string</var>.
<var class="var">string</var> undergoes tilde expansion, parameter and variable expansion,
arithmetic expansion, command and process substitution, and quote removal.
</p>
<p>In the first form above, only the first match is replaced.
If there are two slashes separating <var class="var">parameter</var> and <var class="var">pattern</var>
(the second form above), all matches of <var class="var">pattern</var> are
replaced with <var class="var">string</var>.
If <var class="var">pattern</var> is preceded by &lsquo;<samp class="samp">#</samp>&rsquo; (the third form above),
it must match at the beginning of the expanded value of <var class="var">parameter</var>.
If <var class="var">pattern</var> is preceded by &lsquo;<samp class="samp">%</samp>&rsquo; (the fourth form above),
it must match at the end of the expanded value of <var class="var">parameter</var>.
</p>
<p>If the expansion of <var class="var">string</var> is null,
matches of <var class="var">pattern</var> are deleted
and the &lsquo;<samp class="samp">/</samp>&rsquo; following <var class="var">pattern</var> may be omitted.
</p>
<p>If the <code class="code">patsub_replacement</code> shell option is enabled using <code class="code">shopt</code>
(see <a class="pxref" href="The-Shopt-Builtin.html">The Shopt Builtin</a>),
any unquoted instances of &lsquo;<samp class="samp">&amp;</samp>&rsquo; in <var class="var">string</var> are replaced with the
matching portion of <var class="var">pattern</var>.
This is intended to duplicate a common <code class="code">sed</code> idiom.
</p>
<p>Quoting any part of <var class="var">string</var> inhibits replacement in the
expansion of the quoted portion, including replacement strings stored
in shell variables.
Backslash escapes &lsquo;<samp class="samp">&amp;</samp>&rsquo; in <var class="var">string</var>; the backslash is removed
in order to permit a literal &lsquo;<samp class="samp">&amp;</samp>&rsquo; in the replacement string.
Users should take care if <var class="var">string</var> is double-quoted to avoid
unwanted interactions between the backslash and double-quoting, since
backslash has special meaning within double quotes.
Pattern substitution performs the check for unquoted &lsquo;<samp class="samp">&amp;</samp>&rsquo; after
expanding <var class="var">string</var>,
so users should ensure to properly quote any occurrences of &lsquo;<samp class="samp">&amp;</samp>&rsquo;
they want to be taken literally in the replacement
and ensure any instances of &lsquo;<samp class="samp">&amp;</samp>&rsquo; they want to be replaced are unquoted.
</p>
<p>For instance,
</p>
<div class="example">
<pre class="example-preformatted">var=abcdef
rep='&amp; '
echo ${var/abc/&amp; }
echo &quot;${var/abc/&amp; }&quot;
echo ${var/abc/$rep}
echo &quot;${var/abc/$rep}&quot;
</pre></div>

<p>will display four lines of &quot;abc def&quot;, while
</p>
<div class="example">
<pre class="example-preformatted">var=abcdef
rep='&amp; '
echo ${var/abc/\&amp; }
echo &quot;${var/abc/\&amp; }&quot;
echo ${var/abc/&quot;&amp; &quot;}
echo ${var/abc/&quot;$rep&quot;}
</pre></div>

<p>will display four lines of &quot;&amp; def&quot;.
Like the pattern removal operators, double quotes surrounding the
replacement string quote the expanded characters, while double quotes
enclosing the entire parameter substitution do not, since
the expansion is performed in a
context that doesn&rsquo;t take any enclosing double quotes into account.
</p>
<p>Since backslash can escape &lsquo;<samp class="samp">&amp;</samp>&rsquo;, it can also escape a backslash in
the replacement string.
This means that &lsquo;<samp class="samp">\\</samp>&rsquo; will insert a literal
backslash into the replacement, so these two <code class="code">echo</code> commands
</p>
<div class="example">
<pre class="example-preformatted">var=abcdef
rep='\\&amp;xyz'
echo ${var/abc/\\&amp;xyz}
echo ${var/abc/$rep}
</pre></div>

<p>will both output &lsquo;<samp class="samp">\abcxyzdef</samp>&rsquo;.
</p>
<p>It should rarely be necessary to enclose only <var class="var">string</var> in double
quotes.
</p>
<p>If the <code class="code">nocasematch</code> shell option   
(see the description of <code class="code">shopt</code> in <a class="ref" href="The-Shopt-Builtin.html">The Shopt Builtin</a>)
is enabled, the match is performed without regard to the case   
of alphabetic characters.
</p>
<p>If <var class="var">parameter</var> is &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the substitution operation is applied to each positional
parameter in turn, and the expansion is the resultant list.
If <var class="var">parameter</var>
is an array variable subscripted with &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the substitution operation is applied to each member of the
array in turn, and the expansion is the resultant list.
</p>
</dd>
<dt><code class="code">${<var class="var">parameter</var>^<var class="var">pattern</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>^^<var class="var">pattern</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>,<var class="var">pattern</var>}</code></dt>
<dt><code class="code">${<var class="var">parameter</var>,,<var class="var">pattern</var>}</code></dt>
<dd><p>This expansion modifies the case of alphabetic characters in <var class="var">parameter</var>.
First, the <var class="var">pattern</var> is expanded to produce a pattern
as described below in <a class="ref" href="Pattern-Matching.html">Pattern Matching</a>.
</p>
<p><code class="code">Bash</code>
then examines characters in the expanded value of <var class="var">parameter</var>
against <var class="var">pattern</var> as described below.
If a character matches the pattern, its case is converted.
The pattern should not attempt to match more than one character.
</p>
<p>Using
&lsquo;<samp class="samp">^</samp>&rsquo;
converts lowercase letters matching <var class="var">pattern</var> to uppercase;
&lsquo;<samp class="samp">,</samp>&rsquo;
converts matching uppercase letters to lowercase.
The
&lsquo;<samp class="samp">^</samp>&rsquo; and &lsquo;<samp class="samp">,</samp>&rsquo; variants
examine the first character in the expanded value
and convert its case if it matches <var class="var">pattern</var>;
the
&lsquo;<samp class="samp">^^</samp>&rsquo; and &lsquo;<samp class="samp">,,</samp>&rsquo; variants
examine all characters in the expanded value
and convert each one that matches <var class="var">pattern</var>.
If <var class="var">pattern</var> is omitted, it is treated like a &lsquo;<samp class="samp">?</samp>&rsquo;, which matches
every character.
</p>
<p>If <var class="var">parameter</var> is &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the case modification operation is applied to each positional
parameter in turn, and the expansion is the resultant list.
If <var class="var">parameter</var>
is an array variable subscripted with &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the case modification operation is applied to each member of the
array in turn, and the expansion is the resultant list.
</p>
</dd>
<dt><code class="code">${<var class="var">parameter</var>@<var class="var">operator</var>}</code></dt>
<dd><p>The expansion is either a transformation of the value of <var class="var">parameter</var>
or information about <var class="var">parameter</var> itself, depending on the value of
<var class="var">operator</var>.  Each <var class="var">operator</var> is a single letter:
</p>
<dl class="table">
<dt><code class="code">U</code></dt>
<dd><p>The expansion is a string that is the value of <var class="var">parameter</var> with lowercase
alphabetic characters converted to uppercase.
</p></dd>
<dt><code class="code">u</code></dt>
<dd><p>The expansion is a string that is the value of <var class="var">parameter</var> with the first
character converted to uppercase, if it is alphabetic.
</p></dd>
<dt><code class="code">L</code></dt>
<dd><p>The expansion is a string that is the value of <var class="var">parameter</var> with uppercase
alphabetic characters converted to lowercase.
</p></dd>
<dt><code class="code">Q</code></dt>
<dd><p>The expansion is a string that is the value of <var class="var">parameter</var> quoted in a
format that can be reused as input.
</p></dd>
<dt><code class="code">E</code></dt>
<dd><p>The expansion is a string that is the value of <var class="var">parameter</var> with backslash
escape sequences expanded as with the <code class="code">$'&hellip;'</code> quoting mechanism.
</p></dd>
<dt><code class="code">P</code></dt>
<dd><p>The expansion is a string that is the result of expanding the value of
<var class="var">parameter</var> as if it were a prompt string (see <a class="pxref" href="Controlling-the-Prompt.html">Controlling the Prompt</a>).
</p></dd>
<dt><code class="code">A</code></dt>
<dd><p>The expansion is a string in the form of
an assignment statement or <code class="code">declare</code> command that, if
evaluated, recreates <var class="var">parameter</var> with its attributes and value.
</p></dd>
<dt><code class="code">K</code></dt>
<dd><p>Produces a possibly-quoted version of the value of <var class="var">parameter</var>,
except that it prints the values of
indexed and associative arrays as a sequence of quoted key-value pairs
(see <a class="pxref" href="Arrays.html">Arrays</a>).
The keys and values are quoted in a format that can be reused as input.
</p></dd>
<dt><code class="code">a</code></dt>
<dd><p>The expansion is a string consisting of flag values representing
<var class="var">parameter</var>&rsquo;s attributes.
</p></dd>
<dt><code class="code">k</code></dt>
<dd><p>Like the &lsquo;<samp class="samp">K</samp>&rsquo; transformation, but expands the keys and values of
indexed and associative arrays to separate words after word splitting.
</p></dd>
</dl>

<p>If <var class="var">parameter</var> is &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the operation is applied to each positional
parameter in turn, and the expansion is the resultant list.
If <var class="var">parameter</var>
is an array variable subscripted with &lsquo;<samp class="samp">@</samp>&rsquo; or &lsquo;<samp class="samp">*</samp>&rsquo;,
the operation is applied to each member of the
array in turn, and the expansion is the resultant list.
</p>
<p>The result of the expansion is subject to word splitting and filename
expansion as described below.
</p></dd>
</dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Command-Substitution.html">Command Substitution</a>, Previous: <a href="Tilde-Expansion.html">Tilde Expansion</a>, Up: <a href="Shell-Expansions.html">Shell Expansions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Indexes.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
