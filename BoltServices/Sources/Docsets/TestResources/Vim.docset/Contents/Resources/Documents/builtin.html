<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Vim documentation: builtin</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Vim documentation: builtin</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="builtin.txt"></A><B>builtin.txt</B>*	For Vim version 9.0.  Last change: 2022 Jun 27


		  VIM REFERENCE MANUAL	  by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>



Builtin <A HREF="eval.html#functions">functions</A>				*<A NAME="builtin-functions"></A><B>builtin-functions</B>*

Note: Expression evaluation can be disabled at compile time.  If this has been
done, the builtin <A HREF="eval.html#functions">functions</A> are not available.  See |<A HREF="various.html#+eval">+eval</A>| and
|<A HREF="eval.html#no-eval-feature">no-eval-feature</A>|.

1. Overview				|<A HREF="#builtin-function-list">builtin-function-list</A>|
2. Details				|<A HREF="#builtin-function-details">builtin-function-details</A>|
3. Feature list				|<A HREF="#feature-list">feature-list</A>|
4. Matching a <A HREF="pattern.html#pattern">pattern</A> in a <A HREF="eval.html#String">String</A>	|<A HREF="#string-match">string-match</A>|

==============================================================================

1. Overview					*<A NAME="builtin-function-list"></A><B>builtin-function-list</B>*

Use <A HREF="tagsrch.html#CTRL-]">CTRL-]</A> on the function name to jump to the full explanation.

<B><FONT COLOR="PURPLE">USAGE				RESULT	DESCRIPTION	</FONT></B>

abs({expr})			<A HREF="eval.html#Float">Float</A> or <A HREF="eval.html#Number">Number</A>  absolute value of {expr}
acos({expr})			<A HREF="eval.html#Float">Float</A>	arc cosine of {expr}
add({object}, {item})		List/Blob   append {item} to {object}
and({expr}, {expr})		<A HREF="eval.html#Number">Number</A>	bitwise AND
append({lnum}, {text})		<A HREF="eval.html#Number">Number</A>	append {text} below line {lnum}
appendbufline({expr}, {lnum}, {text})
				<A HREF="eval.html#Number">Number</A>	append {text} below line {lnum}
					in buffer {expr}
argc([{winid}])			<A HREF="eval.html#Number">Number</A>	number of files in the argument <A HREF="eval.html#list">list</A>
<A HREF="#argidx()">argidx()</A>			<A HREF="eval.html#Number">Number</A>	current index in the argument <A HREF="eval.html#list">list</A>
arglistid([{winnr} [, {tabnr}]]) <A HREF="eval.html#Number">Number</A>	argument <A HREF="eval.html#list">list</A> id
argv({nr} [, {winid}])		<A HREF="eval.html#String">String</A>	{nr} entry of the argument <A HREF="eval.html#list">list</A>
argv([-1, {winid}])		<A HREF="eval.html#List">List</A>	the argument <A HREF="eval.html#list">list</A>
asin({expr})			<A HREF="eval.html#Float">Float</A>	arc sine of {expr}
assert_beeps({cmd})		<A HREF="eval.html#Number">Number</A>	assert {cmd} causes a beep
assert_equal({exp}, {act} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert {exp} is equal to {act}
assert_equalfile({fname-one}, {fname-two} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert file contents are equal
assert_exception({error} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert {error} is in <A HREF="eval.html#v:exception">v:exception</A>
assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])
				<A HREF="eval.html#Number">Number</A>	assert {cmd} fails
assert_false({actual} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert {actual} is <A HREF="vim9.html#false">false</A>
assert_inrange({lower}, {upper}, {actual} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert {actual} is inside the range
assert_match({pat}, {text} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert {pat} matches {text}
assert_nobeep({cmd})		<A HREF="eval.html#Number">Number</A>	assert {cmd} does not cause a beep
assert_notequal({exp}, {act} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert {exp} is not equal {act}
assert_notmatch({pat}, {text} [, {msg}])
				<A HREF="eval.html#Number">Number</A>	assert {pat} not matches {text}
assert_report({msg})		<A HREF="eval.html#Number">Number</A>	report a test failure
assert_true({actual} [, {msg}])	<A HREF="eval.html#Number">Number</A>	assert {actual} is <A HREF="vim9.html#true">true</A>
atan({expr})			<A HREF="eval.html#Float">Float</A>	arc tangent of {expr}
atan2({expr1}, {expr2})		<A HREF="eval.html#Float">Float</A>	arc tangent of {expr1} / {expr2}
autocmd_add({acmds})		Bool	add a <A HREF="eval.html#list">list</A> of autocmds and groups
autocmd_delete({acmds})		Bool	delete a <A HREF="eval.html#list">list</A> of autocmds and groups
autocmd_get([{opts}])		<A HREF="eval.html#List">List</A>	return a <A HREF="eval.html#list">list</A> of autocmds
<A HREF="#balloon_gettext()">balloon_gettext()</A>		<A HREF="eval.html#String">String</A>	current text in the balloon
balloon_show({expr})		none	show {expr} inside the balloon
balloon_split({msg})		<A HREF="eval.html#List">List</A>	split {msg} <A HREF="motion.html#as">as</A> used for a balloon
blob2list({blob})		<A HREF="eval.html#List">List</A>	convert {blob} into a <A HREF="eval.html#list">list</A> of numbers
browse({save}, {title}, {initdir}, {default})
				<A HREF="eval.html#String">String</A>	put up a file requester
browsedir({title}, {initdir})	<A HREF="eval.html#String">String</A>	put up a directory requester
bufadd({name})			<A HREF="eval.html#Number">Number</A>	add a buffer to the buffer <A HREF="eval.html#list">list</A>
bufexists({buf})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if buffer {buf} exists
buflisted({buf})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if buffer {buf} is listed
bufload({buf})			<A HREF="eval.html#Number">Number</A>	load buffer {buf} if not loaded yet
bufloaded({buf})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if buffer {buf} is loaded
bufname([{buf}])		<A HREF="eval.html#String">String</A>	Name of the buffer {buf}
bufnr([{buf} [, {create}]])	<A HREF="eval.html#Number">Number</A>	<A HREF="eval.html#Number">Number</A> of the buffer {buf}
bufwinid({buf})			<A HREF="eval.html#Number">Number</A>	<A HREF="windows.html#window">window</A> ID of buffer {buf}
bufwinnr({buf})			<A HREF="eval.html#Number">Number</A>	<A HREF="windows.html#window">window</A> number of buffer {buf}
byte2line({byte})		<A HREF="eval.html#Number">Number</A>	line number at byte <A HREF="intro.html#count">count</A> {byte}
byteidx({expr}, {nr})		<A HREF="eval.html#Number">Number</A>	byte index of {nr}'th char in {expr}
byteidxcomp({expr}, {nr})	<A HREF="eval.html#Number">Number</A>	byte index of {nr}'th char in {expr}
call({func}, <A HREF="editing.html#{arglist}">{arglist}</A> [, {dict}])
				any	call {func} with arguments <A HREF="editing.html#{arglist}">{arglist}</A>
ceil({expr})			<A HREF="eval.html#Float">Float</A>	round {expr} up
ch_canread({handle})		<A HREF="eval.html#Number">Number</A>	check if there is something to read
ch_close({handle})		none	close {handle}
ch_close_in({handle})		none	close in part of {handle}
ch_evalexpr({handle}, {expr} [, {options}])
				any	evaluate {expr} on JSON {handle}
ch_evalraw({handle}, {string} [, {options}])
				any	evaluate {string} on raw {handle}
ch_getbufnr({handle}, {what})	<A HREF="eval.html#Number">Number</A>	get buffer number for {handle}/{what}
ch_getjob({channel})		<A HREF="eval.html#Job">Job</A>	get the <A HREF="eval.html#Job">Job</A> of {channel}
ch_info({handle})		<A HREF="eval.html#String">String</A>	info about <A HREF="channel.html#channel">channel</A> {handle}
ch_log({msg} [, {handle}])	none	write {msg} in the <A HREF="channel.html#channel">channel</A> log file
ch_logfile({fname} [, {mode}])	none	start logging <A HREF="channel.html#channel">channel</A> activity
ch_open({address} [, {options}])
				<A HREF="eval.html#Channel">Channel</A>	open a <A HREF="channel.html#channel">channel</A> to <A HREF="cmdline.html#{address}">{address}</A>
ch_read({handle} [, {options}]) <A HREF="eval.html#String">String</A>	read from {handle}
ch_readblob({handle} [, {options}])
				<A HREF="eval.html#Blob">Blob</A>	read <A HREF="eval.html#Blob">Blob</A> from {handle}
ch_readraw({handle} [, {options}])
				<A HREF="eval.html#String">String</A>	read raw from {handle}
ch_sendexpr({handle}, {expr} [, {options}])
				any	send {expr} over JSON {handle}
ch_sendraw({handle}, {expr} [, {options}])
				any	send {expr} over raw {handle}
ch_setoptions({handle}, {options})
				none	set <A HREF="options.html#options">options</A> for {handle}
ch_status({handle} [, {options}])
				<A HREF="eval.html#String">String</A>	status of <A HREF="channel.html#channel">channel</A> {handle}
<A HREF="#changenr()">changenr()</A>			<A HREF="eval.html#Number">Number</A>	current change number
char2nr({expr} [, {utf8}])	<A HREF="eval.html#Number">Number</A>	ASCII/UTF-8 value of first char in {expr}
charclass({string})		<A HREF="eval.html#Number">Number</A>	character class of {string}
charcol({expr})			<A HREF="eval.html#Number">Number</A>	column number of cursor or <A HREF="motion.html#mark">mark</A>
charidx({string}, {idx} [, {countcc}])
				<A HREF="eval.html#Number">Number</A>	char index of byte {idx} in {string}
chdir({dir})			<A HREF="eval.html#String">String</A>	change current working directory
cindent({lnum})			<A HREF="eval.html#Number">Number</A>	C indent for line {lnum}
clearmatches([{win}])		none	clear all matches
col({expr})			<A HREF="eval.html#Number">Number</A>	column byte index of cursor or <A HREF="motion.html#mark">mark</A>
complete({startcol}, {matches}) none	set <A HREF="insert.html#Insert">Insert</A> mode completion
complete_add({expr})		<A HREF="eval.html#Number">Number</A>	add completion match
<A HREF="#complete_check()">complete_check()</A>		<A HREF="eval.html#Number">Number</A>	check for key typed during completion
complete_info([{what}])		<A HREF="eval.html#Dict">Dict</A>	get current completion information
confirm({msg} [, {choices} [, {default} [, {type}]]])
				<A HREF="eval.html#Number">Number</A>	number of choice picked by user
copy({expr})			any	make a shallow copy of {expr}
cos({expr})			<A HREF="eval.html#Float">Float</A>	cosine of {expr}
cosh({expr})			<A HREF="eval.html#Float">Float</A>	hyperbolic cosine of {expr}
count({comp}, {expr} [, {ic} [, {start}]])
				<A HREF="eval.html#Number">Number</A>	<A HREF="intro.html#count">count</A> how many {expr} are in {comp}
cscope_connection([{num}, {dbpath} [, {prepend}]])
				<A HREF="eval.html#Number">Number</A>	checks existence of <A HREF="if_cscop.html#cscope">cscope</A> connection
cursor({lnum}, {col} [, {off}])
				<A HREF="eval.html#Number">Number</A>	move cursor to {lnum}, {col}, {off}
cursor({list})			<A HREF="eval.html#Number">Number</A>	move cursor to position in {list}
debugbreak({pid})		<A HREF="eval.html#Number">Number</A>	interrupt process being debugged
deepcopy({expr} [, {noref}])	any	make a full copy of {expr}
delete({fname} [, {flags}])	<A HREF="eval.html#Number">Number</A>	delete the file or directory {fname}
deletebufline({buf}, {first} [, {last}])
				<A HREF="eval.html#Number">Number</A>	delete lines from buffer {buf}
<A HREF="#did_filetype()">did_filetype()</A>			<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if <A HREF="autocmd.html#FileType">FileType</A> autocmd event used
diff_filler({lnum})		<A HREF="eval.html#Number">Number</A>	<A HREF="diff.html#diff">diff</A> filler lines about {lnum}
diff_hlID({lnum}, {col})	<A HREF="eval.html#Number">Number</A>	<A HREF="diff.html#diff">diff</A> highlighting at {lnum}/{col}
digraph_get({chars})		<A HREF="eval.html#String">String</A>	get the |<A HREF="digraph.html#digraph">digraph</A>| of {chars}
digraph_getlist([{listall}])	<A HREF="eval.html#List">List</A>	get all |<A HREF="digraph.html#digraph">digraph</A>|<A HREF="change.html#s">s</A>
digraph_set({chars}, {digraph})	<A HREF="eval.html#Boolean">Boolean</A>	<A HREF="sponsor.html#register">register</A> |<A HREF="digraph.html#digraph">digraph</A>|
digraph_setlist({digraphlist})	<A HREF="eval.html#Boolean">Boolean</A>	<A HREF="sponsor.html#register">register</A> multiple |<A HREF="digraph.html#digraph">digraph</A>|<A HREF="change.html#s">s</A>
echoraw({expr})			none	output {expr} as-is
empty({expr})			<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {expr} is empty
<A HREF="#environ()">environ()</A>			<A HREF="eval.html#Dict">Dict</A>	return environment <A HREF="eval.html#variables">variables</A>
escape({string}, {chars})	<A HREF="eval.html#String">String</A>	<A HREF="intro.html#escape">escape</A> {chars} in {string} with '\'
eval({string})			any	evaluate {string} into its value
<A HREF="#eventhandler()">eventhandler()</A>			<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if inside an event handler
executable({expr})		<A HREF="eval.html#Number">Number</A>	1 if executable {expr} exists
execute({command})		<A HREF="eval.html#String">String</A>	execute {command} and get the output
exepath({expr})			<A HREF="eval.html#String">String</A>	full path of the command {expr}
exists({expr})			<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {expr} exists
exists_compiled({expr})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {expr} exists at compile time
exp({expr})			<A HREF="eval.html#Float">Float</A>	exponential of {expr}
expand({expr} [, {nosuf} [, {list}]])
				any	expand special keywords in {expr}
expandcmd({string} [, {options}])
				<A HREF="eval.html#String">String</A>	expand {string} like with `:edit`
extend({expr1}, {expr2} [, {expr3}])
				List/Dict insert items of {expr2} into {expr1}
extendnew({expr1}, {expr2} [, {expr3}])
				List/Dict like |<A HREF="#extend()">extend()</A>| but creates a new
					<A HREF="eval.html#List">List</A> or <A HREF="eval.html#Dictionary">Dictionary</A>
feedkeys({string} [, {mode}])	<A HREF="eval.html#Number">Number</A>	add key sequence to typeahead buffer
filereadable({file})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if <A HREF="editing.html#{file}">{file}</A> is a readable file
filewritable({file})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if <A HREF="editing.html#{file}">{file}</A> is a writable file
filter({expr1}, {expr2})	List/Dict/Blob/String
					remove items from {expr1} where
					{expr2} is 0
finddir({name} [, {path} [, {count}]])
				<A HREF="eval.html#String">String</A>	find directory {name} in {path}
findfile({name} [, {path} [, {count}]])
				<A HREF="eval.html#String">String</A>	find file {name} in {path}
flatten({list} [, {maxdepth}])	<A HREF="eval.html#List">List</A>	flatten {list} up to {maxdepth} levels
flattennew({list} [, {maxdepth}])
				<A HREF="eval.html#List">List</A>	flatten a copy of {list}
float2nr({expr})		<A HREF="eval.html#Number">Number</A>	convert <A HREF="eval.html#Float">Float</A> {expr} to a <A HREF="eval.html#Number">Number</A>
floor({expr})			<A HREF="eval.html#Float">Float</A>	round {expr} down
fmod({expr1}, {expr2})		<A HREF="eval.html#Float">Float</A>	remainder of {expr1} / {expr2}
fnameescape({fname})		<A HREF="eval.html#String">String</A>	<A HREF="intro.html#escape">escape</A> special characters in {fname}
fnamemodify({fname}, {mods})	<A HREF="eval.html#String">String</A>	modify file name
foldclosed({lnum})		<A HREF="eval.html#Number">Number</A>	first line of fold at {lnum} if closed
foldclosedend({lnum})		<A HREF="eval.html#Number">Number</A>	last line of fold at {lnum} if closed
foldlevel({lnum})		<A HREF="eval.html#Number">Number</A>	fold level at {lnum}
<A HREF="#foldtext()">foldtext()</A>			<A HREF="eval.html#String">String</A>	line displayed for closed fold
foldtextresult({lnum})		<A HREF="eval.html#String">String</A>	text for closed fold at {lnum}
<A HREF="#foreground()">foreground()</A>			<A HREF="eval.html#Number">Number</A>	bring the Vim <A HREF="windows.html#window">window</A> to the foreground
fullcommand({name})		<A HREF="eval.html#String">String</A>	get full command from {name}
funcref({name} [, {arglist}] [, {dict}])
				<A HREF="eval.html#Funcref">Funcref</A>	reference to function {name}
function({name} [, {arglist}] [, {dict}])
				<A HREF="eval.html#Funcref">Funcref</A>	named reference to function {name}
garbagecollect([{atexit}])	none	free memory, breaking cyclic references
get({list}, {idx} [, {def}])	any	get item {idx} from {list} or {def}
get({dict}, {key} [, {def}])	any	get item {key} from {dict} or {def}
get({func}, {what})		any	get property of funcref/partial {func}
getbufinfo([{buf}])		<A HREF="eval.html#List">List</A>	information about <A HREF="windows.html#buffers">buffers</A>
getbufline({buf}, {lnum} [, {end}])
				<A HREF="eval.html#List">List</A>	lines {lnum} to {end} of buffer {buf}
getbufvar({buf}, {varname} [, {def}])
				any	variable {varname} in buffer {buf}
getchangelist([{buf}])		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of change <A HREF="eval.html#list">list</A> items
getchar([expr])			<A HREF="eval.html#Number">Number</A> or <A HREF="eval.html#String">String</A>
					get one character from the user
<A HREF="#getcharmod()">getcharmod()</A>			<A HREF="eval.html#Number">Number</A>	modifiers for the last typed character
getcharpos({expr})		<A HREF="eval.html#List">List</A>	position of cursor, <A HREF="motion.html#mark">mark</A>, etc.
<A HREF="#getcharsearch()">getcharsearch()</A>			<A HREF="eval.html#Dict">Dict</A>	last character search
getcharstr([expr])		<A HREF="eval.html#String">String</A>	get one character from the user
<A HREF="#getcmdcompltype()">getcmdcompltype()</A>		<A HREF="eval.html#String">String</A>	return the type of the current
					command-line completion
<A HREF="#getcmdline()">getcmdline()</A>			<A HREF="eval.html#String">String</A>	return the current command-line
<A HREF="#getcmdpos()">getcmdpos()</A>			<A HREF="eval.html#Number">Number</A>	return cursor position in command-line
<A HREF="#getcmdscreenpos()">getcmdscreenpos()</A>		<A HREF="eval.html#Number">Number</A>	return cursor screen position in
					command-line
<A HREF="#getcmdtype()">getcmdtype()</A>			<A HREF="eval.html#String">String</A>	return current command-line type
<A HREF="#getcmdwintype()">getcmdwintype()</A>			<A HREF="eval.html#String">String</A>	return current command-line <A HREF="windows.html#window">window</A> type
getcompletion({pat}, {type} [, {filtered}])
				<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of cmdline completion matches
getcurpos([{winnr}])		<A HREF="eval.html#List">List</A>	position of the cursor
getcursorcharpos([{winnr}])	<A HREF="eval.html#List">List</A>	character position of the cursor
getcwd([{winnr} [, {tabnr}]])	<A HREF="eval.html#String">String</A>	get the current working directory
getenv({name})			<A HREF="eval.html#String">String</A>	return environment variable
getfontname([{name}])		<A HREF="eval.html#String">String</A>	name of font being used
getfperm({fname})		<A HREF="eval.html#String">String</A>	file permissions of file {fname}
getfsize({fname})		<A HREF="eval.html#Number">Number</A>	size in bytes of file {fname}
getftime({fname})		<A HREF="eval.html#Number">Number</A>	last modification time of file
getftype({fname})		<A HREF="eval.html#String">String</A>	description of type of file {fname}
<A HREF="#getimstatus()">getimstatus()</A>			<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if the <A HREF="mbyte.html#IME">IME</A> status is active
getjumplist([{winnr} [, {tabnr}]])
				<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of jump <A HREF="eval.html#list">list</A> items
getline({lnum})			<A HREF="eval.html#String">String</A>	line {lnum} of current buffer
getline({lnum}, {end})		<A HREF="eval.html#List">List</A>	lines {lnum} to {end} of current buffer
getloclist({nr})		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of location <A HREF="eval.html#list">list</A> items
getloclist({nr}, {what})	<A HREF="eval.html#Dict">Dict</A>	get specific location <A HREF="eval.html#list">list</A> properties
getmarklist([{buf}])		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of global/local marks
getmatches([{win}])		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of current matches
<A HREF="#getmousepos()">getmousepos()</A>			<A HREF="eval.html#Dict">Dict</A>	last known mouse position
<A HREF="#getpid()">getpid()</A>			<A HREF="eval.html#Number">Number</A>	process ID of Vim
getpos({expr})			<A HREF="eval.html#List">List</A>	position of cursor, <A HREF="motion.html#mark">mark</A>, etc.
<A HREF="#getqflist()">getqflist()</A>			<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of <A HREF="quickfix.html#quickfix">quickfix</A> items
getqflist({what})		<A HREF="eval.html#Dict">Dict</A>	get specific <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> properties
getreg([{regname} [, 1 [, {list}]]])
				<A HREF="eval.html#String">String</A> or <A HREF="eval.html#List">List</A>   contents of a <A HREF="sponsor.html#register">register</A>
getreginfo([{regname}])		<A HREF="eval.html#Dict">Dict</A>	information about a <A HREF="sponsor.html#register">register</A>
getregtype([{regname}])		<A HREF="eval.html#String">String</A>	type of a <A HREF="sponsor.html#register">register</A>
gettabinfo([{expr}])		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of <A HREF="intro.html#tab">tab</A> pages
gettabvar({nr}, {varname} [, {def}])
				any	variable {varname} in <A HREF="intro.html#tab">tab</A> {nr} or {def}
gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
				any	{name} in {winnr} in <A HREF="intro.html#tab">tab</A> page {tabnr}
gettagstack([{nr}])		<A HREF="eval.html#Dict">Dict</A>	get the <A HREF="tagsrch.html#tag">tag</A> stack of <A HREF="windows.html#window">window</A> {nr}
gettext({text})			<A HREF="eval.html#String">String</A>	lookup translation of {text}
getwininfo([{winid}])		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of info about each <A HREF="windows.html#window">window</A>
getwinpos([{timeout}])		<A HREF="eval.html#List">List</A>	X and <A HREF="change.html#Y">Y</A> coord in pixels of the Vim <A HREF="windows.html#window">window</A>
<A HREF="#getwinposx()">getwinposx()</A>			<A HREF="eval.html#Number">Number</A>	X coord in pixels of the Vim <A HREF="windows.html#window">window</A>
<A HREF="#getwinposy()">getwinposy()</A>			<A HREF="eval.html#Number">Number</A>	<A HREF="change.html#Y">Y</A> coord in pixels of the Vim <A HREF="windows.html#window">window</A>
getwinvar({nr}, {varname} [, {def}])
				any	variable {varname} in <A HREF="windows.html#window">window</A> {nr}
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
				any	expand file <A HREF="editing.html#wildcards">wildcards</A> in {expr}
glob2regpat({expr})		<A HREF="eval.html#String">String</A>	convert a glob pat into a search pat
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
				<A HREF="eval.html#String">String</A>	<A HREF="diff.html#do">do</A> glob({expr}) for all dirs in {path}
has({feature} [, {check}])	<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if feature {feature} supported
has_key({dict}, {key})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {dict} has entry {key}
haslocaldir([{winnr} [, {tabnr}]])
				<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if the <A HREF="windows.html#window">window</A> executed |<A HREF="editing.html#:lcd">:lcd</A>|
					or |<A HREF="editing.html#:tcd">:tcd</A>|
hasmapto({what} [, {mode} [, {abbr}]])
				<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if <A HREF="map.html#mapping">mapping</A> to {what} exists
histadd({history}, {item})	<A HREF="eval.html#Number">Number</A>	add an item to a <A HREF="cmdline.html#history">history</A>
histdel({history} [, {item}])	<A HREF="eval.html#Number">Number</A>	remove an item from a <A HREF="cmdline.html#history">history</A>
histget({history} [, {index}])	<A HREF="eval.html#String">String</A>	get the item {index} from a <A HREF="cmdline.html#history">history</A>
histnr({history})		<A HREF="eval.html#Number">Number</A>	highest index of a <A HREF="cmdline.html#history">history</A>
hlID({name})			<A HREF="eval.html#Number">Number</A>	<A HREF="syntax.html#syntax">syntax</A> ID of highlight group {name}
hlexists({name})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if highlight group {name} exists
hlget([{name} [, {resolve}]])	<A HREF="eval.html#List">List</A>	get highlight group attributes
hlset({list})			<A HREF="eval.html#Number">Number</A>	set highlight group attributes
<A HREF="#hostname()">hostname()</A>			<A HREF="eval.html#String">String</A>	name of the machine Vim is running on
iconv({expr}, {from}, {to})	<A HREF="eval.html#String">String</A>	convert encoding of {expr}
indent({lnum})			<A HREF="eval.html#Number">Number</A>	indent of line {lnum}
index({object}, {expr} [, {start} [, {ic}]])
				<A HREF="eval.html#Number">Number</A>	index in {object} where {expr} appears
input({prompt} [, {text} [, {completion}]])
				<A HREF="eval.html#String">String</A>	get input from the user
inputdialog({prompt} [, {text} [, {completion}]])
				<A HREF="eval.html#String">String</A>	like <A HREF="#input()">input()</A> but in a <A HREF="gui.html#GUI">GUI</A> <A HREF="gui_w32.html#dialog">dialog</A>
inputlist({textlist})		<A HREF="eval.html#Number">Number</A>	let the user pick from a choice <A HREF="eval.html#list">list</A>
<A HREF="#inputrestore()">inputrestore()</A>			<A HREF="eval.html#Number">Number</A>	restore typeahead
<A HREF="#inputsave()">inputsave()</A>			<A HREF="eval.html#Number">Number</A>	save and clear typeahead
inputsecret({prompt} [, {text}]) <A HREF="eval.html#String">String</A>	like <A HREF="#input()">input()</A> but hiding the text
insert({object}, {item} [, {idx}]) <A HREF="eval.html#List">List</A>	insert {item} in {object} [before {idx}]
<A HREF="#interrupt()">interrupt()</A>			none	interrupt <A HREF="usr_41.html#script">script</A> execution
invert({expr})			<A HREF="eval.html#Number">Number</A>	bitwise invert
isabsolutepath({path})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {path} is an absolute path
isdirectory({directory})	<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {directory} is a directory
isinf({expr})			<A HREF="eval.html#Number">Number</A>	determine if {expr} is infinity value
					(positive or negative)
islocked({expr})		<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {expr} is locked
isnan({expr})			<A HREF="eval.html#Number">Number</A>	|<A HREF="eval.html#TRUE">TRUE</A>| if {expr} is NaN
items({dict})			<A HREF="eval.html#List">List</A>	key-value pairs in {dict}
job_getchannel({job})		<A HREF="eval.html#Channel">Channel</A>	get the <A HREF="channel.html#channel">channel</A> handle for {job}
job_info([{job}])		<A HREF="eval.html#Dict">Dict</A>	get information about {job}
job_setoptions({job}, {options}) none	set <A HREF="options.html#options">options</A> for {job}
job_start({command} [, {options}])
				<A HREF="eval.html#Job">Job</A>	start a <A HREF="channel.html#job">job</A>
job_status({job})		<A HREF="eval.html#String">String</A>	get the status of {job}
job_stop({job} [, {how}])	<A HREF="eval.html#Number">Number</A>	stop {job}
join({list} [, {sep}])		<A HREF="eval.html#String">String</A>	join {list} items into one <A HREF="eval.html#String">String</A>
js_decode({string})		any	decode JS style JSON
js_encode({expr})		<A HREF="eval.html#String">String</A>	encode JS style JSON
json_decode({string})		any	decode JSON
json_encode({expr})		<A HREF="eval.html#String">String</A>	encode JSON
keys({dict})			<A HREF="eval.html#List">List</A>	keys in {dict}
len({expr})			<A HREF="eval.html#Number">Number</A>	the length of {expr}
libcall({lib}, {func}, {arg})	<A HREF="eval.html#String">String</A>	call {func} in library {lib} with {arg}
libcallnr({lib}, {func}, {arg})	<A HREF="eval.html#Number">Number</A>	idem, but return a <A HREF="eval.html#Number">Number</A>
line({expr} [, {winid}])	<A HREF="eval.html#Number">Number</A>	line nr of cursor, last line or <A HREF="motion.html#mark">mark</A>
line2byte({lnum})		<A HREF="eval.html#Number">Number</A>	byte <A HREF="intro.html#count">count</A> of line {lnum}
lispindent({lnum})		<A HREF="eval.html#Number">Number</A>	Lisp indent for line {lnum}
list2blob({list})		<A HREF="eval.html#Blob">Blob</A>	turn {list} of numbers into a <A HREF="eval.html#Blob">Blob</A>
list2str({list} [, {utf8}])	<A HREF="eval.html#String">String</A>	turn {list} of numbers into a <A HREF="eval.html#String">String</A>
listener_add({callback} [, {buf}])
				<A HREF="eval.html#Number">Number</A>	add a callback to listen to changes
listener_flush([{buf}])		none	invoke listener callbacks
listener_remove({id})		none	remove a listener callback
<A HREF="#localtime()">localtime()</A>			<A HREF="eval.html#Number">Number</A>	current time
log({expr})			<A HREF="eval.html#Float">Float</A>	natural logarithm (base <A HREF="motion.html#e">e</A>) of {expr}
log10({expr})			<A HREF="eval.html#Float">Float</A>	logarithm of <A HREF="eval.html#Float">Float</A> {expr} to base 10
luaeval({expr} [, {expr}])	any	evaluate |<A HREF="if_lua.html#Lua">Lua</A>| <A HREF="eval.html#expression">expression</A>
map({expr1}, {expr2})		List/Dict/Blob/String
					change each item in {expr1} to {expr2}
maparg({name} [, {mode} [, {abbr} [, {dict}]]])
				<A HREF="eval.html#String">String</A> or <A HREF="eval.html#Dict">Dict</A>
					rhs of <A HREF="map.html#mapping">mapping</A> {name} in mode {mode}
mapcheck({name} [, {mode} [, {abbr}]])
				<A HREF="eval.html#String">String</A>	check for mappings matching {name}
maplist([{abbr}])		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of all mappings, a <A HREF="eval.html#dict">dict</A> for each
mapnew({expr1}, {expr2})	List/Dict/Blob/String
					like |<A HREF="#map()">map()</A>| but creates a new <A HREF="eval.html#List">List</A> or
					<A HREF="eval.html#Dictionary">Dictionary</A>
mapset({mode}, {abbr}, {dict})	none	restore <A HREF="map.html#mapping">mapping</A> from |<A HREF="#maparg()">maparg()</A>| result
match({expr}, {pat} [, {start} [, {count}]])
				<A HREF="eval.html#Number">Number</A>	position where {pat} matches in {expr}
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
				<A HREF="eval.html#Number">Number</A>	highlight {pattern} with {group}
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
				<A HREF="eval.html#Number">Number</A>	highlight positions with {group}
matcharg({nr})			<A HREF="eval.html#List">List</A>	arguments of |<A HREF="pattern.html#:match">:match</A>|
matchdelete({id} [, {win}])	<A HREF="eval.html#Number">Number</A>	delete match identified by {id}
matchend({expr}, {pat} [, {start} [, {count}]])
				<A HREF="eval.html#Number">Number</A>	position where {pat} ends in {expr}
matchfuzzy({list}, {str} [, {dict}])
				<A HREF="eval.html#List">List</A>	fuzzy match {str} in {list}
matchfuzzypos({list}, {str} [, {dict}])
				<A HREF="eval.html#List">List</A>	fuzzy match {str} in {list}
matchlist({expr}, {pat} [, {start} [, {count}]])
				<A HREF="eval.html#List">List</A>	match and submatches of {pat} in {expr}
matchstr({expr}, {pat} [, {start} [, {count}]])
				<A HREF="eval.html#String">String</A>	{count}'th match of {pat} in {expr}
matchstrpos({expr}, {pat} [, {start} [, {count}]])
				<A HREF="eval.html#List">List</A>	{count}'th match of {pat} in {expr}
max({expr})			<A HREF="eval.html#Number">Number</A>	maximum value of items in {expr}
menu_info({name} [, {mode}])	<A HREF="eval.html#Dict">Dict</A>	get menu item information
min({expr})			<A HREF="eval.html#Number">Number</A>	minimum value of items in {expr}
mkdir({name} [, {path} [, {prot}]])
				<A HREF="eval.html#Number">Number</A>	create directory {name}
mode([expr])			<A HREF="eval.html#String">String</A>	current editing mode
mzeval({expr})			any	evaluate |<A HREF="if_mzsch.html#MzScheme">MzScheme</A>| <A HREF="eval.html#expression">expression</A>
nextnonblank({lnum})		<A HREF="eval.html#Number">Number</A>	line nr of non-blank line &gt;= {lnum}
nr2char({expr} [, {utf8}])	<A HREF="eval.html#String">String</A>	single char with ASCII/UTF-8 value {expr}
or({expr}, {expr})		<A HREF="eval.html#Number">Number</A>	bitwise OR
pathshorten({expr} [, {len}])	<A HREF="eval.html#String">String</A>	shorten directory names in a path
perleval({expr})		any	evaluate |<A HREF="if_perl.html#Perl">Perl</A>| <A HREF="eval.html#expression">expression</A>
popup_atcursor({what}, {options}) <A HREF="eval.html#Number">Number</A> create <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> near the cursor
popup_beval({what}, {options})	<A HREF="eval.html#Number">Number</A>	create <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> for <A HREF="options.html#'ballooneval'">'ballooneval'</A>
<A HREF="popup.html#popup_clear()">popup_clear()</A>			none	close all <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#windows">windows</A>
popup_close({id} [, {result}])	none	close <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> {id}
popup_create({what}, {options}) <A HREF="eval.html#Number">Number</A>	create a <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>
popup_dialog({what}, {options}) <A HREF="eval.html#Number">Number</A>	create a <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> used <A HREF="motion.html#as">as</A> a <A HREF="gui_w32.html#dialog">dialog</A>
popup_filter_menu({id}, {key})  <A HREF="eval.html#Number">Number</A>	<A HREF="change.html#filter">filter</A> for a menu <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>
popup_filter_yesno({id}, {key}) <A HREF="eval.html#Number">Number</A>	<A HREF="change.html#filter">filter</A> for a <A HREF="gui_w32.html#dialog">dialog</A> <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>
<A HREF="popup.html#popup_findinfo()">popup_findinfo()</A>		<A HREF="eval.html#Number">Number</A>	get <A HREF="windows.html#window">window</A> ID of info <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>
<A HREF="popup.html#popup_findpreview()">popup_findpreview()</A>		<A HREF="eval.html#Number">Number</A>	get <A HREF="windows.html#window">window</A> ID of preview <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>
popup_getoptions({id})		<A HREF="eval.html#Dict">Dict</A>	get <A HREF="options.html#options">options</A> of <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> {id}
popup_getpos({id})		<A HREF="eval.html#Dict">Dict</A>	get position of <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> {id}
popup_hide({id})		none	hide <A HREF="popup.html#popup">popup</A> menu {id}
<A HREF="popup.html#popup_list()">popup_list()</A>			<A HREF="eval.html#List">List</A>	get a <A HREF="eval.html#list">list</A> of <A HREF="windows.html#window">window</A> IDs of all popups
popup_locate({row}, {col})	<A HREF="eval.html#Number">Number</A>	get <A HREF="windows.html#window">window</A> ID of <A HREF="popup.html#popup">popup</A> at position
popup_menu({what}, {options})	<A HREF="eval.html#Number">Number</A>	create a <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> used <A HREF="motion.html#as">as</A> a menu
popup_move({id}, {options})	none	set position of <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> {id}
popup_notification({what}, {options})
				<A HREF="eval.html#Number">Number</A>	create a notification <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>
popup_setoptions({id}, {options})
				none	set <A HREF="options.html#options">options</A> for <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> {id}
popup_settext({id}, {text})	none	set the text of <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> {id}
popup_show({id})		none	unhide <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> {id}
pow({x}, {y})			<A HREF="eval.html#Float">Float</A>	{x} to the power of {y}
prevnonblank({lnum})		<A HREF="eval.html#Number">Number</A>	line nr of non-blank line &lt;= {lnum}
printf({fmt}, {expr1}...)	<A HREF="eval.html#String">String</A>	format text
prompt_getprompt({buf})		<A HREF="eval.html#String">String</A>	get prompt text
prompt_setcallback({buf}, {expr}) none	set prompt callback function
prompt_setinterrupt({buf}, {text}) none	set prompt interrupt function
prompt_setprompt({buf}, {text}) none	set prompt text
prop_add({lnum}, {col}, {props})  none	add one text property
prop_add_list({props}, [[{lnum}, {col}, {end-lnum}, {end-col}], ...])
				none	add multiple text properties
prop_clear({lnum} [, {lnum-end} [, {props}]])
				none	remove all text properties
prop_find({props} [, {direction}])
				<A HREF="eval.html#Dict">Dict</A>	search for a text property
prop_list({lnum} [, {props}])	<A HREF="eval.html#List">List</A>	text properties in {lnum}
prop_remove({props} [, {lnum} [, {lnum-end}]])
				<A HREF="eval.html#Number">Number</A>	remove a text property
prop_type_add({name}, {props})	none	define a new property type
prop_type_change({name}, {props})
				none	change an existing property type
prop_type_delete({name} [, {props}])
				none	delete a property type
prop_type_get({name} [, {props}])
				<A HREF="eval.html#Dict">Dict</A>	get property type values
prop_type_list([{props}])	<A HREF="eval.html#List">List</A>	get <A HREF="eval.html#list">list</A> of property types
<A HREF="#pum_getpos()">pum_getpos()</A>			<A HREF="eval.html#Dict">Dict</A>	position and size of pum if visible
<A HREF="#pumvisible()">pumvisible()</A>			<A HREF="eval.html#Number">Number</A>	whether <A HREF="popup.html#popup">popup</A> menu is visible
py3eval({expr})			any	evaluate |<A HREF="if_pyth.html#python3">python3</A>| <A HREF="eval.html#expression">expression</A>
pyeval({expr})			any	evaluate |<A HREF="if_pyth.html#Python">Python</A>| <A HREF="eval.html#expression">expression</A>
pyxeval({expr})			any	evaluate |<A HREF="if_pyth.html#python_x">python_x</A>| <A HREF="eval.html#expression">expression</A>
rand([{expr}])			<A HREF="eval.html#Number">Number</A>	get pseudo-random number
range({expr} [, {max} [, {stride}]])
				<A HREF="eval.html#List">List</A>	items from {expr} to {max}
readblob({fname})		Blob	read a |<A HREF="eval.html#Blob">Blob</A>| from {fname}
readdir({dir} [, {expr} [, {dict}]])
				<A HREF="eval.html#List">List</A>	file names in {dir} selected by {expr}
readdirex({dir} [, {expr} [, {dict}]])
				<A HREF="eval.html#List">List</A>	file info in {dir} selected by {expr}
readfile({fname} [, {type} [, {max}]])
				<A HREF="eval.html#List">List</A>	get <A HREF="eval.html#list">list</A> of lines from file {fname}
reduce({object}, {func} [, {initial}])
				any	reduce {object} using {func}
<A HREF="#reg_executing()">reg_executing()</A>			<A HREF="eval.html#String">String</A>	get the executing <A HREF="sponsor.html#register">register</A> name
<A HREF="#reg_recording()">reg_recording()</A>			<A HREF="eval.html#String">String</A>	get the <A HREF="repeat.html#recording">recording</A> <A HREF="sponsor.html#register">register</A> name
reltime([{start} [, {end}]])	<A HREF="eval.html#List">List</A>	get time value
reltimefloat({time})		<A HREF="eval.html#Float">Float</A>	turn the time value into a <A HREF="eval.html#Float">Float</A>
reltimestr({time})		<A HREF="eval.html#String">String</A>	turn time value into a <A HREF="eval.html#String">String</A>
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
				<A HREF="eval.html#String">String</A>	send <A HREF="eval.html#expression">expression</A>
remote_foreground({server})	<A HREF="eval.html#Number">Number</A>	bring Vim server to the foreground
remote_peek({serverid} [, {retvar}])
				<A HREF="eval.html#Number">Number</A>	check for reply <A HREF="eval.html#string">string</A>
remote_read({serverid} [, {timeout}])
				<A HREF="eval.html#String">String</A>	read reply <A HREF="eval.html#string">string</A>
remote_send({server}, {string} [, {idvar}])
				<A HREF="eval.html#String">String</A>	send key sequence
remote_startserver({name})	none	become server {name}
remove({list}, {idx} [, {end}])	any/List
					remove items {idx}-{end} from {list}
remove({blob}, {idx} [, {end}])	Number/Blob
					remove bytes {idx}-{end} from {blob}
remove({dict}, {key})		any	remove entry {key} from {dict}
rename({from}, {to})		<A HREF="eval.html#Number">Number</A>	rename (move) file from {from} to {to}
repeat({expr}, {count})		<A HREF="eval.html#String">String</A>	repeat {expr} {count} times
resolve({filename})		<A HREF="eval.html#String">String</A>	get filename a shortcut points to
reverse({list})			<A HREF="eval.html#List">List</A>	reverse {list} in-place
round({expr})			<A HREF="eval.html#Float">Float</A>	round off {expr}
rubyeval({expr})		any	evaluate |<A HREF="if_ruby.html#Ruby">Ruby</A>| <A HREF="eval.html#expression">expression</A>
screenattr({row}, {col})	<A HREF="eval.html#Number">Number</A>	attribute at screen position
screenchar({row}, {col})	<A HREF="eval.html#Number">Number</A>	character at screen position
screenchars({row}, {col})	<A HREF="eval.html#List">List</A>	<A HREF="eval.html#List">List</A> of characters at screen position
<A HREF="#screencol()">screencol()</A>			<A HREF="eval.html#Number">Number</A>	current cursor column
screenpos({winid}, {lnum}, {col}) <A HREF="eval.html#Dict">Dict</A>	screen row and col of a text character
<A HREF="#screenrow()">screenrow()</A>			<A HREF="eval.html#Number">Number</A>	current cursor row
screenstring({row}, {col})	<A HREF="eval.html#String">String</A>	characters at screen position
search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
				<A HREF="eval.html#Number">Number</A>	search for {pattern}
searchcount([{options}])	<A HREF="eval.html#Dict">Dict</A>	get or update search stats
searchdecl({name} [, {global} [, {thisblock}]])
				<A HREF="eval.html#Number">Number</A>	search for variable declaration
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				<A HREF="eval.html#Number">Number</A>	search for other end of start/end pair
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				<A HREF="eval.html#List">List</A>	search for other end of start/end pair
searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
				<A HREF="eval.html#List">List</A>	search for {pattern}
server2client({clientid}, {string})
				<A HREF="eval.html#Number">Number</A>	send reply <A HREF="eval.html#string">string</A>
<A HREF="#serverlist()">serverlist()</A>			<A HREF="eval.html#String">String</A>	get a <A HREF="eval.html#list">list</A> of available servers
setbufline({expr}, {lnum}, {text})
				<A HREF="eval.html#Number">Number</A>	set line {lnum} to {text} in buffer
					{expr}
setbufvar({buf}, {varname}, {val})
				none	set {varname} in buffer {buf} to {val}
setcellwidths({list})		none	set character cell width overrides
setcharpos({expr}, {list})	<A HREF="eval.html#Number">Number</A>	set the {expr} position to {list}
setcharsearch({dict})		<A HREF="eval.html#Dict">Dict</A>	set character search from {dict}
setcmdpos({pos})		<A HREF="eval.html#Number">Number</A>	set cursor position in command-line
setcursorcharpos({list})	<A HREF="eval.html#Number">Number</A>	move cursor to position in {list}
setenv({name}, {val})		none	set environment variable
setfperm({fname}, {mode})	<A HREF="eval.html#Number">Number</A>	set {fname} file permissions to {mode}
setline({lnum}, {line})		<A HREF="eval.html#Number">Number</A>	set line {lnum} to {line}
setloclist({nr}, {list} [, {action}])
				<A HREF="eval.html#Number">Number</A>	modify location <A HREF="eval.html#list">list</A> using {list}
setloclist({nr}, {list}, {action}, {what})
				<A HREF="eval.html#Number">Number</A>	modify specific location <A HREF="eval.html#list">list</A> props
setmatches({list} [, {win}])	<A HREF="eval.html#Number">Number</A>	restore a <A HREF="eval.html#list">list</A> of matches
setpos({expr}, {list})		<A HREF="eval.html#Number">Number</A>	set the {expr} position to {list}
setqflist({list} [, {action}])	<A HREF="eval.html#Number">Number</A>	modify <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> using {list}
setqflist({list}, {action}, {what})
				<A HREF="eval.html#Number">Number</A>	modify specific <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> props
setreg({n}, {v} [, {opt}])	<A HREF="eval.html#Number">Number</A>	set <A HREF="sponsor.html#register">register</A> to value and type
settabvar({nr}, {varname}, {val}) none	set {varname} in <A HREF="intro.html#tab">tab</A> page {nr} to {val}
settabwinvar({tabnr}, {winnr}, {varname}, {val})
				none	set {varname} in <A HREF="windows.html#window">window</A> {winnr} in <A HREF="intro.html#tab">tab</A>
					page {tabnr} to {val}
settagstack({nr}, {dict} [, {action}])
				<A HREF="eval.html#Number">Number</A>	modify <A HREF="tagsrch.html#tag">tag</A> stack using {dict}
setwinvar({nr}, {varname}, {val}) none	set {varname} in <A HREF="windows.html#window">window</A> {nr} to {val}
sha256({string})		<A HREF="eval.html#String">String</A>	SHA256 checksum of {string}
shellescape({string} [, {special}])
				<A HREF="eval.html#String">String</A>	<A HREF="intro.html#escape">escape</A> {string} for use <A HREF="motion.html#as">as</A> shell
					command argument
shiftwidth([{col}])		<A HREF="eval.html#Number">Number</A>	effective value of <A HREF="options.html#'shiftwidth'">'shiftwidth'</A>
sign_define({name} [, {dict}])	<A HREF="eval.html#Number">Number</A>	define or update a sign
sign_define({list})		<A HREF="eval.html#List">List</A>	define or update a <A HREF="eval.html#list">list</A> of <A HREF="sign.html#signs">signs</A>
sign_getdefined([{name}])	<A HREF="eval.html#List">List</A>	get a <A HREF="eval.html#list">list</A> of defined <A HREF="sign.html#signs">signs</A>
sign_getplaced([{buf} [, {dict}]])
				<A HREF="eval.html#List">List</A>	get a <A HREF="eval.html#list">list</A> of placed <A HREF="sign.html#signs">signs</A>
sign_jump({id}, {group}, {buf})
				<A HREF="eval.html#Number">Number</A>	jump to a sign
sign_place({id}, {group}, {name}, {buf} [, {dict}])
				<A HREF="eval.html#Number">Number</A>	place a sign
sign_placelist({list})		<A HREF="eval.html#List">List</A>	place a <A HREF="eval.html#list">list</A> of <A HREF="sign.html#signs">signs</A>
sign_undefine([{name}])		<A HREF="eval.html#Number">Number</A>	undefine a sign
sign_undefine({list})		<A HREF="eval.html#List">List</A>	undefine a <A HREF="eval.html#list">list</A> of <A HREF="sign.html#signs">signs</A>
sign_unplace({group} [, {dict}])
				<A HREF="eval.html#Number">Number</A>	unplace a sign
sign_unplacelist({list})	<A HREF="eval.html#List">List</A>	unplace a <A HREF="eval.html#list">list</A> of <A HREF="sign.html#signs">signs</A>
simplify({filename})		<A HREF="eval.html#String">String</A>	simplify filename <A HREF="motion.html#as">as</A> much <A HREF="motion.html#as">as</A> possible
sin({expr})			<A HREF="eval.html#Float">Float</A>	sine of {expr}
sinh({expr})			<A HREF="eval.html#Float">Float</A>	hyperbolic sine of {expr}
slice({expr}, {start} [, {end}])  <A HREF="eval.html#String">String</A>, <A HREF="eval.html#List">List</A> or <A HREF="eval.html#Blob">Blob</A>
					<A HREF="eval.html#slice">slice</A> of a <A HREF="eval.html#String">String</A>, <A HREF="eval.html#List">List</A> or <A HREF="eval.html#Blob">Blob</A>
sort({list} [, {how} [, {dict}]])
				<A HREF="eval.html#List">List</A>	sort {list}, compare with {how}
<A HREF="#sound_clear()">sound_clear()</A>			none	stop playing all sounds
sound_playevent({name} [, {callback}])
				<A HREF="eval.html#Number">Number</A>	play an event sound
sound_playfile({path} [, {callback}])
				<A HREF="eval.html#Number">Number</A>	play sound file {path}
sound_stop({id})		none	stop playing sound {id}
soundfold({word})		<A HREF="eval.html#String">String</A>	sound-fold {word}
<A HREF="#spellbadword()">spellbadword()</A>			<A HREF="eval.html#String">String</A>	badly spelled <A HREF="motion.html#word">word</A> at cursor
spellsuggest({word} [, {max} [, {capital}]])
				<A HREF="eval.html#List">List</A>	spelling suggestions
split({expr} [, {pat} [, {keepempty}]])
				List	make |<A HREF="eval.html#List">List</A>| from {pat} separated {expr}
sqrt({expr})			<A HREF="eval.html#Float">Float</A>	square root of {expr}
srand([{expr}])			<A HREF="eval.html#List">List</A>	get seed for |<A HREF="#rand()">rand()</A>|
state([{what}])			<A HREF="eval.html#String">String</A>	current state of Vim
str2float({expr} [, {quoted}])	<A HREF="eval.html#Float">Float</A>	convert <A HREF="eval.html#String">String</A> to <A HREF="eval.html#Float">Float</A>
str2list({expr} [, {utf8}])	<A HREF="eval.html#List">List</A>	convert each character of {expr} to
					ASCII/UTF-8 value
str2nr({expr} [, {base} [, {quoted}]])
				<A HREF="eval.html#Number">Number</A>	convert <A HREF="eval.html#String">String</A> to <A HREF="eval.html#Number">Number</A>
strcharlen({expr})		<A HREF="eval.html#Number">Number</A>	character length of the <A HREF="eval.html#String">String</A> {expr}
strcharpart({str}, {start} [, {len} [, {skipcc}]])
				<A HREF="eval.html#String">String</A>	{len} characters of {str} at
					character {start}
strchars({expr} [, {skipcc}])	<A HREF="eval.html#Number">Number</A>	character <A HREF="intro.html#count">count</A> of the <A HREF="eval.html#String">String</A> {expr}
strdisplaywidth({expr} [, {col}]) <A HREF="eval.html#Number">Number</A> display length of the <A HREF="eval.html#String">String</A> {expr}
strftime({format} [, {time}])	<A HREF="eval.html#String">String</A>	format time with a specified format
strgetchar({str}, {index})	<A HREF="eval.html#Number">Number</A>	get char {index} from {str}
stridx({haystack}, {needle} [, {start}])
				<A HREF="eval.html#Number">Number</A>	index of {needle} in {haystack}
string({expr})			<A HREF="eval.html#String">String</A>	<A HREF="eval.html#String">String</A> representation of {expr} value
strlen({expr})			<A HREF="eval.html#Number">Number</A>	length of the <A HREF="eval.html#String">String</A> {expr}
strpart({str}, {start} [, {len} [, {chars}]])
				<A HREF="eval.html#String">String</A>	{len} bytes/chars of {str} at
					byte {start}
strptime({format}, {timestring})
				<A HREF="eval.html#Number">Number</A>	Convert {timestring} to <A HREF="os_unix.html#unix">unix</A> <A HREF="editing.html#timestamp">timestamp</A>
strridx({haystack}, {needle} [, {start}])
				<A HREF="eval.html#Number">Number</A>	last index of {needle} in {haystack}
strtrans({expr})		<A HREF="eval.html#String">String</A>	translate <A HREF="eval.html#string">string</A> to make <A HREF="motion.html#it">it</A> printable
strwidth({expr})		<A HREF="eval.html#Number">Number</A>	display cell length of the <A HREF="eval.html#String">String</A> {expr}
submatch({nr} [, {list}])	<A HREF="eval.html#String">String</A> or <A HREF="eval.html#List">List</A>
					specific match in &quot;<A HREF="change.html#:s">:s</A>&quot; or <A HREF="#substitute()">substitute()</A>
substitute({expr}, {pat}, {sub}, {flags})
				<A HREF="eval.html#String">String</A>	all {pat} in {expr} replaced with {sub}
swapinfo({fname})		<A HREF="eval.html#Dict">Dict</A>	information about swap file {fname}
swapname({buf})			<A HREF="eval.html#String">String</A>	swap file of buffer {buf}
synID({lnum}, {col}, {trans})	<A HREF="eval.html#Number">Number</A>	<A HREF="syntax.html#syntax">syntax</A> ID at {lnum} and {col}
synIDattr({synID}, {what} [, {mode}])
				<A HREF="eval.html#String">String</A>	attribute {what} of <A HREF="syntax.html#syntax">syntax</A> ID {synID}
synIDtrans({synID})		<A HREF="eval.html#Number">Number</A>	translated <A HREF="syntax.html#syntax">syntax</A> ID of {synID}
synconcealed({lnum}, {col})	<A HREF="eval.html#List">List</A>	info about concealing
synstack({lnum}, {col})		<A HREF="eval.html#List">List</A>	stack of <A HREF="syntax.html#syntax">syntax</A> IDs at {lnum} and {col}
system({expr} [, {input}])	<A HREF="eval.html#String">String</A>	output of shell command/filter {expr}
systemlist({expr} [, {input}])	<A HREF="eval.html#List">List</A>	output of shell command/filter {expr}
tabpagebuflist([{arg}])		<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of buffer numbers in <A HREF="intro.html#tab">tab</A> page
tabpagenr([{arg}])		<A HREF="eval.html#Number">Number</A>	number of current or last <A HREF="intro.html#tab">tab</A> page
tabpagewinnr({tabarg} [, {arg}]) <A HREF="eval.html#Number">Number</A>	number of current <A HREF="windows.html#window">window</A> in <A HREF="intro.html#tab">tab</A> page
<A HREF="#tagfiles()">tagfiles()</A>			<A HREF="eval.html#List">List</A>	<A HREF="tagsrch.html#tags">tags</A> files used
taglist({expr} [, {filename}])	<A HREF="eval.html#List">List</A>	<A HREF="eval.html#list">list</A> of <A HREF="tagsrch.html#tags">tags</A> matching {expr}
tan({expr})			<A HREF="eval.html#Float">Float</A>	tangent of {expr}
tanh({expr})			<A HREF="eval.html#Float">Float</A>	hyperbolic tangent of {expr}
<A HREF="#tempname()">tempname()</A>			<A HREF="eval.html#String">String</A>	name for a temporary file
term_dumpdiff({filename}, {filename} [, {options}])
				<A HREF="eval.html#Number">Number</A>  display difference between two dumps
term_dumpload({filename} [, {options}])
				<A HREF="eval.html#Number">Number</A>	displaying a screen dump
term_dumpwrite({buf}, {filename} [, {options}])
				none	dump <A HREF="terminal.html#terminal">terminal</A> <A HREF="windows.html#window">window</A> contents
term_getaltscreen({buf})	<A HREF="eval.html#Number">Number</A>	get the alternate screen flag
term_getansicolors({buf})	<A HREF="eval.html#List">List</A>	get ANSI palette in <A HREF="gui.html#GUI">GUI</A> color mode
term_getattr({attr}, {what})	<A HREF="eval.html#Number">Number</A>	get the value of attribute {what}
term_getcursor({buf})		<A HREF="eval.html#List">List</A>	get the cursor position of a <A HREF="terminal.html#terminal">terminal</A>
term_getjob({buf})		<A HREF="eval.html#Job">Job</A>	get the <A HREF="channel.html#job">job</A> associated with a <A HREF="terminal.html#terminal">terminal</A>
term_getline({buf}, {row})	<A HREF="eval.html#String">String</A>	get a line of text from a <A HREF="terminal.html#terminal">terminal</A>
term_getscrolled({buf})		<A HREF="eval.html#Number">Number</A>	get the scroll <A HREF="intro.html#count">count</A> of a <A HREF="terminal.html#terminal">terminal</A>
term_getsize({buf})		<A HREF="eval.html#List">List</A>	get the size of a <A HREF="terminal.html#terminal">terminal</A>
term_getstatus({buf})		<A HREF="eval.html#String">String</A>	get the status of a <A HREF="terminal.html#terminal">terminal</A>
term_gettitle({buf})		<A HREF="eval.html#String">String</A>	get the title of a <A HREF="terminal.html#terminal">terminal</A>
term_gettty({buf}, [{input}])	<A HREF="eval.html#String">String</A>	get the tty name of a <A HREF="terminal.html#terminal">terminal</A>
<A HREF="terminal.html#term_list()">term_list()</A>			<A HREF="eval.html#List">List</A>	get the <A HREF="eval.html#list">list</A> of <A HREF="terminal.html#terminal">terminal</A> <A HREF="windows.html#buffers">buffers</A>
term_scrape({buf}, {row})	<A HREF="eval.html#List">List</A>	get row of a <A HREF="terminal.html#terminal">terminal</A> screen
term_sendkeys({buf}, {keys})	none	send keystrokes to a <A HREF="terminal.html#terminal">terminal</A>
term_setansicolors({buf}, {colors})
				none	set ANSI palette in <A HREF="gui.html#GUI">GUI</A> color mode
term_setapi({buf}, {expr})	none	set |<A HREF="terminal.html#terminal-api">terminal-api</A>| function name prefix
term_setkill({buf}, {how})	none	set signal to stop <A HREF="channel.html#job">job</A> in <A HREF="terminal.html#terminal">terminal</A>
term_setrestore({buf}, {command}) none	set command to restore <A HREF="terminal.html#terminal">terminal</A>
term_setsize({buf}, {rows}, {cols})
				none	set the size of a <A HREF="terminal.html#terminal">terminal</A>
term_start({cmd} [, {options}])	<A HREF="eval.html#Number">Number</A>	open a <A HREF="terminal.html#terminal">terminal</A> <A HREF="windows.html#window">window</A> and run a <A HREF="channel.html#job">job</A>
term_wait({buf} [, {time}])	<A HREF="eval.html#Number">Number</A>  wait for screen to be updated
<A HREF="#terminalprops()">terminalprops()</A>			<A HREF="eval.html#Dict">Dict</A>	properties of the <A HREF="terminal.html#terminal">terminal</A>
test_alloc_fail({id}, {countdown}, {repeat})
				none	make memory allocation fail
<A HREF="testing.html#test_autochdir()">test_autochdir()</A>		none	enable <A HREF="options.html#'autochdir'">'autochdir'</A> during <A HREF="starting.html#startup">startup</A>
test_feedinput({string})	none	add key sequence to input buffer
<A HREF="testing.html#test_garbagecollect_now()">test_garbagecollect_now()</A>	none	free memory right now for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_garbagecollect_soon()">test_garbagecollect_soon()</A>	none	free memory soon for <A HREF="testing.html#testing">testing</A>
test_getvalue({string})		any	get value of an internal variable
test_gui_event({event}, {args})	bool	generate a <A HREF="gui.html#GUI">GUI</A> event for <A HREF="testing.html#testing">testing</A>
test_ignore_error({expr})	none	ignore a specific error
<A HREF="testing.html#test_null_blob()">test_null_blob()</A>		<A HREF="eval.html#Blob">Blob</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_null_channel()">test_null_channel()</A>		<A HREF="eval.html#Channel">Channel</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_null_dict()">test_null_dict()</A>		<A HREF="eval.html#Dict">Dict</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_null_function()">test_null_function()</A>		<A HREF="eval.html#Funcref">Funcref</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_null_job()">test_null_job()</A>			<A HREF="eval.html#Job">Job</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_null_list()">test_null_list()</A>		<A HREF="eval.html#List">List</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_null_partial()">test_null_partial()</A>		<A HREF="eval.html#Funcref">Funcref</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_null_string()">test_null_string()</A>		<A HREF="eval.html#String">String</A>	<A HREF="vim9.html#null">null</A> value for <A HREF="testing.html#testing">testing</A>
test_option_not_set({name})	none	reset flag indicating option was set
test_override({expr}, {val})	none	test with Vim internal overrides
test_refcount({expr})		<A HREF="eval.html#Number">Number</A>	get the reference <A HREF="intro.html#count">count</A> of {expr}
test_setmouse({row}, {col})	none	set the mouse position for <A HREF="testing.html#testing">testing</A>
test_settime({expr})		none	set current time for <A HREF="testing.html#testing">testing</A>
test_srand_seed([seed])		none	set seed for <A HREF="testing.html#testing">testing</A> <A HREF="#srand()">srand()</A>
<A HREF="testing.html#test_unknown()">test_unknown()</A>			any	unknown value for <A HREF="testing.html#testing">testing</A>
<A HREF="testing.html#test_void()">test_void()</A>			any	void value for <A HREF="testing.html#testing">testing</A>
timer_info([{id}])		<A HREF="eval.html#List">List</A>	information about <A HREF="#timers">timers</A>
timer_pause({id}, {pause})	none	pause or unpause a <A HREF="#timer">timer</A>
timer_start({time}, {callback} [, {options}])
				<A HREF="eval.html#Number">Number</A>	create a <A HREF="#timer">timer</A>
timer_stop({timer})		none	stop a <A HREF="#timer">timer</A>
<A HREF="#timer_stopall()">timer_stopall()</A>			none	stop all <A HREF="#timers">timers</A>
tolower({expr})			<A HREF="eval.html#String">String</A>	the <A HREF="eval.html#String">String</A> {expr} switched to <A HREF="change.html#lowercase">lowercase</A>
toupper({expr})			<A HREF="eval.html#String">String</A>	the <A HREF="eval.html#String">String</A> {expr} switched to <A HREF="change.html#uppercase">uppercase</A>
tr({src}, {fromstr}, {tostr})	<A HREF="eval.html#String">String</A>	translate chars of {src} in {fromstr}
					to chars in {tostr}
trim({text} [, {mask} [, {dir}]])
				<A HREF="eval.html#String">String</A>	trim characters in {mask} from {text}
trunc({expr})			<A HREF="eval.html#Float">Float</A>	truncate <A HREF="eval.html#Float">Float</A> {expr}
type({expr})			<A HREF="eval.html#Number">Number</A>	type of value {expr}
typename({expr})		<A HREF="eval.html#String">String</A>	representation of the type of {expr}
undofile({name})		<A HREF="eval.html#String">String</A>	<A HREF="undo.html#undo">undo</A> file name for {name}
<A HREF="#undotree()">undotree()</A>			<A HREF="eval.html#List">List</A>	<A HREF="undo.html#undo">undo</A> file tree
uniq({list} [, {func} [, {dict}]])
				<A HREF="eval.html#List">List</A>	remove adjacent duplicates from a <A HREF="eval.html#list">list</A>
values({dict})			<A HREF="eval.html#List">List</A>	values in {dict}
virtcol({expr} [, {list}])	<A HREF="eval.html#Number">Number</A> or <A HREF="eval.html#List">List</A>
					screen column of cursor or <A HREF="motion.html#mark">mark</A>
virtcol2col({winid}, {lnum}, {col})
				<A HREF="eval.html#Number">Number</A>  byte index of a character on screen
visualmode([expr])		<A HREF="eval.html#String">String</A>	last visual mode used
<A HREF="#wildmenumode()">wildmenumode()</A>			<A HREF="eval.html#Number">Number</A>	whether <A HREF="options.html#'wildmenu'">'wildmenu'</A> mode is active
win_execute({id}, {command} [, {silent}])
				<A HREF="eval.html#String">String</A>	execute {command} in <A HREF="windows.html#window">window</A> {id}
win_findbuf({bufnr})		<A HREF="eval.html#List">List</A>	find <A HREF="windows.html#windows">windows</A> containing {bufnr}
win_getid([{win} [, {tab}]])	<A HREF="eval.html#Number">Number</A>	get <A HREF="windows.html#window">window</A> ID for {win} in {tab}
win_gettype([{nr}])		<A HREF="eval.html#String">String</A>	type of <A HREF="windows.html#window">window</A> {nr}
win_gotoid({expr})		<A HREF="eval.html#Number">Number</A>	go to <A HREF="windows.html#window">window</A> with ID {expr}
win_id2tabwin({expr})		<A HREF="eval.html#List">List</A>	get <A HREF="intro.html#tab">tab</A> and <A HREF="windows.html#window">window</A> nr from <A HREF="windows.html#window">window</A> ID
win_id2win({expr})		<A HREF="eval.html#Number">Number</A>	get <A HREF="windows.html#window">window</A> nr from <A HREF="windows.html#window">window</A> ID
win_move_separator({nr})	<A HREF="eval.html#Number">Number</A>	move <A HREF="windows.html#window">window</A> vertical separator
win_move_statusline({nr})	<A HREF="eval.html#Number">Number</A>	move <A HREF="windows.html#window">window</A> status line
win_screenpos({nr})		<A HREF="eval.html#List">List</A>	get screen position of <A HREF="windows.html#window">window</A> {nr}
win_splitmove({nr}, {target} [, {options}])
				<A HREF="eval.html#Number">Number</A>	move <A HREF="windows.html#window">window</A> {nr} to split of {target}
winbufnr({nr})			<A HREF="eval.html#Number">Number</A>	buffer number of <A HREF="windows.html#window">window</A> {nr}
<A HREF="#wincol()">wincol()</A>			<A HREF="eval.html#Number">Number</A>	<A HREF="windows.html#window">window</A> column of the cursor
<A HREF="#windowsversion()">windowsversion()</A>		<A HREF="eval.html#String">String</A>	<A HREF="os_win32.html#MS-Windows">MS-Windows</A> OS version
winheight({nr})			<A HREF="eval.html#Number">Number</A>	height of <A HREF="windows.html#window">window</A> {nr}
winlayout([{tabnr}])		<A HREF="eval.html#List">List</A>	layout of <A HREF="windows.html#windows">windows</A> in <A HREF="intro.html#tab">tab</A> {tabnr}
<A HREF="#winline()">winline()</A>			<A HREF="eval.html#Number">Number</A>	<A HREF="windows.html#window">window</A> line of the cursor
winnr([{expr}])			<A HREF="eval.html#Number">Number</A>	number of current <A HREF="windows.html#window">window</A>
<A HREF="#winrestcmd()">winrestcmd()</A>			<A HREF="eval.html#String">String</A>	returns command to restore <A HREF="windows.html#window">window</A> sizes
winrestview({dict})		none	restore <A HREF="starting.html#view">view</A> of current <A HREF="windows.html#window">window</A>
<A HREF="#winsaveview()">winsaveview()</A>			<A HREF="eval.html#Dict">Dict</A>	save <A HREF="starting.html#view">view</A> of current <A HREF="windows.html#window">window</A>
winwidth({nr})			<A HREF="eval.html#Number">Number</A>	width of <A HREF="windows.html#window">window</A> {nr}
<A HREF="#wordcount()">wordcount()</A>			<A HREF="eval.html#Dict">Dict</A>	get byte/char/word statistics
writefile({object}, {fname} [, {flags}])
				<A HREF="eval.html#Number">Number</A>	write |<A HREF="eval.html#Blob">Blob</A>| or |<A HREF="eval.html#List">List</A>| of lines to file
xor({expr}, {expr})		<A HREF="eval.html#Number">Number</A>	bitwise XOR

==============================================================================

2. Details					*<A NAME="builtin-function-details"></A><B>builtin-function-details</B>*

Not all <A HREF="eval.html#functions">functions</A> are here, some have been moved to a help file covering the
specific functionality.


abs({expr})							*<A NAME="abs()"></A><B>abs()</B>*
		Return the absolute value of {expr}.  When {expr} evaluates to
		a |<A HREF="eval.html#Float">Float</A>| <A HREF="#abs()">abs()</A> returns a |<A HREF="eval.html#Float">Float</A>|.  When {expr} can be
		converted to a |<A HREF="eval.html#Number">Number</A>| <A HREF="#abs()">abs()</A> returns a |<A HREF="eval.html#Number">Number</A>|.  Otherwise
		<A HREF="#abs()">abs()</A> gives an error message and returns -1.
		Examples:
<B>			echo abs(1.456)</B>
 			1.456 
<B>			echo abs(-5.456)</B>
 			5.456 
<B>			echo abs(-4)</B>
 			4

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;abs()</B>

 		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



acos({expr})							*<A NAME="acos()"></A><B>acos()</B>*
		Return the arc cosine of {expr} measured in radians, <A HREF="motion.html#as">as</A> a
		|<A HREF="eval.html#Float">Float</A>| in the range of [0, pi].
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>| in the range
		[-1, 1].  Otherwise <A HREF="#acos()">acos()</A> returns &quot;nan&quot;.
		Examples:
<B>			:echo acos(0)</B>
 			1.570796
<B>			:echo acos(-0.5)</B>
 			2.094395

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;acos()</B>

 		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



add({object}, {expr})					*<A NAME="add()"></A><B>add()</B>*
		Append the item {expr} to |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Blob">Blob</A>| {object}.  Returns
		the resulting |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Blob">Blob</A>|.  Examples:
<B>			:let alist = add([1, 2, 3], item)</B>
<B>			:call add(mylist, "woodstock")</B>
 		Note that when {expr} is a |<A HREF="eval.html#List">List</A>| <A HREF="motion.html#it">it</A> is appended <A HREF="motion.html#as">as</A> a single
		item.  Use |<A HREF="#extend()">extend()</A>| to concatenate |<A HREF="eval.html#Lists">Lists</A>|.
		When {object} is a |<A HREF="eval.html#Blob">Blob</A>| then  {expr} must be a number.
		Use |<A HREF="#insert()">insert()</A>| to add an item at another position.
		Returns 1 if {object} is not a |<A HREF="eval.html#List">List</A>| or a |<A HREF="eval.html#Blob">Blob</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;add(val1)-&gt;add(val2)</B>



and({expr}, {expr})					*<A NAME="and()"></A><B>and()</B>*
		Bitwise AND on the two arguments.  The arguments are converted
		to a number.  A <A HREF="eval.html#List">List</A>, <A HREF="eval.html#Dict">Dict</A> or <A HREF="eval.html#Float">Float</A> argument causes an error.
		Also see `or()` and `xor()`.
		Example:
<B>			:let flag = and(bits, 0x80)</B>
 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			:let flag = bits-&gt;and(0x80)</B>



append({lnum}, {text})					*<A NAME="append()"></A><B>append()</B>*
		When {text} is a |<A HREF="eval.html#List">List</A>|: Append each item of the |<A HREF="eval.html#List">List</A>| <A HREF="motion.html#as">as</A> a
		text line below line {lnum} in the current buffer.
		Otherwise append {text} <A HREF="motion.html#as">as</A> one text line below line {lnum} in
		the current buffer.
		Any type of item is accepted and converted to a <A HREF="eval.html#String">String</A>.
		{lnum} can be zero to insert a line before the first one.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.
		Returns 1 for failure ({lnum} out of range or out of memory),
		0 for success.  In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an invalid argument or
		negative number results in an error.  Example:
<B>			:let failed = append(line('$'), "# THE END")</B>
<B>			:let failed = append(0, ["Chapter 1", "the beginning"])</B>

 		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>| after a <A HREF="eval.html#List">List</A>, the base is
		passed <A HREF="motion.html#as">as</A> the second argument:
<B>			mylist-&gt;append(lnum)</B>



appendbufline({buf}, {lnum}, {text})			*<A NAME="appendbufline()"></A><B>appendbufline()</B>*
		Like |<A HREF="#append()">append()</A>| but append the text in buffer {buf}.

		This function works only for loaded <A HREF="windows.html#buffers">buffers</A>. First call
		|<A HREF="#bufload()">bufload()</A>| if needed.

		For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>|.

		{lnum} is the line number to append below.  Note that using
		|<A HREF="#line()">line()</A>| would use the current buffer, not the one appending
		to.  Use &quot;<A HREF="motion.html#$">$</A>&quot; to append at the end of the buffer.  Other <A HREF="eval.html#string">string</A>
		values are not supported.

		On success 0 is returned, on failure 1 is returned.
		In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an error is given for an invalid {lnum}.

		If {buf} is not a valid buffer or {lnum} is not valid, an
		error message is given. Example:
<B>			:let failed = appendbufline(13, 0, "# THE START")</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>| after a <A HREF="eval.html#List">List</A>, the base is
		passed <A HREF="motion.html#as">as</A> the second argument:
<B>			mylist-&gt;appendbufline(buf, lnum)</B>



argc([{winid}])					*<A NAME="argc()"></A><B>argc()</B>*
		The result is the number of files in the argument <A HREF="eval.html#list">list</A>.  See
		|<A HREF="editing.html#arglist">arglist</A>|.
		If {winid} is not supplied, the argument <A HREF="eval.html#list">list</A> of the current
		<A HREF="windows.html#window">window</A> is used.
		If {winid} is -1, the global argument <A HREF="eval.html#list">list</A> is used.
		Otherwise {winid} specifies the <A HREF="windows.html#window">window</A> of which the argument
		<A HREF="eval.html#list">list</A> is used: either the <A HREF="windows.html#window">window</A> number or the <A HREF="windows.html#window">window</A> ID.
		Returns -1 if the {winid} argument is invalid.


							*<A NAME="argidx()"></A><B>argidx()</B>*
<A HREF="#argidx()">argidx()</A>	The result is the current index in the argument <A HREF="eval.html#list">list</A>.  0 is
		the first file.  <A HREF="#argc()">argc()</A> - 1 is the last one.  See |<A HREF="editing.html#arglist">arglist</A>|.


							*<A NAME="arglistid()"></A><B>arglistid()</B>*
arglistid([{winnr} [, {tabnr}]])
		Return the argument <A HREF="eval.html#list">list</A> ID.  This is a number which
		identifies the argument <A HREF="eval.html#list">list</A> being used.  Zero is used for the
		global argument list.  See |<A HREF="editing.html#arglist">arglist</A>|.
		Returns -1 if the arguments are invalid.

		Without arguments use the current <A HREF="windows.html#window">window</A>.
		With {winnr} only use this <A HREF="windows.html#window">window</A> in the current <A HREF="intro.html#tab">tab</A> page.
		With {winnr} and {tabnr} use the <A HREF="windows.html#window">window</A> in the specified <A HREF="intro.html#tab">tab</A>
		page.
		{winnr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.


							*<A NAME="argv()"></A><B>argv()</B>*
argv([{nr} [, {winid}]])
		The result is the {nr}th file in the argument <A HREF="eval.html#list">list</A>.  See
		|<A HREF="editing.html#arglist">arglist</A>|.  &quot;argv(0)&quot; is the first one.  Example:
<B>	:let i = 0</B>
<B>	:while i &lt; argc()</B>
<B>	:  let f = escape(fnameescape(argv(i)), '.')</B>
<B>	:  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '&lt;CR&gt;'</B>
<B>	:  let i = i + 1</B>
<B>	:endwhile</B>
 		Without the {nr} argument, or when {nr} is -1, a |<A HREF="eval.html#List">List</A>| with
		the whole |<A HREF="editing.html#arglist">arglist</A>| is returned.

		The {winid} argument specifies the <A HREF="windows.html#window">window</A> ID, see |<A HREF="#argc()">argc()</A>|.
		For the Vim command line arguments see |<A HREF="eval.html#v:argv">v:argv</A>|.

		Returns an empty <A HREF="eval.html#string">string</A> if {nr}th argument is not present in
		the argument <A HREF="eval.html#list">list</A>.  Returns an empty <A HREF="eval.html#List">List</A> if the {winid}
		argument is invalid.


asin({expr})						*<A NAME="asin()"></A><B>asin()</B>*
		Return the arc sine of {expr} measured in radians, <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|
		in the range of [-pi/2, pi/2].
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>| in the range
		[-1, 1].
		Returns &quot;nan&quot; if {expr} is outside the range [-1, 1].  Returns
		0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo asin(0.8)</B>
 			0.927295
<B>			:echo asin(-0.5)</B>
 			-0.523599

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;asin()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


assert_ functions are documented here: |<A HREF="testing.html#assert-functions-details">assert-functions-details</A>|




atan({expr})						*<A NAME="atan()"></A><B>atan()</B>*
		Return the principal value of the arc tangent of {expr}, in
		the range [-pi/2, +pi/2] radians, <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|.
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo atan(100)</B>
 			1.560797
<B>			:echo atan(-4.01)</B>
 			-1.326405

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;atan()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



atan2({expr1}, {expr2})					*<A NAME="atan2()"></A><B>atan2()</B>*
		Return the arc tangent of {expr1} / {expr2}, measured in
		radians, <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| in the range [-pi, pi].
		{expr1} and {expr2} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr1} or {expr2} is not a |<A HREF="eval.html#Float">Float</A>| or a
		|<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo atan2(-1, 1)</B>
 			-0.785398
<B>			:echo atan2(1, -1)</B>
 			2.356194

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;atan2(1)</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



autocmd_add({acmds})					*<A NAME="autocmd_add()"></A><B>autocmd_add()</B>*
		Adds a <A HREF="eval.html#List">List</A> of autocmds and autocmd groups.

		The {acmds} argument is a <A HREF="eval.html#List">List</A> where each item is a <A HREF="eval.html#Dict">Dict</A> with
		the following optional items:
		    bufnr	buffer number to add a buffer-local autocmd.
				If this item is specified, then the &quot;<A HREF="pattern.html#pattern">pattern</A>&quot;
				item is ignored.
		    cmd		<A HREF="intro.html#Ex">Ex</A> command to execute for this autocmd event
		    event	autocmd event name. Refer to |<A HREF="autocmd.html#autocmd-events">autocmd-events</A>|.
				This can be either a <A HREF="eval.html#String">String</A> with a single
				event name or a <A HREF="eval.html#List">List</A> of event names.
		    group	autocmd group name. Refer to |<A HREF="autocmd.html#autocmd-groups">autocmd-groups</A>|.
				If this group doesn't exist then <A HREF="motion.html#it">it</A> is
				created.  If not specified or empty, then the
				default group is used.
		    nested	<A HREF="options.html#boolean">boolean</A> flag, set to <A HREF="eval.html#v:true">v:true</A> to add a nested
				autocmd.  Refer to |<A HREF="autocmd.html#autocmd-nested">autocmd-nested</A>|.
		    once	<A HREF="options.html#boolean">boolean</A> flag, set to <A HREF="eval.html#v:true">v:true</A> to add an autocmd
				which executes only once. Refer to
				|<A HREF="autocmd.html#autocmd-once">autocmd-once</A>|.
		    <A HREF="pattern.html#pattern">pattern</A>	autocmd <A HREF="pattern.html#pattern">pattern</A> <A HREF="eval.html#string">string</A>. Refer to
				|<A HREF="autocmd.html#autocmd-patterns">autocmd-patterns</A>|.  If &quot;bufnr&quot; item is
				present, then this item is ignored.  This can
				be a <A HREF="eval.html#String">String</A> with a single <A HREF="pattern.html#pattern">pattern</A> or a <A HREF="eval.html#List">List</A> of
				patterns.
		    replace	<A HREF="options.html#boolean">boolean</A> flag, set to <A HREF="eval.html#v:true">v:true</A> to remove all the
				commands associated with the specified autocmd
				event and group and add the {cmd}.  This is
				useful to avoid adding the same command
				multiple times for an autocmd event in a group.

		Returns <A HREF="eval.html#v:true">v:true</A> on success and <A HREF="eval.html#v:false">v:false</A> on failure.
		Examples:
<B>			" Create a buffer-local autocmd for buffer 5</B>
<B>			let acmd = {}</B>
<B>			let acmd.group = 'MyGroup'</B>
<B>			let acmd.event = 'BufEnter'</B>
<B>			let acmd.bufnr = 5</B>
<B>			let acmd.cmd = 'call BufEnterFunc()'</B>
<B>			call autocmd_add([acmd])</B>

<B>		Can also be used as a |method|: &gt;</B>
<B>			GetAutocmdList()-&gt;autocmd_add()</B>
 

autocmd_delete({acmds})					*<A NAME="autocmd_delete()"></A><B>autocmd_delete()</B>*
		Deletes a <A HREF="eval.html#List">List</A> of autocmds and autocmd groups.

		The {acmds} argument is a <A HREF="eval.html#List">List</A> where each item is a <A HREF="eval.html#Dict">Dict</A> with
		the following optional items:
		    bufnr	buffer number to delete a buffer-local autocmd.
				If this item is specified, then the &quot;<A HREF="pattern.html#pattern">pattern</A>&quot;
				item is ignored.
		    cmd		<A HREF="intro.html#Ex">Ex</A> command for this autocmd event
		    event	autocmd event name. Refer to |<A HREF="autocmd.html#autocmd-events">autocmd-events</A>|.
				If '*' then all the autocmd events in this
				group are deleted.
		    group	autocmd group name. Refer to |<A HREF="autocmd.html#autocmd-groups">autocmd-groups</A>|.
				If not specified or empty, then the default
				group is used.
		    nested	set to <A HREF="eval.html#v:true">v:true</A> for a nested autocmd.
				Refer to |<A HREF="autocmd.html#autocmd-nested">autocmd-nested</A>|.
		    once	set to <A HREF="eval.html#v:true">v:true</A> for an autocmd which executes
				only once. Refer to |<A HREF="autocmd.html#autocmd-once">autocmd-once</A>|.
		    <A HREF="pattern.html#pattern">pattern</A>	autocmd <A HREF="pattern.html#pattern">pattern</A> <A HREF="eval.html#string">string</A>. Refer to
				|<A HREF="autocmd.html#autocmd-patterns">autocmd-patterns</A>|.  If &quot;bufnr&quot; item is
				present, then this item is ignored.

		If only {group} is specified in a {acmds} entry and <A HREF="autocmd.html#{event}">{event}</A>,
		{pattern} and {cmd} are not specified, then that autocmd group
		is deleted.

		Returns |<A HREF="eval.html#v:true">v:true</A>| on success and |<A HREF="eval.html#v:false">v:false</A>| on failure.
		Examples:
<B>			" :autocmd! BufLeave *.vim</B>
<B>			let acmd = #{event: 'BufLeave', pattern: '*.vim'}</B>
<B>			call autocmd_delete([acmd]})</B>
<B>			" :autocmd! MyGroup1 BufLeave</B>
<B>			let acmd = #{group: 'MyGroup1', event: 'BufLeave'}</B>
<B>			call autocmd_delete([acmd])</B>
<B>			" :autocmd! MyGroup2 BufEnter *.c</B>
<B>			let acmd = #{group: 'MyGroup2', event: 'BufEnter',</B>
<B>							\ pattern: '*.c'}</B>
<B>			" :autocmd! MyGroup2 * *.c</B>
<B>			let acmd = #{group: 'MyGroup2', event: '*',</B>
<B>							\ pattern: '*.c'}</B>
<B>			call autocmd_delete([acmd])</B>
<B>			" :autocmd! MyGroup3</B>
<B>			let acmd = #{group: 'MyGroup3'}</B>
<B>			call autocmd_delete([acmd])</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetAutocmdList()-&gt;autocmd_delete()</B>


autocmd_get([{opts}])					*<A NAME="autocmd_get()"></A><B>autocmd_get()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| of autocmds. If {opts} is not supplied, then
		returns the autocmds for all the events in all the groups.

		The optional {opts} <A HREF="eval.html#Dict">Dict</A> argument supports the following
		items:
		    group	Autocmd group name. If specified, returns only
				the autocmds defined in this group. If the
				specified group doesn't exist, results in an
				error message.  If set to an empty <A HREF="eval.html#string">string</A>,
				then the default autocmd group is used.
		    event	Autocmd event name. If specified, returns only
				the autocmds defined for this event.  If set
				to &quot;*&quot;, then returns autocmds for all the
				events.  If the specified event doesn't exist,
				results in an error message.
		    <A HREF="pattern.html#pattern">pattern</A>	Autocmd <A HREF="pattern.html#pattern">pattern</A>. If specified, returns only
				the autocmds defined for this <A HREF="pattern.html#pattern">pattern</A>.
		A combination of the above three times can be supplied in
		{opts}.

		Each <A HREF="eval.html#Dict">Dict</A> in the returned <A HREF="eval.html#List">List</A> contains the following items:
		    bufnr	For buffer-local autocmds, buffer number where
				the autocmd is defined.
		    cmd		Command executed for this autocmd.
		    event	Autocmd event name.
		    group	Autocmd group name.
		    nested	<A HREF="eval.html#Boolean">Boolean</A> flag, set to <A HREF="eval.html#v:true">v:true</A> for a nested
				autocmd. See |<A HREF="autocmd.html#autocmd-nested">autocmd-nested</A>|.
		    once	<A HREF="eval.html#Boolean">Boolean</A> flag, set to <A HREF="eval.html#v:true">v:true</A>, if the autocmd
				will be executed only once. See |<A HREF="autocmd.html#autocmd-once">autocmd-once</A>|.
		    <A HREF="pattern.html#pattern">pattern</A>	Autocmd <A HREF="pattern.html#pattern">pattern</A>.  For a buffer-local
				autocmd, this will be of the form &quot;&lt;buffer=n&gt;&quot;.
		If there are multiple commands for an autocmd event in a
		group, then separate items are returned for each command.

		Returns an empty <A HREF="eval.html#List">List</A> if an autocmd with the specified group
		or event or <A HREF="pattern.html#pattern">pattern</A> is not found.

		Examples:
<B>			" :autocmd MyGroup</B>
<B>			echo autocmd_get(#{group: 'Mygroup'})</B>
<B>			" :autocmd G BufUnload</B>
<B>			echo autocmd_get(#{group: 'G', event: 'BufUnload'})</B>
<B>			" :autocmd G * *.ts</B>
<B>			let acmd = #{group: 'G', event: '*', pattern: '*.ts'}</B>
<B>			echo autocmd_get(acmd)</B>
<B>			" :autocmd Syntax</B>
<B>			echo autocmd_get(#{event: 'Syntax'})</B>
<B>			" :autocmd G BufEnter *.ts</B>
<B>			let acmd = #{group: 'G', event: 'BufEnter',</B>
<B>							\ pattern: '*.ts'}</B>
<B>			echo autocmd_get(acmd)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Getopts()-&gt;autocmd_get()</B>
 

<A HREF="#balloon_gettext()">balloon_gettext()</A>					*<A NAME="balloon_gettext()"></A><B>balloon_gettext()</B>*
		Return the current text in the balloon.  Only for the <A HREF="eval.html#string">string</A>,
		not used for the <A HREF="eval.html#List">List</A>.  Returns an empty <A HREF="eval.html#string">string</A> if balloon
		is not present.


balloon_show({expr})					*<A NAME="balloon_show()"></A><B>balloon_show()</B>*
		Show {expr} inside the balloon.  For the <A HREF="gui.html#GUI">GUI</A> {expr} is used <A HREF="motion.html#as">as</A>
		a <A HREF="eval.html#string">string</A>.  For a <A HREF="terminal.html#terminal">terminal</A> {expr} can be a <A HREF="eval.html#list">list</A>, which contains
		the lines of the balloon.  If {expr} is not a <A HREF="eval.html#list">list</A> <A HREF="motion.html#it">it</A> will be
		split with |<A HREF="#balloon_split()">balloon_split()</A>|.
		If {expr} is an empty <A HREF="eval.html#string">string</A> any existing balloon is removed.

		Example:
<B>			func GetBalloonContent()</B>
<B>			   " ... initiate getting the content</B>
<B>			   return ''</B>
<B>			endfunc</B>
<B>			set balloonexpr=GetBalloonContent()</B>

<B>			func BalloonCallback(result)</B>
<B>			  call balloon_show(a:result)</B>
<B>			endfunc</B>
 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;balloon_show()</B>
 
		The intended use is that fetching the content of the balloon
		is initiated from <A HREF="options.html#'balloonexpr'">'balloonexpr'</A>.  It will invoke an
		asynchronous <A HREF="eval.html#method">method</A>, in which a callback invokes
		<A HREF="#balloon_show()">balloon_show()</A>.  The <A HREF="options.html#'balloonexpr'">'balloonexpr'</A> itself can return an
		empty <A HREF="eval.html#string">string</A> or a placeholder, e.g. &quot;loading...&quot;.

		When showing a balloon is not possible then nothing happens,
		no error message is given.
		{only available when compiled with the |<A HREF="various.html#+balloon_eval">+balloon_eval</A>| or
		|<A HREF="various.html#+balloon_eval_term">+balloon_eval_term</A>| feature}


balloon_split({msg})					*<A NAME="balloon_split()"></A><B>balloon_split()</B>*
		Split <A HREF="eval.html#String">String</A> {msg} into lines to be displayed in a balloon.
		The splits are made for the current <A HREF="windows.html#window">window</A> size and optimize
		to show debugger output.
		Returns a |<A HREF="eval.html#List">List</A>| with the split lines.  Returns an empty List
		on error.
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;balloon_split()-&gt;balloon_show()</B>

 		{only available when compiled with the |<A HREF="various.html#+balloon_eval_term">+balloon_eval_term</A>|
		feature}


blob2list({blob})					*<A NAME="blob2list()"></A><B>blob2list()</B>*
		Return a <A HREF="eval.html#List">List</A> containing the number value of each byte in <A HREF="eval.html#Blob">Blob</A>
		{blob}.  Examples:
<B>			blob2list(0z0102.0304)	returns [1, 2, 3, 4]</B>
<B>			blob2list(0z)		returns []</B>
 		Returns an empty <A HREF="eval.html#List">List</A> on error.  |<A HREF="#list2blob()">list2blob()</A>| does the
		opposite.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBlob()-&gt;blob2list()</B>

<B>							*browse()*</B>
browse({save}, {title}, {initdir}, {default})
		Put up a file requester.  This only works when &quot;has(&quot;browse&quot;)&quot;
		returns |<A HREF="eval.html#TRUE">TRUE</A>| (only in some <A HREF="gui.html#GUI">GUI</A> versions).
		The input fields are:
		    {save}	when |<A HREF="eval.html#TRUE">TRUE</A>|, select file to write
		    {title}	title for the requester
		    {initdir}	directory to start browsing in
		    {default}	default file name
		An empty <A HREF="eval.html#string">string</A> is returned when the &quot;Cancel&quot; button is hit,
		something went wrong, or browsing is not possible.


							*<A NAME="browsedir()"></A><B>browsedir()</B>*
browsedir({title}, {initdir})
		Put up a directory requester.  This only works when
		&quot;has(&quot;browse&quot;)&quot; returns |<A HREF="eval.html#TRUE">TRUE</A>| (only in some <A HREF="gui.html#GUI">GUI</A> versions).
		On systems where a directory browser is not supported a file
		browser is used.  In that <A HREF="change.html#case">case</A>: select a file in the directory
		to be used.
		The input fields are:
		    {title}	title for the requester
		    {initdir}	directory to start browsing in
		When the &quot;Cancel&quot; button is hit, something went wrong, or
		browsing is not possible, an empty <A HREF="eval.html#string">string</A> is returned.


bufadd({name})						*<A NAME="bufadd()"></A><B>bufadd()</B>*
		Add a buffer to the buffer <A HREF="eval.html#list">list</A> with <A HREF="eval.html#String">String</A> {name}.
		If a buffer for file {name} already exists, return that buffer
		number.  Otherwise return the buffer number of the newly
		created buffer.  When {name} is an empty <A HREF="eval.html#string">string</A> then a new
		buffer is always created.
		The buffer will not have <A HREF="options.html#'buflisted'">'buflisted'</A> set and not be loaded
		yet.  To add some text to the buffer use this:
<B>			let bufnr = bufadd('someName')</B>
<B>			call bufload(bufnr)</B>
<B>			call setbufline(bufnr, 1, ['some', 'text'])</B>
 		Returns 0 on error.
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			let bufnr = 'somename'-&gt;bufadd()</B>


bufexists({buf})					*<A NAME="bufexists()"></A><B>bufexists()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| if a buffer called
		{buf} exists.
		If the {buf} argument is a number, buffer numbers are used.
		<A HREF="eval.html#Number">Number</A> zero is the alternate buffer for the current <A HREF="windows.html#window">window</A>.

		If the {buf} argument is a <A HREF="eval.html#string">string</A> <A HREF="motion.html#it">it</A> must match a buffer name
		exactly.  The name can be:
		- Relative to the current directory.
		- A full path.
		- The name of a buffer with <A HREF="options.html#'buftype'">'buftype'</A> set to &quot;nofile&quot;.
		- A URL name.
		Unlisted <A HREF="windows.html#buffers">buffers</A> will be found.
		Note that help files are listed by their short name in the
		output of |<A HREF="windows.html#:buffers">:buffers</A>|, but <A HREF="#bufexists()">bufexists()</A> requires using their
		long name to be able to find them.
		<A HREF="#bufexists()">bufexists()</A> may report a buffer exists, but to use the name
		with a |<A HREF="windows.html#:buffer">:buffer</A>| command you may need to use |<A HREF="#expand()">expand()</A>|.  Esp
		for <A HREF="os_win32.html#MS-Windows">MS-Windows</A> 8.3 names in the form &quot;c:\DOCUME~1&quot;
		Use &quot;bufexists(0)&quot; to test for the existence of an alternate
		file name.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			let exists = 'somename'-&gt;bufexists()</B>
 

		Obsolete name: <A HREF="#buffer_exists()">buffer_exists()</A>.		*<A NAME="buffer_exists()"></A><B>buffer_exists()</B>*


buflisted({buf})					*<A NAME="buflisted()"></A><B>buflisted()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| if a buffer called
		{buf} exists and is listed (has the <A HREF="options.html#'buflisted'">'buflisted'</A> option set).
		The {buf} argument is used like with |<A HREF="#bufexists()">bufexists()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			let listed = 'somename'-&gt;buflisted()</B>


bufload({buf})						*<A NAME="bufload()"></A><B>bufload()</B>*
		Ensure the buffer {buf} is loaded.  When the buffer name
		refers to an existing file then the file is read.  Otherwise
		the buffer will be empty.  If the buffer was already loaded
		then there is no change.
		If there is an existing swap file for the file of the buffer,
		there will be no <A HREF="gui_w32.html#dialog">dialog</A>, the buffer will be loaded anyway.
		The {buf} argument is used like with |<A HREF="#bufexists()">bufexists()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			eval 'somename'-&gt;bufload()</B>


bufloaded({buf})					*<A NAME="bufloaded()"></A><B>bufloaded()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| if a buffer called
		{buf} exists and is loaded (shown in a <A HREF="windows.html#window">window</A> or hidden).
		The {buf} argument is used like with |<A HREF="#bufexists()">bufexists()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			let loaded = 'somename'-&gt;bufloaded()</B>


bufname([{buf}])					*<A NAME="bufname()"></A><B>bufname()</B>*
		The result is the name of a buffer.  Mostly <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> is displayed
		by the `:ls` command, but not using special names such <A HREF="motion.html#as">as</A>
		&quot;[No Name]&quot;.
		If {buf} is omitted the current buffer is used.
		If {buf} is a <A HREF="eval.html#Number">Number</A>, that buffer number's name is given.
		<A HREF="eval.html#Number">Number</A> zero is the alternate buffer for the current <A HREF="windows.html#window">window</A>.
		If {buf} is a <A HREF="eval.html#String">String</A>, <A HREF="motion.html#it">it</A> is used <A HREF="motion.html#as">as</A> a |<A HREF="autocmd.html#file-pattern">file-pattern</A>| to match
		with the buffer names.  This is always done like <A HREF="options.html#'magic'">'magic'</A> is
		set and <A HREF="options.html#'cpoptions'">'cpoptions'</A> is empty.  When there is more than one
		match an empty <A HREF="eval.html#string">string</A> is returned.
		&quot;&quot; or &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; can be used for the current buffer, &quot;<A HREF="pattern.html##">#</A>&quot; for the
		alternate buffer.
		A full match is preferred, otherwise a match at the start, end
		or middle of the buffer name is accepted.  If you only want a
		full match then put &quot;<A HREF="motion.html#^">^</A>&quot; at the start and &quot;<A HREF="motion.html#$">$</A>&quot; at the end of the
		<A HREF="pattern.html#pattern">pattern</A>.
		Listed <A HREF="windows.html#buffers">buffers</A> are found first.  If there is a single match
		with a listed buffer, that one is returned.  Next unlisted
		<A HREF="windows.html#buffers">buffers</A> are searched for.
		If the {buf} is a <A HREF="eval.html#String">String</A>, but you want to use <A HREF="motion.html#it">it</A> <A HREF="motion.html#as">as</A> a buffer
		number, force <A HREF="motion.html#it">it</A> to be a <A HREF="eval.html#Number">Number</A> by adding zero to <A HREF="motion.html#it">it</A>:
<B>			:echo bufname("3" + 0)</B>
 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			echo bufnr-&gt;bufname()</B>

 		If the buffer doesn't exist, or doesn't have a name, an empty
		<A HREF="eval.html#string">string</A> is returned.
<B>	bufname("#")		alternate buffer name</B>
<B>	bufname(3)		name of buffer 3</B>
<B>	bufname("%")		name of current buffer</B>
<B>	bufname("file2")	name of buffer where "file2" matches.</B>

 							*<A NAME="buffer_name()"></A><B>buffer_name()</B>*
		Obsolete name: <A HREF="#buffer_name()">buffer_name()</A>.


							*<A NAME="bufnr()"></A><B>bufnr()</B>*
bufnr([{buf} [, {create}]])
		The result is the number of a buffer, <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> is displayed by
		the `:ls` command.  For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>|
		above.

		If the buffer doesn't exist, -1 is returned.  Or, if the
		{create} argument is present and <A HREF="eval.html#TRUE">TRUE</A>, a new, unlisted,
		buffer is created and its number is returned.  Example:
<B>			let newbuf = bufnr('Scratch001', 1)</B>
 		Using an empty name uses the current buffer. To create a new
		buffer with an empty name use |<A HREF="#bufadd()">bufadd()</A>|.

		bufnr(&quot;$&quot;) is the last buffer:
<B>			:let last_buffer = bufnr("$")</B>
 		The result is a <A HREF="eval.html#Number">Number</A>, which is the highest buffer number
		of existing <A HREF="windows.html#buffers">buffers</A>.  Note that not all <A HREF="windows.html#buffers">buffers</A> with a smaller
		number necessarily exist, because &quot;<A HREF="windows.html#:bwipeout">:bwipeout</A>&quot; may have removed
		them.  Use <A HREF="#bufexists()">bufexists()</A> to test for the existence of a buffer.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			echo bufref-&gt;bufnr()</B>
 

		Obsolete name: <A HREF="#buffer_number()">buffer_number()</A>.		*<A NAME="buffer_number()"></A><B>buffer_number()</B>*

							*<A NAME="last_buffer_nr()"></A><B>last_buffer_nr()</B>*
		Obsolete name for bufnr(&quot;$&quot;): <A HREF="#last_buffer_nr()">last_buffer_nr()</A>.


bufwinid({buf})						*<A NAME="bufwinid()"></A><B>bufwinid()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the |<A HREF="windows.html#window-ID">window-ID</A>| of the first
		<A HREF="windows.html#window">window</A> associated with buffer {buf}.  For the use of {buf},
		see |<A HREF="#bufname()">bufname()</A>| above.  If buffer {buf} doesn't exist or
		there is no such <A HREF="windows.html#window">window</A>, -1 is returned.  Example:

<B>	echo "A window containing buffer 1 is " .. (bufwinid(1))</B>
 
		Only deals with the current <A HREF="intro.html#tab">tab</A> page.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			FindBuffer()-&gt;bufwinid()</B>


bufwinnr({buf})						*<A NAME="bufwinnr()"></A><B>bufwinnr()</B>*
		Like |<A HREF="#bufwinid()">bufwinid()</A>| but return the <A HREF="windows.html#window">window</A> number instead of the
		|<A HREF="windows.html#window-ID">window-ID</A>|.
		If buffer {buf} doesn't exist or there is no such <A HREF="windows.html#window">window</A>, -1
		is returned.  Example:

<B>	echo "A window containing buffer 1 is " .. (bufwinnr(1))</B>

 		The number can be used with |<A HREF="windows.html#CTRL-W_w">CTRL-W_w</A>| and &quot;<A HREF="windows.html#:wincmd">:wincmd</A> w&quot;
		|<A HREF="windows.html#:wincmd">:wincmd</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			FindBuffer()-&gt;bufwinnr()</B>


byte2line({byte})					*<A NAME="byte2line()"></A><B>byte2line()</B>*
		Return the line number that contains the character at byte
		<A HREF="intro.html#count">count</A> {byte} in the current buffer.  This includes the
		end-of-line character, depending on the <A HREF="options.html#'fileformat'">'fileformat'</A> option
		for the current buffer.  The first character has byte <A HREF="intro.html#count">count</A>
		one.
		Also see |<A HREF="#line2byte()">line2byte()</A>|, |<A HREF="motion.html#go">go</A>| and |<A HREF="motion.html#:goto">:goto</A>|.

		Returns -1 if the {byte} value is invalid.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetOffset()-&gt;byte2line()</B>

 		{not available when compiled without the |<A HREF="various.html#+byte_offset">+byte_offset</A>|
		feature}


byteidx({expr}, {nr})					*<A NAME="byteidx()"></A><B>byteidx()</B>*
		Return byte index of the {nr}'th character in the <A HREF="eval.html#String">String</A>
		{expr}.  Use zero for the first character, <A HREF="motion.html#it">it</A> then returns
		zero.
		If there are no <A HREF="mbyte.html#multibyte">multibyte</A> characters the returned value is
		equal to {nr}.
		Composing characters are not counted separately, their byte
		length is added to the preceding base character.  See
		|<A HREF="#byteidxcomp()">byteidxcomp()</A>| below for counting composing characters
		separately.
		Example :
<B>			echo matchstr(str, ".", byteidx(str, 3))</B>
 		will display the fourth character.  Another way to <A HREF="diff.html#do">do</A> the
		same:
<B>			let s = strpart(str, byteidx(str, 3))</B>
<B>			echo strpart(s, 0, byteidx(s, 1))</B>
 		Also see |<A HREF="#strgetchar()">strgetchar()</A>| and |<A HREF="#strcharpart()">strcharpart()</A>|.

		If there are <A HREF="various.html#less">less</A> than {nr} characters -1 is returned.
		If there are exactly {nr} characters the length of the <A HREF="eval.html#string">string</A>
		in bytes is returned.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;byteidx(idx)</B>


byteidxcomp({expr}, {nr})					*<A NAME="byteidxcomp()"></A><B>byteidxcomp()</B>*
		Like <A HREF="#byteidx()">byteidx()</A>, except that a composing character is counted
		<A HREF="motion.html#as">as</A> a separate character.  Example:
<B>			let s = 'e' .. nr2char(0x301)</B>
<B>			echo byteidx(s, 1)</B>
<B>			echo byteidxcomp(s, 1)</B>
<B>			echo byteidxcomp(s, 2)</B>
 		The first and third echo result in 3 ('e' plus composing
		character is 3 bytes), the second echo results in 1 ('e' is
		one byte).
		Only works differently from <A HREF="#byteidx()">byteidx()</A> when <A HREF="options.html#'encoding'">'encoding'</A> is set
		to a <A HREF="mbyte.html#Unicode">Unicode</A> encoding.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;byteidxcomp(idx)</B>


call({func}, <A HREF="editing.html#{arglist}">{arglist}</A> [, {dict}])			*<A NAME="call()"></A><B>call()</B>* *<A NAME="E699"></A><B>E699</B>*
		Call function {func} with the items in |<A HREF="eval.html#List">List</A>| <A HREF="editing.html#{arglist}">{arglist}</A> <A HREF="motion.html#as">as</A>
		arguments.
		{func} can either be a |<A HREF="eval.html#Funcref">Funcref</A>| or the name of a function.
		<A HREF="eval.html#a:firstline">a:firstline</A> and <A HREF="eval.html#a:lastline">a:lastline</A> are set to the cursor line.
		Returns the return value of the called function.
		{dict} is for <A HREF="eval.html#functions">functions</A> with the &quot;<A HREF="eval.html#dict">dict</A>&quot; attribute.  It will be
		used to set the local variable &quot;<A HREF="eval.html#self">self</A>&quot;. |<A HREF="eval.html#Dictionary-function">Dictionary-function</A>|

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFunc()-&gt;call([arg, arg], dict)</B>


ceil({expr})							*<A NAME="ceil()"></A><B>ceil()</B>*
		Return the smallest integral value greater than or equal to
		{expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| (round up).
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			echo ceil(1.456)</B>
 			2.0 
<B>			echo ceil(-5.456)</B>
 			-5.0 
<B>			echo ceil(4.0)</B>
 			4.0

		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;ceil()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


ch_ functions are documented here: |<A HREF="channel.html#channel-functions-details">channel-functions-details</A>|



<A HREF="#changenr()">changenr()</A>						*<A NAME="changenr()"></A><B>changenr()</B>*
		Return the number of the most recent change.  This is the same
		number <A HREF="motion.html#as">as</A> what is displayed with |<A HREF="undo.html#:undolist">:undolist</A>| and can be used
		with the |<A HREF="undo.html#:undo">:undo</A>| command.
		When a change was made <A HREF="motion.html#it">it</A> is the number of that change.  After
		<A HREF="undo.html#redo">redo</A> <A HREF="motion.html#it">it</A> is the number of the redone change.  After <A HREF="undo.html#undo">undo</A> <A HREF="motion.html#it">it</A> is
		one <A HREF="various.html#less">less</A> than the number of the undone change.
		Returns 0 if the <A HREF="undo.html#undo">undo</A> <A HREF="eval.html#list">list</A> is empty.


char2nr({string} [, {utf8}])					*<A NAME="char2nr()"></A><B>char2nr()</B>*
		Return <A HREF="eval.html#Number">Number</A> value of the first char in {string}.
		Examples:
<B>			char2nr(" ")		returns 32</B>
<B>			char2nr("ABC")		returns 65</B>
 		When {utf8} is omitted or zero, the current <A HREF="options.html#'encoding'">'encoding'</A> is used.
		Example for &quot;<A HREF="mbyte.html#utf-8">utf-8</A>&quot;:
<B>			char2nr("")		returns 225</B>
<B>			char2nr(""[0])		returns 195</B>
 		When {utf8} is <A HREF="eval.html#TRUE">TRUE</A>, always treat <A HREF="motion.html#as">as</A> <A HREF="mbyte.html#UTF-8">UTF-8</A> characters.
		A combining character is a separate character.
		|<A HREF="#nr2char()">nr2char()</A>| does the opposite.
		To turn a <A HREF="eval.html#string">string</A> into a <A HREF="eval.html#list">list</A> of character numbers:
<B>		    let str = "ABC"</B>
<B>		    let list = map(split(str, '\zs'), {_, val -&gt; char2nr(val)})</B>
 		Result: [65, 66, 67]

		Returns 0 if {string} is not a |<A HREF="eval.html#String">String</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetChar()-&gt;char2nr()</B>


charclass({string})					*<A NAME="charclass()"></A><B>charclass()</B>*
		Return the character class of the first character in {string}.
		The character class is one of:
			0	blank
			1	punctuation
			2	<A HREF="motion.html#word">word</A> character
			3	emoji
			other	specific <A HREF="mbyte.html#Unicode">Unicode</A> class
		The class is used in patterns and <A HREF="motion.html#word">word</A> motions.
		Returns 0 if {string} is not a |<A HREF="eval.html#String">String</A>|.



charcol({expr})						*<A NAME="charcol()"></A><B>charcol()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#col()">col()</A>| but returns the character index of the column
		position given with {expr} instead of the byte position.

		Example:
		With the cursor on '' in line 5 with text &quot;&quot;:
<B>			charcol('.')		returns 3</B>
<B>			col('.')		returns 7</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPos()-&gt;col()</B>
 

							*<A NAME="charidx()"></A><B>charidx()</B>*
charidx({string}, {idx} [, {countcc}])
		Return the character index of the byte at {idx} in {string}.
		The index of the first character is zero.
		If there are no <A HREF="mbyte.html#multibyte">multibyte</A> characters the returned value is
		equal to {idx}.
		When {countcc} is omitted or |<A HREF="eval.html#FALSE">FALSE</A>|, then composing characters
		are not counted separately, their byte length is
		added to the preceding base character.
		When {countcc} is |<A HREF="eval.html#TRUE">TRUE</A>|, then composing characters are
		counted <A HREF="motion.html#as">as</A> separate characters.
		Returns -1 if the arguments are invalid or if {idx} is greater
		than the index of the last byte in {string}.  An error is
		given if the first argument is not a <A HREF="eval.html#string">string</A>, the second
		argument is not a number or when the third argument is present
		and is not zero or one.
		See |<A HREF="#byteidx()">byteidx()</A>| and |<A HREF="#byteidxcomp()">byteidxcomp()</A>| for getting the byte index
		from the character index.
		Examples:
<B>			echo charidx('abc', 3)		returns 1</B>
<B>			echo charidx('abc', 6, 1)	returns 4</B>
<B>			echo charidx('abc', 16)		returns -1</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;charidx(idx)</B>


chdir({dir})						*<A NAME="chdir()"></A><B>chdir()</B>*
		Change the current working directory to {dir}.  The scope of
		the directory change depends on the directory of the current
		<A HREF="windows.html#window">window</A>:
			- If the current <A HREF="windows.html#window">window</A> has a window-local directory
			  (|<A HREF="editing.html#:lcd">:lcd</A>|), then changes the <A HREF="windows.html#window">window</A> local directory.
			- Otherwise, if the current <A HREF="tabpage.html#tabpage">tabpage</A> has a local
			  directory (|<A HREF="editing.html#:tcd">:tcd</A>|) then changes the <A HREF="tabpage.html#tabpage">tabpage</A> local
			  directory.
			- Otherwise, changes the global directory.
		{dir} must be a <A HREF="eval.html#String">String</A>.
		If successful, returns the previous working directory.  Pass
		this to another <A HREF="#chdir()">chdir()</A> to restore the directory.
		On failure, returns an empty <A HREF="eval.html#string">string</A>.

		Example:
<B>			let save_dir = chdir(newdir)</B>
<B>			if save_dir != ""</B>
<B>			   " ... do some work</B>
<B>			   call chdir(save_dir)</B>
<B>			endif</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetDir()-&gt;chdir()</B>
 

cindent({lnum})						*<A NAME="cindent()"></A><B>cindent()</B>*
		Get the amount of indent for line {lnum} according the C
		indenting rules, <A HREF="motion.html#as">as</A> with <A HREF="options.html#'cindent'">'cindent'</A>.
		The indent is counted in spaces, the value of <A HREF="options.html#'tabstop'">'tabstop'</A> is
		relevant.  {lnum} is used just like in |<A HREF="#getline()">getline()</A>|.
		When {lnum} is invalid -1 is returned.
		See |<A HREF="indent.html#C-indenting">C-indenting</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;cindent()</B>


clearmatches([{win}])					*<A NAME="clearmatches()"></A><B>clearmatches()</B>*
		Clears all matches previously defined for the current <A HREF="windows.html#window">window</A>
		by |<A HREF="#matchadd()">matchadd()</A>| and the |<A HREF="pattern.html#:match">:match</A>| commands.
		If {win} is specified, use the <A HREF="windows.html#window">window</A> with this number or
		<A HREF="windows.html#window">window</A> ID instead of the current <A HREF="windows.html#window">window</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWin()-&gt;clearmatches()</B>
 

							*<A NAME="col()"></A><B>col()</B>*
col({expr})	The result is a <A HREF="eval.html#Number">Number</A>, which is the byte index of the column
		position given with {expr}.  The accepted positions are:
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of bytes in the cursor line plus one)
		    'x	    position of <A HREF="motion.html#mark">mark</A> <A HREF="change.html#x">x</A> (if the <A HREF="motion.html#mark">mark</A> is not set, 0 is
			    returned)
		    <A HREF="visual.html#v">v</A>       In <A HREF="visual.html#Visual">Visual</A> mode: the start of the <A HREF="visual.html#Visual">Visual</A> area (the
			    cursor is the end).  When not in <A HREF="visual.html#Visual">Visual</A> mode
			    returns the cursor position.  Differs from |<A HREF="motion.html#'&lt;">'&lt;</A>| in
			    that it's updated right away.
		Additionally {expr} can be [lnum, col]: a |<A HREF="eval.html#List">List</A>| with the line
		and column number. Most useful when the column is &quot;<A HREF="motion.html#$">$</A>&quot;, to get
		the last column of a specific line.  When &quot;lnum&quot; or &quot;col&quot; is
		out of range then <A HREF="#col()">col()</A> returns zero.
		To get the line number use |<A HREF="#line()">line()</A>|.  To get both use
		|<A HREF="#getpos()">getpos()</A>|.
		For the screen column position use |<A HREF="#virtcol()">virtcol()</A>|.  For the
		character position use |<A HREF="#charcol()">charcol()</A>|.
		Note that only marks in the current file can be used.
		Examples:
<B>			col(".")		column of cursor</B>
<B>			col("$")		length of cursor line plus one</B>
<B>			col("'t")		column of mark t</B>
<B>			col("'" .. markname)	column of mark markname</B>
 		The first column is 1.  Returns 0 if {expr} is invalid.
		For an <A HREF="change.html#uppercase">uppercase</A> <A HREF="motion.html#mark">mark</A> the column may actually be in another
		buffer.
		For the cursor position, when <A HREF="options.html#'virtualedit'">'virtualedit'</A> is active, the
		column is one higher if the cursor is after the end of the
		line.  This can be used to obtain the column in <A HREF="insert.html#Insert">Insert</A> mode:
<B>			:imap &lt;F2&gt; &lt;C-O&gt;:let save_ve = &amp;ve&lt;CR&gt;</B>
<B>				\&lt;C-O&gt;:set ve=all&lt;CR&gt;</B>
<B>				\&lt;C-O&gt;:echo col(".") .. "\n" &lt;Bar&gt;</B>
<B>				\let &amp;ve = save_ve&lt;CR&gt;</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPos()-&gt;col()</B>
 


complete({startcol}, {matches})			*<A NAME="complete()"></A><B>complete()</B>* *<A NAME="E785"></A><B>E785</B>*
		Set the matches for <A HREF="insert.html#Insert">Insert</A> mode completion.
		Can only be used in <A HREF="insert.html#Insert">Insert</A> mode.  You need to use a <A HREF="map.html#mapping">mapping</A>
		with CTRL-R = (see |<A HREF="insert.html#i_CTRL-R">i_CTRL-R</A>|).  It does not work after <A HREF="motion.html#CTRL-O">CTRL-O</A>
		or with an <A HREF="eval.html#expression">expression</A> <A HREF="map.html#mapping">mapping</A>.
		{startcol} is the byte offset in the line where the completed
		text start.  The text up to the cursor is the original text
		that will be replaced by the matches.  Use col('.') for an
		empty <A HREF="eval.html#string">string</A>.  &quot;col('.') - 1&quot; will replace one character by a
		match.
		{matches} must be a |<A HREF="eval.html#List">List</A>|.  Each |<A HREF="eval.html#List">List</A>| item is one match.
		See |<A HREF="insert.html#complete-items">complete-items</A>| for the kind of items that are possible.
		&quot;longest&quot; in <A HREF="options.html#'completeopt'">'completeopt'</A> is ignored.
		Note that the after calling this function you need to avoid
		<A HREF="insert.html#inserting">inserting</A> anything that would cause completion to stop.
		The match can be selected with <A HREF="motion.html#CTRL-N">CTRL-N</A> and <A HREF="motion.html#CTRL-P">CTRL-P</A> <A HREF="motion.html#as">as</A> usual with
		<A HREF="insert.html#Insert">Insert</A> mode completion.  The <A HREF="popup.html#popup">popup</A> menu will appear if
		specified, see |<A HREF="insert.html#ins-completion-menu">ins-completion-menu</A>|.
		Example:
<B>	inoremap &lt;F5&gt; &lt;C-R&gt;=ListMonths()&lt;CR&gt;</B>

<B>	func! ListMonths()</B>
<B>	  call complete(col('.'), ['January', 'February', 'March',</B>
<B>		\ 'April', 'May', 'June', 'July', 'August', 'September',</B>
<B>		\ 'October', 'November', 'December'])</B>
<B>	  return ''</B>
<B>	endfunc</B>
 		This isn't very useful, but <A HREF="motion.html#it">it</A> shows how <A HREF="motion.html#it">it</A> works.  Note that
		an empty <A HREF="eval.html#string">string</A> is returned to avoid a zero being inserted.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetMatches()-&gt;complete(col('.'))</B>


complete_add({expr})				*<A NAME="complete_add()"></A><B>complete_add()</B>*
		Add {expr} to the <A HREF="eval.html#list">list</A> of matches.  Only to be used by the
		function specified with the <A HREF="options.html#'completefunc'">'completefunc'</A> option.
		Returns 0 for failure (empty <A HREF="eval.html#string">string</A> or out of memory),
		1 when the match was added, 2 when the match was already in
		the <A HREF="eval.html#list">list</A>.
		See |<A HREF="insert.html#complete-functions">complete-functions</A>| for an explanation of {expr}.  It is
		the same <A HREF="motion.html#as">as</A> one item in the <A HREF="eval.html#list">list</A> that <A HREF="options.html#'omnifunc'">'omnifunc'</A> would return.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMoreMatches()-&gt;complete_add()</B>


<A HREF="#complete_check()">complete_check()</A>				*<A NAME="complete_check()"></A><B>complete_check()</B>*
		Check for a key typed while looking for completion matches.
		This is to be used when looking for matches takes some time.
		Returns |<A HREF="eval.html#TRUE">TRUE</A>| when searching for matches is to be aborted,
		zero otherwise.
		Only to be used by the function specified with the
		<A HREF="options.html#'completefunc'">'completefunc'</A> option.



complete_info([{what}])				*<A NAME="complete_info()"></A><B>complete_info()</B>*
		Returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| with information about <A HREF="insert.html#Insert">Insert</A> mode
		completion.  See |<A HREF="insert.html#ins-completion">ins-completion</A>|.
		The items are:
		   mode		Current completion mode name <A HREF="eval.html#string">string</A>.
				See |<A HREF="#complete_info_mode">complete_info_mode</A>| for the values.
		   pum_visible	|<A HREF="eval.html#TRUE">TRUE</A>| if <A HREF="popup.html#popup">popup</A> menu is visible.
				See |<A HREF="#pumvisible()">pumvisible()</A>|.
		   items	<A HREF="eval.html#List">List</A> of completion matches.  Each item is a
				dictionary containing the entries &quot;<A HREF="motion.html#word">word</A>&quot;,
				&quot;abbr&quot;, &quot;menu&quot;, &quot;kind&quot;, &quot;info&quot; and &quot;user_data&quot;.
				See |<A HREF="insert.html#complete-items">complete-items</A>|.
		   selected	Selected item index.  First index is zero.
				Index is -1 if no item is selected (showing
				typed text only, or the last completion after
				no item is selected when using the <A HREF="motion.html#&lt;Up&gt;">&lt;Up&gt;</A> or
				<A HREF="motion.html#&lt;Down&gt;">&lt;Down&gt;</A> keys)
		   inserted	Inserted <A HREF="eval.html#string">string</A>. [NOT IMPLEMENT YET]


							*<A NAME="complete_info_mode"></A><B>complete_info_mode</B>*
		mode values are:
		   &quot;&quot;		     Not in completion mode
		   &quot;keyword&quot;	     Keyword completion |<A HREF="insert.html#i_CTRL-X_CTRL-N">i_CTRL-X_CTRL-N</A>|
		   &quot;ctrl_x&quot;	     Just pressed CTRL-X |<A HREF="insert.html#i_CTRL-X">i_CTRL-X</A>|
		   &quot;scroll&quot;	     Scrolling with |<A HREF="insert.html#i_CTRL-X_CTRL-E">i_CTRL-X_CTRL-E</A>| or
				     |<A HREF="insert.html#i_CTRL-X_CTRL-Y">i_CTRL-X_CTRL-Y</A>|
		   &quot;whole_line&quot;	     Whole lines |<A HREF="insert.html#i_CTRL-X_CTRL-L">i_CTRL-X_CTRL-L</A>|
		   &quot;files&quot;	     File names |<A HREF="insert.html#i_CTRL-X_CTRL-F">i_CTRL-X_CTRL-F</A>|
		   &quot;<A HREF="tagsrch.html#tags">tags</A>&quot;	     Tags |<A HREF="insert.html#i_CTRL-X_CTRL-]">i_CTRL-X_CTRL-]</A>|
		   &quot;path_defines&quot;    Definition completion |<A HREF="insert.html#i_CTRL-X_CTRL-D">i_CTRL-X_CTRL-D</A>|
		   &quot;path_patterns&quot;   Include completion |<A HREF="insert.html#i_CTRL-X_CTRL-I">i_CTRL-X_CTRL-I</A>|
		   &quot;dictionary&quot;	     <A HREF="eval.html#Dictionary">Dictionary</A> |<A HREF="insert.html#i_CTRL-X_CTRL-K">i_CTRL-X_CTRL-K</A>|
		   &quot;thesaurus&quot;	     Thesaurus |<A HREF="insert.html#i_CTRL-X_CTRL-T">i_CTRL-X_CTRL-T</A>|
		   &quot;cmdline&quot;	     Vim Command line |<A HREF="insert.html#i_CTRL-X_CTRL-V">i_CTRL-X_CTRL-V</A>|
		   &quot;function&quot;	     <A HREF="autocmd.html#User">User</A> defined completion |<A HREF="insert.html#i_CTRL-X_CTRL-U">i_CTRL-X_CTRL-U</A>|
		   &quot;omni&quot;	     Omni completion |<A HREF="insert.html#i_CTRL-X_CTRL-O">i_CTRL-X_CTRL-O</A>|
		   &quot;<A HREF="spell.html#spell">spell</A>&quot;	     Spelling suggestions |<A HREF="insert.html#i_CTRL-X_s">i_CTRL-X_s</A>|
		   &quot;<A HREF="eval.html#eval">eval</A>&quot;	     |<A HREF="#complete()">complete()</A>| completion
		   &quot;unknown&quot;	     Other internal modes

		If the optional {what} <A HREF="eval.html#list">list</A> argument is supplied, then only
		the items listed in {what} are returned.  Unsupported items in
		{what} are silently ignored.

		To get the position and size of the <A HREF="popup.html#popup">popup</A> menu, see
		|<A HREF="#pum_getpos()">pum_getpos()</A>|. It's also available in |<A HREF="eval.html#v:event">v:event</A>| during the
		|<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>| event.

		Returns an empty |<A HREF="eval.html#Dictionary">Dictionary</A>| on error.

		Examples:
<B>			" Get all items</B>
<B>			call complete_info()</B>
<B>			" Get only 'mode'</B>
<B>			call complete_info(['mode'])</B>
<B>			" Get only 'mode' and 'pum_visible'</B>
<B>			call complete_info(['mode', 'pum_visible'])</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetItems()-&gt;complete_info()</B>
 

						*<A NAME="confirm()"></A><B>confirm()</B>*
confirm({msg} [, {choices} [, {default} [, {type}]]])
		<A HREF="#confirm()">confirm()</A> offers the user a <A HREF="gui_w32.html#dialog">dialog</A>, from which a choice can be
		made.  It returns the number of the choice.  For the first
		choice this is 1.
		Note: <A HREF="#confirm()">confirm()</A> is only supported when compiled with <A HREF="gui_w32.html#dialog">dialog</A>
		support, see |<A HREF="various.html#+dialog_con">+dialog_con</A>| and |<A HREF="various.html#+dialog_gui">+dialog_gui</A>|.

		{msg} is displayed in a |<A HREF="gui_w32.html#dialog">dialog</A>| with {choices} <A HREF="motion.html#as">as</A> the
		alternatives.  When {choices} is missing or empty, &quot;&amp;OK&quot; is
		used (and translated).
		{msg} is a <A HREF="eval.html#String">String</A>, use '\n' to include a newline.  Only on
		some systems the <A HREF="eval.html#string">string</A> is wrapped when <A HREF="motion.html#it">it</A> doesn't fit.

		{choices} is a <A HREF="eval.html#String">String</A>, with the individual choices separated
		by '\n', e.g.
<B>			confirm("Save changes?", "&amp;Yes\n&amp;No\n&amp;Cancel")</B>
 		The <A HREF="print.html#letter">letter</A> after the '<A HREF="change.html#&amp;">&amp;</A>' is the shortcut key for that choice.
		Thus you can type '<A HREF="change.html#c">c</A>' to select &quot;Cancel&quot;.  The shortcut does
		not need to be the first <A HREF="print.html#letter">letter</A>:
<B>			confirm("file has been modified", "&amp;Save\nSave &amp;All")</B>
 		For the console, the first <A HREF="print.html#letter">letter</A> of each choice is used <A HREF="motion.html#as">as</A>
		the default shortcut key.  Case is ignored.

		The optional {default} argument is the number of the choice
		that is made if the user hits <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A>.  Use 1 to make the first
		choice the default one.  Use 0 to not set a default.  If
		{default} is omitted, 1 is used.

		The optional {type} <A HREF="eval.html#String">String</A> argument gives the type of <A HREF="gui_w32.html#dialog">dialog</A>.
		This is only used for the icon of the <A HREF="gui_x11.html#GTK">GTK</A>, <A HREF="os_mac.html#Mac">Mac</A>, <A HREF="gui_x11.html#Motif">Motif</A> and
		<A HREF="os_win32.html#Win32">Win32</A> <A HREF="gui.html#GUI">GUI</A>.  It can be one of these values: &quot;Error&quot;,
		&quot;Question&quot;, &quot;Info&quot;, &quot;Warning&quot; or &quot;Generic&quot;.  Only the first
		character is relevant.  When {type} is omitted, &quot;Generic&quot; is
		used.

		If the user aborts the <A HREF="gui_w32.html#dialog">dialog</A> by pressing <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>, <A HREF="pattern.html#CTRL-C">CTRL-C</A>,
		or another valid interrupt key, <A HREF="#confirm()">confirm()</A> returns 0.

		An example:
<B>		   let choice = confirm("What do you want?",</B>
<B>					\ "&amp;Apples\n&amp;Oranges\n&amp;Bananas", 2)</B>
<B>		   if choice == 0</B>
<B>			echo "make up your mind!"</B>
<B>		   elseif choice == 3</B>
<B>			echo "tasteful"</B>
<B>		   else</B>
<B>			echo "I prefer bananas myself."</B>
<B>		   endif</B>
 		In a <A HREF="gui.html#GUI">GUI</A> <A HREF="gui_w32.html#dialog">dialog</A>, buttons are used.  The layout of the buttons
		depends on the '<A HREF="visual.html#v">v</A>' flag in <A HREF="options.html#'guioptions'">'guioptions'</A>.  If <A HREF="motion.html#it">it</A> is included,
		the buttons are always put vertically.  Otherwise,  <A HREF="#confirm()">confirm()</A>
		tries to put the buttons in one horizontal line.  If they
		don't fit, a vertical layout is used anyway.  For some systems
		the horizontal layout is always used.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|in:
<B>			BuildMessage()-&gt;confirm("&amp;Yes\n&amp;No")</B>
 

							*<A NAME="copy()"></A><B>copy()</B>*
copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
		different from using {expr} directly.
		When {expr} is a |<A HREF="eval.html#List">List</A>| a shallow copy is created.  This means
		that the original |<A HREF="eval.html#List">List</A>| can be changed without <A HREF="change.html#changing">changing</A> the
		copy, and vice versa.  But the items are identical, thus
		<A HREF="change.html#changing">changing</A> an item changes the contents of both |<A HREF="eval.html#Lists">Lists</A>|.
		A |<A HREF="eval.html#Dictionary">Dictionary</A>| is copied in a similar way <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#List">List</A>|.
		Also see |<A HREF="#deepcopy()">deepcopy()</A>|.
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;copy()</B>


cos({expr})						*<A NAME="cos()"></A><B>cos()</B>*
		Return the cosine of {expr}, measured in radians, <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|.
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo cos(100)</B>
 			0.862319
<B>			:echo cos(-4.01)</B>
 			-0.646043

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;cos()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



cosh({expr})						*<A NAME="cosh()"></A><B>cosh()</B>*
		Return the hyperbolic cosine of {expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| in the range
		[1, inf].
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo cosh(0.5)</B>
 			1.127626
<B>			:echo cosh(-0.5)</B>
 			-1.127626

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;cosh()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



count({comp}, {expr} [, {ic} [, {start}]])			*<A NAME="count()"></A><B>count()</B>*
		Return the number of times an item with value {expr} appears
		in |<A HREF="eval.html#String">String</A>|, |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| {comp}.

		If {start} is given then start with the item with this index.
		{start} can only be used with a |<A HREF="eval.html#List">List</A>|.

		When {ic} is given and it's |<A HREF="eval.html#TRUE">TRUE</A>| then <A HREF="change.html#case">case</A> is ignored.

		When {comp} is a <A HREF="eval.html#string">string</A> then the number of not overlapping
		occurrences of {expr} is returned. Zero is returned when
		{expr} is an empty <A HREF="eval.html#string">string</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;count(val)</B>
 

							*<A NAME="cscope_connection()"></A><B>cscope_connection()</B>*
cscope_connection([{num} , {dbpath} [, {prepend}]])
		Checks for the existence of a |<A HREF="if_cscop.html#cscope">cscope</A>| connection.  If no
		parameters are specified, then the function returns:
			0, if <A HREF="if_cscop.html#cscope">cscope</A> was not available (not compiled in), or
			   if there are no <A HREF="if_cscop.html#cscope">cscope</A> connections;
			1, if there is at least one <A HREF="if_cscop.html#cscope">cscope</A> connection.

		If parameters are specified, then the value of {num}
		determines how existence of a <A HREF="if_cscop.html#cscope">cscope</A> connection is checked:

		{num}	Description of existence check
		-----	------------------------------
		0	Same <A HREF="motion.html#as">as</A> no parameters (e.g., &quot;cscope_connection()&quot;).
		1	Ignore {prepend}, and use <A HREF="#partial">partial</A> <A HREF="eval.html#string">string</A> matches for
			{dbpath}.
		2	Ignore {prepend}, and use exact <A HREF="eval.html#string">string</A> matches for
			{dbpath}.
		3	Use {prepend}, use <A HREF="#partial">partial</A> <A HREF="eval.html#string">string</A> matches for both
			{dbpath} and {prepend}.
		4	Use {prepend}, use exact <A HREF="eval.html#string">string</A> matches for both
			{dbpath} and {prepend}.

		Note: All <A HREF="eval.html#string">string</A> comparisons are <A HREF="change.html#case">case</A> sensitive!

		Examples.  Suppose we had the following (from &quot;<A HREF="if_cscop.html#:cs">:cs</A> show&quot;):

<B>  # pid    database name			prepend path</B>
<B>  0 27664  cscope.out				/usr/local</B>
 
<B><FONT COLOR="PURPLE">		Invocation					Return Val </FONT></B>
		----------					----------
<B>		cscope_connection()					1</B>
<B>		cscope_connection(1, "out")				1</B>
<B>		cscope_connection(2, "out")				0</B>
<B>		cscope_connection(3, "out")				0</B>
<B>		cscope_connection(3, "out", "local")			1</B>
<B>		cscope_connection(4, "out")				0</B>
<B>		cscope_connection(4, "out", "local")			0</B>
<B>		cscope_connection(4, "cscope.out", "/usr/local")	1</B>
 

cursor({lnum}, {col} [, {off}])				*<A NAME="cursor()"></A><B>cursor()</B>*
cursor({list})
		Positions the cursor at the column (byte <A HREF="intro.html#count">count</A>) {col} in the
		line {lnum}.  The first column is one.

		When there is one argument {list} this is used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#List">List</A>|
		with two, three or four item:
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		This is like the return value of |<A HREF="#getpos()">getpos()</A>| or |<A HREF="#getcurpos()">getcurpos()</A>|,
		but without the first item.

		To position the cursor using the character <A HREF="intro.html#count">count</A>, use
		|<A HREF="#setcursorcharpos()">setcursorcharpos()</A>|.

		Does not change the <A HREF="motion.html#jumplist">jumplist</A>.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.
		If {lnum} is greater than the number of lines in the buffer,
		the cursor will be positioned at the last line in the buffer.
		If {lnum} is zero, the cursor will stay in the current line.
		If {col} is greater than the number of bytes in the line,
		the cursor will be positioned at the last character in the
		line.
		If {col} is zero, the cursor will stay in the current column.
		If {curswant} is given <A HREF="motion.html#it">it</A> is used to set the preferred column
		for vertical <A HREF="intro.html#movement">movement</A>.  Otherwise {col} is used.

		When <A HREF="options.html#'virtualedit'">'virtualedit'</A> is used {off} specifies the offset in
		screen columns from the start of the character.  E.g., a
		position within a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> or after the last character.
		Returns 0 when the position could be set, -1 otherwise.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetCursorPos()-&gt;cursor()</B>


debugbreak({pid})					*<A NAME="debugbreak()"></A><B>debugbreak()</B>*
		Specifically used to interrupt a program being debugged.  It
		will cause process {pid} to get a SIGTRAP.  Behavior for other
		processes is undefined. See |<A HREF="terminal.html#terminal-debugger">terminal-debugger</A>|.
		{only available on MS-Windows}

		Returns |<A HREF="eval.html#TRUE">TRUE</A>| if successfully interrupted the program.
		Otherwise returns |<A HREF="eval.html#FALSE">FALSE</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPid()-&gt;debugbreak()</B>


deepcopy({expr} [, {noref}])				*<A NAME="deepcopy()"></A><B>deepcopy()</B>* *<A NAME="E698"></A><B>E698</B>*
		Make a copy of {expr}.  For Numbers and Strings this isn't
		different from using {expr} directly.
		When {expr} is a |<A HREF="eval.html#List">List</A>| a full copy is created.  This means
		that the original |<A HREF="eval.html#List">List</A>| can be changed without <A HREF="change.html#changing">changing</A> the
		copy, and vice versa.  When an item is a |<A HREF="eval.html#List">List</A>| or
		|<A HREF="eval.html#Dictionary">Dictionary</A>|, a copy for <A HREF="motion.html#it">it</A> is made, recursively.  Thus
		<A HREF="change.html#changing">changing</A> an item in the copy does not change the contents of
		the original |<A HREF="eval.html#List">List</A>|.
		A |<A HREF="eval.html#Dictionary">Dictionary</A>| is copied in a similar way <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#List">List</A>|.

		When {noref} is omitted or zero a contained |<A HREF="eval.html#List">List</A>| or
		|<A HREF="eval.html#Dictionary">Dictionary</A>| is only copied once.  All references point to
		this single copy.  With {noref} set to 1 every occurrence of a
		|<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| results in a new copy.  This also means
		that a cyclic reference causes <A HREF="#deepcopy()">deepcopy()</A> to fail.

								*<A NAME="E724"></A><B>E724</B>*
		Nesting is possible up to 100 levels.  When there is an item
		that refers back to a higher level making a deep copy with
		{noref} set to 1 will fail.
		Also see |<A HREF="#copy()">copy()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetObject()-&gt;deepcopy()</B>


delete({fname} [, {flags}])				*<A NAME="delete()"></A><B>delete()</B>*
		Without {flags} or with {flags} empty: Deletes the file by the
		name {fname}.

		This also works when {fname} is a symbolic link.  The symbolic
		link itself is deleted, not what <A HREF="motion.html#it">it</A> points to.

		When {flags} is &quot;<A HREF="change.html#d">d</A>&quot;: Deletes the directory by the name
		{fname}.  This fails when directory {fname} is not empty.

		When {flags} is &quot;rf&quot;: Deletes the directory by the name
		{fname} and everything in <A HREF="motion.html#it">it</A>, recursively.  BE CAREFUL!
		Note: on <A HREF="os_win32.html#MS-Windows">MS-Windows</A> <A HREF="motion.html#it">it</A> is not possible to delete a directory
		that is being used.

		The result is a <A HREF="eval.html#Number">Number</A>, which is 0/false if the delete
		operation was successful and -1/true when the deletion failed
		or partly failed.

		Use |<A HREF="#remove()">remove()</A>| to delete an item from a |<A HREF="eval.html#List">List</A>|.
		To delete a line from the buffer use |<A HREF="change.html#:delete">:delete</A>| or
		|<A HREF="#deletebufline()">deletebufline()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;delete()</B>


deletebufline({buf}, {first} [, {last}])		*<A NAME="deletebufline()"></A><B>deletebufline()</B>*
		Delete lines {first} to {last} (inclusive) from buffer {buf}.
		If {last} is omitted then delete line {first} only.
		On success 0 is returned, on failure 1 is returned.

		This function works only for loaded <A HREF="windows.html#buffers">buffers</A>. First call
		|<A HREF="#bufload()">bufload()</A>| if needed.

		For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>| above.

		{first} and {last} are used like with |<A HREF="#getline()">getline()</A>|. Note that
		when using |<A HREF="#line()">line()</A>| this refers to the current buffer. Use &quot;<A HREF="motion.html#$">$</A>&quot;
		to refer to the last line in buffer {buf}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBuffer()-&gt;deletebufline(1)</B>
 

							*<A NAME="did_filetype()"></A><B>did_filetype()</B>*
<A HREF="#did_filetype()">did_filetype()</A>	Returns |<A HREF="eval.html#TRUE">TRUE</A>| when <A HREF="autocmd.html#autocommands">autocommands</A> are being executed and the
		<A HREF="autocmd.html#FileType">FileType</A> event has been triggered at least once.  Can be used
		to avoid triggering the <A HREF="autocmd.html#FileType">FileType</A> event again in the scripts
		that detect the file type. |<A HREF="autocmd.html#FileType">FileType</A>|
		Returns |<A HREF="eval.html#FALSE">FALSE</A>| when `:setf FALLBACK` was used.
		When editing another file, the counter is reset, thus this
		really checks if the <A HREF="autocmd.html#FileType">FileType</A> event has been triggered for the
		current buffer.  This allows an <A HREF="autocmd.html#autocommand">autocommand</A> that starts
		editing another buffer to set <A HREF="options.html#'filetype'">'filetype'</A> and load a <A HREF="syntax.html#syntax">syntax</A>
		file.


diff_filler({lnum})					*<A NAME="diff_filler()"></A><B>diff_filler()</B>*
		Returns the number of filler lines above line {lnum}.
		These are the lines that were inserted at this point in
		another diff'ed <A HREF="windows.html#window">window</A>.  These filler lines are shown in the
		display but don't exist in the buffer.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.  Thus &quot;<A HREF="repeat.html#.">.</A>&quot; is the current
		line, &quot;'m&quot; <A HREF="motion.html#mark">mark</A> <A HREF="motion.html#m">m</A>, etc.
		Returns 0 if the current <A HREF="windows.html#window">window</A> is not in <A HREF="diff.html#diff">diff</A> mode.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;diff_filler()</B>


diff_hlID({lnum}, {col})				*<A NAME="diff_hlID()"></A><B>diff_hlID()</B>*
		Returns the highlight ID for <A HREF="diff.html#diff">diff</A> mode at line {lnum} column
		{col} (byte index).  When the current line does not have a
		<A HREF="diff.html#diff">diff</A> change zero is returned.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.  Thus &quot;<A HREF="repeat.html#.">.</A>&quot; is the current
		line, &quot;'m&quot; <A HREF="motion.html#mark">mark</A> <A HREF="motion.html#m">m</A>, etc.
		{col} is 1 for the leftmost column, {lnum} is 1 for the first
		line.
		The highlight ID can be used with |<A HREF="#synIDattr()">synIDattr()</A>| to obtain
		<A HREF="syntax.html#syntax">syntax</A> information about the highlighting.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;diff_hlID(col)</B>
 


digraph_get({chars})					*<A NAME="digraph_get()"></A><B>digraph_get()</B>* *<A NAME="E1214"></A><B>E1214</B>*
		Return the <A HREF="digraph.html#digraph">digraph</A> of {chars}.  This should be a <A HREF="eval.html#string">string</A> with
		exactly two characters.  If {chars} are not just two
		characters, or the <A HREF="digraph.html#digraph">digraph</A> of {chars} does not exist, an error
		is given and an empty <A HREF="eval.html#string">string</A> is returned.

		The character will be converted from <A HREF="mbyte.html#Unicode">Unicode</A> to <A HREF="options.html#'encoding'">'encoding'</A>
		when needed.  This does require the conversion to be
		available, <A HREF="motion.html#it">it</A> might fail.

		Also see |<A HREF="#digraph_getlist()">digraph_getlist()</A>|.

		Examples:
<B>		" Get a built-in digraph</B>
<B>		:echo digraph_get('00')		" Returns ''</B>

<B>		" Get a user-defined digraph</B>
<B>		:call digraph_set('aa', '')</B>
<B>		:echo digraph_get('aa')		" Returns ''</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetChars()-&gt;digraph_get()</B>
 
		This function works only when compiled with the |<A HREF="various.html#+digraphs">+digraphs</A>|
		feature.  If this feature is disabled, this function will
		display an error message.



digraph_getlist([{listall}])				*<A NAME="digraph_getlist()"></A><B>digraph_getlist()</B>*
		Return a <A HREF="eval.html#list">list</A> of <A HREF="digraph.html#digraphs">digraphs</A>.  If the {listall} argument is given
		and <A HREF="motion.html#it">it</A> is <A HREF="eval.html#TRUE">TRUE</A>, return all <A HREF="digraph.html#digraphs">digraphs</A>, including the default
		<A HREF="digraph.html#digraphs">digraphs</A>.  Otherwise, return only user-defined <A HREF="digraph.html#digraphs">digraphs</A>.

		The characters will be converted from <A HREF="mbyte.html#Unicode">Unicode</A> to <A HREF="options.html#'encoding'">'encoding'</A>
		when needed.  This does require the conservation to be
		available, <A HREF="motion.html#it">it</A> might fail.

		Also see |<A HREF="#digraph_get()">digraph_get()</A>|.

		Examples:
<B>		" Get user-defined digraphs</B>
<B>		:echo digraph_getlist()</B>

<B>		" Get all the digraphs, including default digraphs</B>
<B>		:echo digraph_getlist(1)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetNumber()-&gt;digraph_getlist()</B>
 
		This function works only when compiled with the |<A HREF="various.html#+digraphs">+digraphs</A>|
		feature.  If this feature is disabled, this function will
		display an error message.



digraph_set({chars}, {digraph})				*<A NAME="digraph_set()"></A><B>digraph_set()</B>*
		Add <A HREF="digraph.html#digraph">digraph</A> {chars} to the <A HREF="eval.html#list">list</A>.  {chars} must be a <A HREF="eval.html#string">string</A>
		with two characters.  {digraph} is a <A HREF="eval.html#string">string</A> with one <A HREF="mbyte.html#UTF-8">UTF-8</A>

		encoded character.  *<A NAME="E1215"></A><B>E1215</B>*
		Be careful, composing characters are NOT ignored.  This
		function is similar to |<A HREF="digraph.html#:digraphs">:digraphs</A>| command, but useful to add
		<A HREF="digraph.html#digraphs">digraphs</A> start with a white space.

		The function result is <A HREF="eval.html#v:true">v:true</A> if |<A HREF="digraph.html#digraph">digraph</A>| is registered.  If
		this fails an error message is given and <A HREF="eval.html#v:false">v:false</A> is returned.

		If you want to define multiple <A HREF="digraph.html#digraphs">digraphs</A> at once, you can use
		|<A HREF="#digraph_setlist()">digraph_setlist()</A>|.

		Example:
<B>			call digraph_set('  ', '')</B>
 
		Can be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetString()-&gt;digraph_set('')</B>
 
		This function works only when compiled with the |<A HREF="various.html#+digraphs">+digraphs</A>|
		feature.  If this feature is disabled, this function will
		display an error message.



digraph_setlist({digraphlist})				*<A NAME="digraph_setlist()"></A><B>digraph_setlist()</B>*
		Similar to |<A HREF="#digraph_set()">digraph_set()</A>| but this function can add multiple
		<A HREF="digraph.html#digraphs">digraphs</A> at once.  {digraphlist} is a <A HREF="eval.html#list">list</A> composed of lists,
		where each <A HREF="eval.html#list">list</A> contains two strings with {chars} and

		{digraph} <A HREF="motion.html#as">as</A> in |<A HREF="#digraph_set()">digraph_set()</A>|. *<A NAME="E1216"></A><B>E1216</B>*
		Example:
<B>		    call digraph_setlist([['aa', ''], ['ii', '']])</B>
 
		It is similar to the following:
<B>		    for [chars, digraph] in [['aa', ''], ['ii', '']]</B>
<B>			  call digraph_set(chars, digraph)</B>
<B>		    endfor</B>
 		Except that the function returns after the first error,
		following <A HREF="digraph.html#digraphs">digraphs</A> will not be added.

		Can be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>		    GetList()-&gt;digraph_setlist()</B>
 
		This function works only when compiled with the |<A HREF="various.html#+digraphs">+digraphs</A>|
		feature.  If this feature is disabled, this function will
		display an error message.



echoraw({string})					*<A NAME="echoraw()"></A><B>echoraw()</B>*
		Output {string} as-is, including unprintable characters.
		This can be used to output a <A HREF="terminal.html#terminal">terminal</A> code. For example, to
		disable <A HREF="map.html#modifyOtherKeys">modifyOtherKeys</A>:
<B>			call echoraw(&amp;t_TE)</B>
 		and to enable <A HREF="motion.html#it">it</A> again:
<B>			call echoraw(&amp;t_TI)</B>
 		Use with care, you can mess up the <A HREF="terminal.html#terminal">terminal</A> this way.



empty({expr})						*<A NAME="empty()"></A><B>empty()</B>*
		Return the <A HREF="eval.html#Number">Number</A> 1 if {expr} is empty, zero otherwise.
		- A |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| is empty when <A HREF="motion.html#it">it</A> does not have any
		  items.
		- A |<A HREF="eval.html#String">String</A>| is empty when its length is zero.
		- A |<A HREF="eval.html#Number">Number</A>| and |<A HREF="eval.html#Float">Float</A>| are empty when their value is zero.
		- |<A HREF="eval.html#v:false">v:false</A>|, |<A HREF="eval.html#v:none">v:none</A>| and |<A HREF="eval.html#v:null">v:null</A>| are empty, |<A HREF="eval.html#v:true">v:true</A>| is not.
		- A |<A HREF="eval.html#Job">Job</A>| is empty when <A HREF="motion.html#it">it</A> failed to start.
		- A |<A HREF="eval.html#Channel">Channel</A>| is empty when <A HREF="motion.html#it">it</A> is closed.
		- A |<A HREF="eval.html#Blob">Blob</A>| is empty when its length is zero.

		For a long |<A HREF="eval.html#List">List</A>| this is much faster than comparing the
		length with zero.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;empty()</B>


<A HREF="#environ()">environ()</A>						*<A NAME="environ()"></A><B>environ()</B>*
		Return all of environment <A HREF="eval.html#variables">variables</A> <A HREF="motion.html#as">as</A> dictionary. You can
		check if an environment variable exists like this:
<B>			:echo has_key(environ(), 'HOME')</B>
 		Note that the variable name may be CamelCase; to ignore <A HREF="change.html#case">case</A>
		use this:
<B>			:echo index(keys(environ()), 'HOME', 0, 1) != -1</B>


escape({string}, {chars})				*<A NAME="escape()"></A><B>escape()</B>*
		Escape the characters in {chars} that occur in {string} with a
		<A HREF="intro.html#backslash">backslash</A>.  Example:
<B>			:echo escape('c:\program files\vim', ' \')</B>
 		results in:
<B>			c:\\program\ files\\vim</B>
 		Also see |<A HREF="#shellescape()">shellescape()</A>| and |<A HREF="#fnameescape()">fnameescape()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;escape(' \')</B>
 

							*<A NAME="eval()"></A><B>eval()</B>*
eval({string})	Evaluate {string} and return the result.  Especially useful to
		turn the result of |<A HREF="#string()">string()</A>| back into the original value.
		This works for Numbers, Floats, Strings, <A HREF="eval.html#Blobs">Blobs</A> and composites
		of them.  Also works for |<A HREF="eval.html#Funcref">Funcref</A>|<A HREF="change.html#s">s</A> that refer to existing
		<A HREF="eval.html#functions">functions</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			argv-&gt;join()-&gt;eval()</B>


<A HREF="#eventhandler()">eventhandler()</A>						*<A NAME="eventhandler()"></A><B>eventhandler()</B>*
		Returns 1 when inside an event handler.  That is that Vim got
		interrupted while waiting for the user to type a character,
		e.g., when dropping a file on Vim.  This means interactive
		commands cannot be used.  Otherwise zero is returned.


executable({expr})					*<A NAME="executable()"></A><B>executable()</B>*
		This function checks if an executable with the name {expr}
		exists.  {expr} must be the name of the program without any
		arguments.
		<A HREF="#executable()">executable()</A> uses the value of $PATH and/or the normal

		searchpath for programs.		*<A NAME="PATHEXT"></A><B>PATHEXT</B>*
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A> the &quot;.exe&quot;, &quot;.bat&quot;, etc. can optionally be
		included.  Then the extensions in $PATHEXT are tried.  Thus if
		&quot;foo.exe&quot; does not exist, &quot;foo.exe.bat&quot; can be found.  If
		$PATHEXT is not set then &quot;.com;.exe;.bat;.cmd&quot; is used.  A dot
		by itself can be used in $PATHEXT to try using the name
		without an extension.  When <A HREF="options.html#'shell'">'shell'</A> looks like a <A HREF="os_unix.html#Unix">Unix</A> shell,
		then the name is also tried without adding an extension.
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A> <A HREF="motion.html#it">it</A> only checks if the file exists and is not a
		directory, not if it's really executable.
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A> an executable in the same directory <A HREF="motion.html#as">as</A> Vim is
		normally found.  Since this directory is added to $PATH <A HREF="motion.html#it">it</A>
		should also work to execute <A HREF="motion.html#it">it</A> |<A HREF="os_win32.html#win32-PATH">win32-PATH</A>|.  This can be
		disabled by setting the $NoDefaultCurrentDirectoryInExePath

		environment variable.  *<A NAME="NoDefaultCurrentDirectoryInExePath"></A><B>NoDefaultCurrentDirectoryInExePath</B>*
		The result is a <A HREF="eval.html#Number">Number</A>:
			1	exists
			0	does not exist
			-1	not implemented on this system
		|<A HREF="#exepath()">exepath()</A>| can be used to get the full path of an executable.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetCommand()-&gt;executable()</B>


execute({command} [, {silent}])					*<A NAME="execute()"></A><B>execute()</B>*
		Execute an <A HREF="intro.html#Ex">Ex</A> command or commands and return the output <A HREF="motion.html#as">as</A> a
		<A HREF="eval.html#string">string</A>.
		{command} can be a <A HREF="eval.html#string">string</A> or a <A HREF="eval.html#List">List</A>.  In <A HREF="change.html#case">case</A> of a <A HREF="eval.html#List">List</A> the
		lines are executed one by one.
		This is equivalent to:
<B>			redir =&gt; var</B>
<B>			{command}</B>
<B>			redir END</B>
 
		The optional {silent} argument can have these values:
			&quot;&quot;		no `:silent` used
			&quot;silent&quot;	`:silent` used
			&quot;silent!&quot;	`:silent!` used
		The default is &quot;silent&quot;.  Note that with &quot;silent!&quot;, unlike
		`:redir`, error <A HREF="message.html#messages">messages</A> are dropped.  When using an external
		command the screen may be messed up, use `system()` instead.

							*<A NAME="E930"></A><B>E930</B>*
		It is not possible to use `:redir` anywhere in {command}.

		To get a <A HREF="eval.html#list">list</A> of lines use |<A HREF="#split()">split()</A>| on the result:
<B>			execute('args')-&gt;split("\n")</B>

 		To execute a command in another <A HREF="windows.html#window">window</A> than the current one
		use `win_execute()`.

		When used recursively the output of the recursive call is not
		included in the output of the higher level call.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetCommand()-&gt;execute()</B>


exepath({expr})						*<A NAME="exepath()"></A><B>exepath()</B>*
		If {expr} is an executable and is either an absolute path, a
		relative path or found in $PATH, return the full path.
		Note that the current directory is used when {expr} starts
		with &quot;./&quot;, which may be a problem for Vim:
<B>			echo exepath(v:progpath)</B>
 		If {expr} cannot be found in $PATH or is not executable then
		an empty <A HREF="eval.html#string">string</A> is returned.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetCommand()-&gt;exepath()</B>
 

							*<A NAME="exists()"></A><B>exists()</B>*
exists({expr})	The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| if {expr} is defined,
		zero otherwise.

		Note: In a compiled |<A HREF="vim9.html#:def">:def</A>| function the evaluation is done at
		runtime.  Use `exists_compiled()` to evaluate the <A HREF="eval.html#expression">expression</A>
		at compile time.

		For checking for a supported feature use |<A HREF="#has()">has()</A>|.
		For checking if a file exists use |<A HREF="#filereadable()">filereadable()</A>|.

		The {expr} argument is a <A HREF="eval.html#string">string</A>, which contains one of these:
			varname		internal variable (see
			dict.key	|<A HREF="eval.html#internal-variables">internal-variables</A>|).  Also works
			list[i]		for |<A HREF="eval.html#curly-braces-names">curly-braces-names</A>|, |<A HREF="eval.html#Dictionary">Dictionary</A>|
			import.Func	entries, |<A HREF="eval.html#List">List</A>| items, imported
					items, etc.
					Does not work for local <A HREF="eval.html#variables">variables</A> in a
					compiled `:def` function.
					Also works for a function in |<A HREF="vim9.html#Vim9">Vim9</A>|
					<A HREF="usr_41.html#script">script</A>, since <A HREF="motion.html#it">it</A> can be used <A HREF="motion.html#as">as</A> a
					function reference.
					Beware that evaluating an index may
					cause an error message for an invalid
					<A HREF="eval.html#expression">expression</A>.  E.g.:
<B>					   :let l = [1, 2, 3]</B>
<B>					   :echo exists("l[5]")</B>
 					   0
<B>					   :echo exists("l[xx]")</B>
 					   <A HREF="eval.html#E121">E121</A>: Undefined variable: xx
					   0
			&amp;option-name	Vim option (only checks if <A HREF="motion.html#it">it</A> exists,
					not if <A HREF="motion.html#it">it</A> really works)
			+option-name	Vim option that works.
			$ENVNAME	environment variable (could also be
					done by comparing with an empty
					<A HREF="eval.html#string">string</A>)
			*funcname	built-in function (see |<A HREF="eval.html#functions">functions</A>|)
					or user defined function (see
					|<A HREF="eval.html#user-functions">user-functions</A>|) that is implemented.
					Also works for a variable that is a
					<A HREF="eval.html#Funcref">Funcref</A>.
			?funcname	built-in function that could be
					implemented; to be used to check if
					&quot;funcname&quot; is valid
			:cmdname	<A HREF="intro.html#Ex">Ex</A> command: built-in command, user
					command or command modifier |<A HREF="map.html#:command">:command</A>|.
					Returns:
					1  for match with start of a command
					2  full match with a command
					3  matches several user commands
					To check for a supported command
					always check the return value to be 2.
			:2match		The |<A HREF="pattern.html#:2match">:2match</A>| command.
			:3match		The |<A HREF="pattern.html#:3match">:3match</A>| command.
			#event		<A HREF="autocmd.html#autocommand">autocommand</A> defined for this event
			#event#pattern	<A HREF="autocmd.html#autocommand">autocommand</A> defined for this event and
					<A HREF="pattern.html#pattern">pattern</A> (the <A HREF="pattern.html#pattern">pattern</A> is taken
					literally and compared to the
					<A HREF="autocmd.html#autocommand">autocommand</A> patterns character by
					character)
			#group		<A HREF="autocmd.html#autocommand">autocommand</A> group exists
			#group#event	<A HREF="autocmd.html#autocommand">autocommand</A> defined for this group and
					event.
			#group#event#pattern
					<A HREF="autocmd.html#autocommand">autocommand</A> defined for this group,
					event and <A HREF="pattern.html#pattern">pattern</A>.
			##event		<A HREF="autocmd.html#autocommand">autocommand</A> for this event is
					supported.

		Examples:
<B>			exists("&amp;shortname")</B>
<B>			exists("$HOSTNAME")</B>
<B>			exists("*strftime")</B>
<B>			exists("*s:MyFunc")	" only for legacy script</B>
<B>			exists("*MyFunc")</B>
<B>			exists("bufcount")</B>
<B>			exists(":Make")</B>
<B>			exists("#CursorHold")</B>
<B>			exists("#BufReadPre#*.gz")</B>
<B>			exists("#filetypeindent")</B>
<B>			exists("#filetypeindent#FileType")</B>
<B>			exists("#filetypeindent#FileType#*")</B>
<B>			exists("##ColorScheme")</B>
 		There must be no space between the symbol (&amp;/$/*/#) and the
		name.
		There must be no extra characters after the name, although in
		a few cases this is ignored.  That may become stricter in the
		future, thus don't <A HREF="intro.html#count">count</A> on <A HREF="motion.html#it">it</A>!
		Working example:
<B>			exists(":make")</B>
 		NOT working example:
<B>			exists(":make install")</B>

 		Note that the argument must be a <A HREF="eval.html#string">string</A>, not the name of the
		variable itself.  For example:
<B>			exists(bufcount)</B>
 		This doesn't check for existence of the &quot;bufcount&quot; variable,
		but gets the value of &quot;bufcount&quot;, and checks if that exists.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Varname()-&gt;exists()</B>
 


exists_compiled({expr})					*<A NAME="exists_compiled()"></A><B>exists_compiled()</B>*
		Like `exists()` but evaluated at compile time.  This is useful
		to skip a block where a function is used that would otherwise
		give an error:
<B>			if exists_compiled('*ThatFunction')</B>
<B>			   ThatFunction('works')</B>
<B>			endif</B>
 		If `exists()` were used then a compilation error would be
		given if ThatFunction() is not defined.


		{expr} must be a literal <A HREF="eval.html#string">string</A>. *<A NAME="E1232"></A><B>E1232</B>*

		Can only be used in a |<A HREF="vim9.html#:def">:def</A>| function. *<A NAME="E1233"></A><B>E1233</B>*
		This does not work to check for arguments or local <A HREF="eval.html#variables">variables</A>.



exp({expr})							*<A NAME="exp()"></A><B>exp()</B>*
		Return the exponential of {expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| in the range
		[0, inf].
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo exp(2)</B>
 			7.389056
<B>			:echo exp(-1)</B>
 			0.367879

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;exp()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



expand({string} [, {nosuf} [, {list}]])				*<A NAME="expand()"></A><B>expand()</B>*
		Expand <A HREF="editing.html#wildcards">wildcards</A> and the following special keywords in
		{string}.  <A HREF="options.html#'wildignorecase'">'wildignorecase'</A> applies.

		If {list} is given and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>|, a <A HREF="eval.html#List">List</A> will be returned.
		Otherwise the result is a <A HREF="eval.html#String">String</A> and when there are several
		matches, they are separated by <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A> characters.  [Note: in
		version 5.0 a space was used, which caused problems when a
		file name contains a space]

		If the expansion fails, the result is an empty <A HREF="eval.html#string">string</A>.  A name
		for a non-existing file is not included, unless {string} does
		not start with '<A HREF="motion.html#&#37;">&#37;</A>', '<A HREF="pattern.html##">#</A>' or '<A HREF="change.html#&lt;">&lt;</A>', see below.

		When {string} starts with '<A HREF="motion.html#&#37;">&#37;</A>', '<A HREF="pattern.html##">#</A>' or '<A HREF="change.html#&lt;">&lt;</A>', the expansion is
		done like for the |<A HREF="cmdline.html#cmdline-special">cmdline-special</A>| <A HREF="eval.html#variables">variables</A> with their
		associated modifiers.  Here is a short overview:

			<A HREF="motion.html#&#37;">&#37;</A>		current file name
			#		alternate file name
			#n		alternate file name <A HREF="pattern.html#n">n</A>
			<A HREF="cmdline.html#&lt;cfile&gt;">&lt;cfile&gt;</A>		file name under the cursor
			<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>		autocmd file name
			<A HREF="cmdline.html#&lt;abuf&gt;">&lt;abuf&gt;</A>		autocmd buffer number (as a String!)
			<A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A>	autocmd matched name
			<A HREF="cmdline.html#&lt;cexpr&gt;">&lt;cexpr&gt;</A>		C <A HREF="eval.html#expression">expression</A> under the cursor
			<A HREF="cmdline.html#&lt;sfile&gt;">&lt;sfile&gt;</A>		sourced <A HREF="usr_41.html#script">script</A> file or function name
			<A HREF="cmdline.html#&lt;slnum&gt;">&lt;slnum&gt;</A>		sourced <A HREF="usr_41.html#script">script</A> line number or function
					line number
			<A HREF="cmdline.html#&lt;sflnum&gt;">&lt;sflnum&gt;</A>	<A HREF="usr_41.html#script">script</A> file line number, also when in
					a function
			<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>		&quot;&lt;SNR&gt;123_&quot;  where &quot;123&quot; is the
					current <A HREF="usr_41.html#script">script</A> ID  |<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>|
			<A HREF="cmdline.html#&lt;script&gt;">&lt;script&gt;</A>	sourced <A HREF="usr_41.html#script">script</A> file, or <A HREF="usr_41.html#script">script</A> file
					where the current function was defined
			<A HREF="cmdline.html#&lt;stack&gt;">&lt;stack&gt;</A>		call stack
			<A HREF="cmdline.html#&lt;cword&gt;">&lt;cword&gt;</A>		<A HREF="motion.html#word">word</A> under the cursor
			<A HREF="cmdline.html#&lt;cWORD&gt;">&lt;cWORD&gt;</A>		<A HREF="motion.html#WORD">WORD</A> under the cursor
			<A HREF="cmdline.html#&lt;client&gt;">&lt;client&gt;</A>	the {clientid} of the last received
					message |<A HREF="#server2client()">server2client()</A>|
		Modifiers:
			<A HREF="various.html#:p">:p</A>		expand to full path
			<A HREF="helphelp.html#:h">:h</A>		head (last path component removed)
			<A HREF="change.html#:t">:t</A>		tail (last path component only)
			<A HREF="insert.html#:r">:r</A>		root (one extension removed)
			<A HREF="editing.html#:e">:e</A>		extension only

		Example:
<B>			:let &amp;tags = expand("%:p:h") .. "/tags"</B>
 		Note that when expanding a <A HREF="eval.html#string">string</A> that starts with '<A HREF="motion.html#&#37;">&#37;</A>', '<A HREF="pattern.html##">#</A>' or
		'<A HREF="change.html#&lt;">&lt;</A>', any following text is ignored.  This does NOT work:
<B>			:let doesntwork = expand("%:h.bak")</B>
 		Use this:
<B>			:let doeswork = expand("%:h") .. ".bak"</B>
 		Also note that expanding &quot;<A HREF="cmdline.html#&lt;cfile&gt;">&lt;cfile&gt;</A>&quot; and others only returns the
		referenced file name without further expansion.  If &quot;<A HREF="cmdline.html#&lt;cfile&gt;">&lt;cfile&gt;</A>&quot;
		is &quot;~/.cshrc&quot;, you need to <A HREF="diff.html#do">do</A> another <A HREF="#expand()">expand()</A> to have the
		&quot;~/&quot; expanded into the path of the home directory:
<B>			:echo expand(expand("&lt;cfile&gt;"))</B>
 
		There cannot be white space between the <A HREF="eval.html#variables">variables</A> and the
		following modifier.  The |<A HREF="#fnamemodify()">fnamemodify()</A>| function can be used
		to modify normal file names.

		When using '<A HREF="motion.html#&#37;">&#37;</A>' or '<A HREF="pattern.html##">#</A>', and the current or alternate file name
		is not defined, an empty <A HREF="eval.html#string">string</A> is used.  Using &quot;<A HREF="cmdline.html#&#37;:p">&#37;:p</A>&quot; in a
		buffer with no name, results in the current directory, with a
		'<A HREF="pattern.html#/">/</A>' added.
		When <A HREF="options.html#'verbose'">'verbose'</A> is set then expanding '<A HREF="motion.html#&#37;">&#37;</A>', '<A HREF="pattern.html##">#</A>' and <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> items
		will result in an error message if the argument cannot be
		expanded.

		When {string} does not start with '<A HREF="motion.html#&#37;">&#37;</A>', '<A HREF="pattern.html##">#</A>' or '<A HREF="change.html#&lt;">&lt;</A>', <A HREF="motion.html#it">it</A> is
		expanded like a file name is expanded on the command line.
		<A HREF="options.html#'suffixes'">'suffixes'</A> and <A HREF="options.html#'wildignore'">'wildignore'</A> are used, unless the optional
		{nosuf} argument is given and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>|.
		Names for non-existing files are included.  The &quot;**&quot; item can
		be used to search in a directory tree.  For example, to find
		all &quot;README&quot; files in the current directory and below:
<B>			:echo expand("**/README")</B>
 
		<A HREF="#expand()">expand()</A> can also be used to expand <A HREF="eval.html#variables">variables</A> and environment
		<A HREF="eval.html#variables">variables</A> that are only known in a shell.  But this can be
		slow, because a shell may be used to <A HREF="diff.html#do">do</A> the expansion.  See
		|<A HREF="eval.html#expr-env-expand">expr-env-expand</A>|.
		The expanded variable is still handled like a <A HREF="eval.html#list">list</A> of file
		names.  When an environment variable cannot be expanded, <A HREF="motion.html#it">it</A> is
		left unchanged.  Thus &quot;<A HREF="eval.html#:echo">:echo</A> expand('$FOOBAR')&quot; results in
		&quot;$FOOBAR&quot;.

		See |<A HREF="#glob()">glob()</A>| for finding existing files.  See |<A HREF="#system()">system()</A>| for
		getting the raw output of an external command.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Getpattern()-&gt;expand()</B>


expandcmd({string} [, {options}])			*<A NAME="expandcmd()"></A><B>expandcmd()</B>*
		Expand special items in <A HREF="eval.html#String">String</A> {string} like what is done for
		an <A HREF="intro.html#Ex">Ex</A> command such <A HREF="motion.html#as">as</A> `:edit`.  This expands special keywords,
		like with |<A HREF="#expand()">expand()</A>|, and environment <A HREF="eval.html#variables">variables</A>, anywhere in
		{string}.  &quot;~user&quot; and &quot;~/path&quot; are only expanded at the
		start.

		The following items are supported in the {options} <A HREF="eval.html#Dict">Dict</A>
		argument:
		    errmsg	If set to <A HREF="eval.html#TRUE">TRUE</A>, error <A HREF="message.html#messages">messages</A> are displayed
				if an error is encountered during expansion.
				By default, error <A HREF="message.html#messages">messages</A> are not displayed.

		Returns the expanded <A HREF="eval.html#string">string</A>.  If an error is encountered
		during expansion, the unmodified {string} is returned.

		Example:
<B>			:echo expandcmd('make %&lt;.o')</B>
<B>			make /path/runtime/doc/builtin.o</B>
<B>			:echo expandcmd('make %&lt;.o', {'errmsg': v:true})</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetCommand()-&gt;expandcmd()</B>
 

extend({expr1}, {expr2} [, {expr3}])			*<A NAME="extend()"></A><B>extend()</B>*
		{expr1} and {expr2} must be both |<A HREF="eval.html#Lists">Lists</A>| or both
		|<A HREF="eval.html#Dictionaries">Dictionaries</A>|.

		If they are |Lists|: Append {expr2} to {expr1}.
		If {expr3} is given insert the items of {expr2} before the
		item with index {expr3} in {expr1}.  When {expr3} is zero
		insert before the first item.  When {expr3} is equal to
		len({expr1}) then {expr2} is appended.
		Examples:
<B>			:echo sort(extend(mylist, [7, 5]))</B>
<B>			:call extend(mylist, [2, 3], 1)</B>
 		When {expr1} is the same <A HREF="eval.html#List">List</A> <A HREF="motion.html#as">as</A> {expr2} then the number of
		items copied is equal to the original length of the <A HREF="eval.html#List">List</A>.
		E.g., when {expr3} is 1 you get N new copies of the first item
		(where N is the original length of the <A HREF="eval.html#List">List</A>).
		Use |<A HREF="#add()">add()</A>| to concatenate one item to a <A HREF="eval.html#list">list</A>.  To concatenate
		two lists into a new <A HREF="eval.html#list">list</A> use the + <A HREF="motion.html#operator">operator</A>:
<B>			:let newlist = [1, 2, 3] + [4, 5]</B>
 
		If they are YXXYDictionaries|:
		Add all entries from {expr2} to {expr1}.
		If a key exists in both {expr1} and {expr2} then {expr3} is
		used to decide what to <A HREF="diff.html#do">do</A>:
		{expr3} = &quot;keep&quot;: keep the value of {expr1}
		{expr3} = &quot;force&quot;: use the value of {expr2}

		{expr3} = &quot;error&quot;: give an error message		*<A NAME="E737"></A><B>E737</B>*
		When {expr3} is omitted then &quot;force&quot; is assumed.

		{expr1} is changed when {expr2} is not empty.  If necessary
		make a copy of {expr1} first.
		{expr2} remains unchanged.
		When {expr1} is locked and {expr2} is not empty the operation
		fails.
		Returns {expr1}.  Returns 0 on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;extend(otherlist)</B>



extendnew({expr1}, {expr2} [, {expr3}])			*<A NAME="extendnew()"></A><B>extendnew()</B>*
		Like |<A HREF="#extend()">extend()</A>| but instead of adding items to {expr1} a new
		<A HREF="eval.html#List">List</A> or <A HREF="eval.html#Dictionary">Dictionary</A> is created and returned.  {expr1} remains
		unchanged.  Items can still be changed by {expr2}, if you
		don't want that use |<A HREF="#deepcopy()">deepcopy()</A>| first.



feedkeys({string} [, {mode}])				*<A NAME="feedkeys()"></A><B>feedkeys()</B>*
		Characters in {string} are queued for processing <A HREF="motion.html#as">as</A> if they
		come from a <A HREF="map.html#mapping">mapping</A> or were typed by the user.

		By default the <A HREF="eval.html#string">string</A> is added to the end of the typeahead
		buffer, thus if a <A HREF="map.html#mapping">mapping</A> is still being executed the
		characters come after them.  Use the '<A HREF="insert.html#i">i</A>' flag to insert before
		other characters, they will be executed next, before any
		characters from a <A HREF="map.html#mapping">mapping</A>.

		The function does not wait for processing of keys contained in
		{string}.

		To include special keys into {string}, use double-quotes
		and &quot;\...&quot; <A HREF="intro.html#notation">notation</A> |<A HREF="eval.html#expr-quote">expr-quote</A>|. For example,
		feedkeys(&quot;\&lt;CR&gt;&quot;) simulates pressing of the <A HREF="intro.html#&lt;Enter&gt;">&lt;Enter&gt;</A> key. But
		feedkeys('\&lt;CR&gt;') pushes 5 characters.
		A special code that might be useful is <A HREF="#&lt;Ignore&gt;">&lt;Ignore&gt;</A>, <A HREF="motion.html#it">it</A> exits the

		wait for a character without doing anything.  *<A NAME="&lt;Ignore&gt;"></A><B>&lt;Ignore&gt;</B>*

		{mode} is a <A HREF="eval.html#String">String</A>, which can contain these character flags:
		'<A HREF="motion.html#m">m</A>'	Remap keys. This is default.  If {mode} is absent,
			keys are remapped.
		'<A HREF="pattern.html#n">n</A>'	Do not remap keys.
		'<A HREF="motion.html#t">t</A>'	Handle keys <A HREF="motion.html#as">as</A> if typed; otherwise they are handled <A HREF="motion.html#as">as</A>
			if coming from a <A HREF="map.html#mapping">mapping</A>.  This matters for <A HREF="undo.html#undo">undo</A>,
			opening <A HREF="fold.html#folds">folds</A>, etc.
		'<A HREF="motion.html#L">L</A>'	Lowlevel input.  Only works for <A HREF="os_unix.html#Unix">Unix</A> or when using the
			<A HREF="gui.html#GUI">GUI</A>. Keys are used <A HREF="motion.html#as">as</A> if they were coming from the

			<A HREF="terminal.html#terminal">terminal</A>.  Other flags are not used.  *<A NAME="E980"></A><B>E980</B>*
			When a <A HREF="pattern.html#CTRL-C">CTRL-C</A> interrupts and '<A HREF="motion.html#t">t</A>' is included <A HREF="motion.html#it">it</A> sets
			the internal &quot;got_int&quot; flag.
		'<A HREF="insert.html#i">i</A>'	<A HREF="insert.html#Insert">Insert</A> the <A HREF="eval.html#string">string</A> instead of appending (see above).
		'<A HREF="change.html#x">x</A>'	Execute commands until typeahead is empty.  This is
			similar to using &quot;:normal!&quot;.  You can call <A HREF="#feedkeys()">feedkeys()</A>
			several times without '<A HREF="change.html#x">x</A>' and then one time with '<A HREF="change.html#x">x</A>'
			(possibly with an empty {string}) to execute all the
			typeahead.  Note that when Vim ends in <A HREF="insert.html#Insert">Insert</A> mode <A HREF="motion.html#it">it</A>
			will behave <A HREF="motion.html#as">as</A> if <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> is typed, to avoid getting
			stuck, waiting for a character to be typed before the
			<A HREF="usr_41.html#script">script</A> continues.
			Note that if you manage to call <A HREF="#feedkeys()">feedkeys()</A> while
			executing commands, thus calling <A HREF="motion.html#it">it</A> recursively, then
			all typeahead will be consumed by the last call.
		'<A HREF="change.html#c">c</A>'	Remove any <A HREF="usr_41.html#script">script</A> context when executing, so that
			legacy <A HREF="usr_41.html#script">script</A> <A HREF="syntax.html#syntax">syntax</A> applies, &quot;<A HREF="eval.html#s:var">s:var</A>&quot; does not work,
			etc.  Note that if the <A HREF="eval.html#string">string</A> being fed sets a <A HREF="usr_41.html#script">script</A>
			context this still applies.
		'<A HREF="change.html#!">!</A>'	When used with '<A HREF="change.html#x">x</A>' will not end <A HREF="insert.html#Insert">Insert</A> mode. Can be
			used in a test when a <A HREF="#timer">timer</A> is set to exit <A HREF="insert.html#Insert">Insert</A> mode
			a little later.  Useful for <A HREF="testing.html#testing">testing</A> <A HREF="autocmd.html#CursorHoldI">CursorHoldI</A>.

		Return value is always 0.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetInput()-&gt;feedkeys()</B>


filereadable({file})					*<A NAME="filereadable()"></A><B>filereadable()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| when a file with the
		name <A HREF="editing.html#{file}">{file}</A> exists, and can be read.  If <A HREF="editing.html#{file}">{file}</A> doesn't exist,
		or is a directory, the result is |<A HREF="eval.html#FALSE">FALSE</A>|.  <A HREF="editing.html#{file}">{file}</A> is any
		<A HREF="eval.html#expression">expression</A>, which is used <A HREF="motion.html#as">as</A> a <A HREF="eval.html#String">String</A>.
		If you don't care about the file being readable you can use
		|<A HREF="#glob()">glob()</A>|.
		<A HREF="editing.html#{file}">{file}</A> is used as-is, you may want to expand <A HREF="editing.html#wildcards">wildcards</A> first:
<B>			echo filereadable('~/.vimrc')</B>
<B>			0</B>
<B>			echo filereadable(expand('~/.vimrc'))</B>
<B>			1</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;filereadable()</B>

 							*<A NAME="file_readable()"></A><B>file_readable()</B>*
		Obsolete name: <A HREF="#file_readable()">file_readable()</A>.



filewritable({file})					*<A NAME="filewritable()"></A><B>filewritable()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is 1 when a file with the
		name <A HREF="editing.html#{file}">{file}</A> exists, and can be written.  If <A HREF="editing.html#{file}">{file}</A> doesn't
		exist, or is not writable, the result is 0.  If <A HREF="editing.html#{file}">{file}</A> is a
		directory, and we can write to <A HREF="motion.html#it">it</A>, the result is 2.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;filewritable()</B>



filter({expr1}, {expr2})				*<A NAME="filter()"></A><B>filter()</B>*
		{expr1} must be a |<A HREF="eval.html#List">List</A>|, |<A HREF="eval.html#String">String</A>|, |<A HREF="eval.html#Blob">Blob</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>|.
		For each item in {expr1} evaluate {expr2} and when the result
		is zero or <A HREF="vim9.html#false">false</A> remove the item from the |<A HREF="eval.html#List">List</A>| or
		|<A HREF="eval.html#Dictionary">Dictionary</A>|.  Similarly for each byte in a |<A HREF="eval.html#Blob">Blob</A>| and each
		character in a |<A HREF="eval.html#String">String</A>|.

		{expr2} must be a |<A HREF="eval.html#string">string</A>| or |<A HREF="eval.html#Funcref">Funcref</A>|.

		If {expr2} is a |<A HREF="eval.html#string">string</A>|, inside {expr2} |<A HREF="eval.html#v:val">v:val</A>| has the value
		of the current item.  For a |<A HREF="eval.html#Dictionary">Dictionary</A>| |<A HREF="eval.html#v:key">v:key</A>| has the key
		of the current item and for a |<A HREF="eval.html#List">List</A>| |<A HREF="eval.html#v:key">v:key</A>| has the index of
		the current item.  For a |<A HREF="eval.html#Blob">Blob</A>| |<A HREF="eval.html#v:key">v:key</A>| has the index of the
		current byte. For a |<A HREF="eval.html#String">String</A>| |<A HREF="eval.html#v:key">v:key</A>| has the index of the
		current character.
		Examples:
<B>			call filter(mylist, 'v:val !~ "OLD"')</B>
 		Removes the items where &quot;OLD&quot; appears.
<B>			call filter(mydict, 'v:key &gt;= 8')</B>
 		Removes the items with a key below 8.
<B>			call filter(var, 0)</B>
 		Removes all the items, thus clears the |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>|.

		Note that {expr2} is the result of <A HREF="eval.html#expression">expression</A> and is then
		used <A HREF="motion.html#as">as</A> an <A HREF="eval.html#expression">expression</A> again.  Often <A HREF="motion.html#it">it</A> is good to use a
		|<A HREF="eval.html#literal-string">literal-string</A>| to avoid having to double backslashes.

		If {expr2} is a |<A HREF="eval.html#Funcref">Funcref</A>| <A HREF="motion.html#it">it</A> must take two arguments:
			1. the key or the index of the current item.
			2. the value of the current item.
		The function must return |<A HREF="eval.html#TRUE">TRUE</A>| if the item should be kept.
		Example that keeps the odd items of a <A HREF="eval.html#list">list</A>:
<B>			func Odd(idx, val)</B>
<B>			  return a:idx % 2 == 1</B>
<B>			endfunc</B>
<B>			call filter(mylist, function('Odd'))</B>
 		It is shorter when using a |<A HREF="eval.html#lambda">lambda</A>|.  In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="syntax.html#syntax">syntax</A>:
<B>			call filter(myList, (idx, val) =&gt; idx * val &lt;= 42)</B>
 		In legacy <A HREF="usr_41.html#script">script</A> <A HREF="syntax.html#syntax">syntax</A>:
<B>			call filter(myList, {idx, val -&gt; idx * val &lt;= 42})</B>
 		If you <A HREF="diff.html#do">do</A> not use &quot;val&quot; you can leave <A HREF="motion.html#it">it</A> out:
<B>			call filter(myList, {idx -&gt; idx % 2 == 1})</B>
 
		In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the result must be <A HREF="vim9.html#true">true</A>, <A HREF="vim9.html#false">false</A>, zero or one.
		Other values will result in a type error.

		For a |<A HREF="eval.html#List">List</A>| and a |<A HREF="eval.html#Dictionary">Dictionary</A>| the operation is done
		in-place.  If you want <A HREF="motion.html#it">it</A> to remain unmodified make a copy
		first:
<B>			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')</B>

 		Returns {expr1}, the |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| that was filtered,
		or a new |<A HREF="eval.html#Blob">Blob</A>| or |<A HREF="eval.html#String">String</A>|.
		When an error is encountered while evaluating {expr2} no
		further items in {expr1} are processed.
		When {expr2} is a <A HREF="eval.html#Funcref">Funcref</A> <A HREF="message.html#errors">errors</A> inside a function are ignored,
		unless <A HREF="motion.html#it">it</A> was defined with the &quot;abort&quot; flag.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;filter(expr2)</B>


finddir({name} [, {path} [, {count}]])				*<A NAME="finddir()"></A><B>finddir()</B>*
		Find directory {name} in {path}.  Supports both downwards and
		upwards recursive directory searches.  See |<A HREF="editing.html#file-searching">file-searching</A>|
		for the <A HREF="syntax.html#syntax">syntax</A> of {path}.

		Returns the path of the first found match.  When the found
		directory is below the current directory a relative path is
		returned.  Otherwise a full path is returned.
		If {path} is omitted or empty then <A HREF="options.html#'path'">'path'</A> is used.

		If the optional {count} is given, find {count}'s occurrence of
		{name} in {path} instead of the first one.
		When {count} is negative return all the matches in a |<A HREF="eval.html#List">List</A>|.

		Returns an empty <A HREF="eval.html#string">string</A> if the directory is not found.

		This is quite similar to the ex-command `:find`.
		{only available when compiled with the |<A HREF="various.html#+file_in_path">+file_in_path</A>|
		feature}

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;finddir()</B>


findfile({name} [, {path} [, {count}]])				*<A NAME="findfile()"></A><B>findfile()</B>*
		Just like |<A HREF="#finddir()">finddir()</A>|, but find a file instead of a directory.
		Uses <A HREF="options.html#'suffixesadd'">'suffixesadd'</A>.
		Example:
<B>			:echo findfile("tags.vim", ".;")</B>
 		Searches from the directory of the current file upwards until
		<A HREF="motion.html#it">it</A> finds the file &quot;tags.vim&quot;.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;findfile()</B>


flatten({list} [, {maxdepth}])					*<A NAME="flatten()"></A><B>flatten()</B>*
		Flatten {list} up to {maxdepth} levels.  Without {maxdepth}
		the result is a |<A HREF="eval.html#List">List</A>| without nesting, <A HREF="motion.html#as">as</A> if {maxdepth} is
		a very large number.
		The {list} is changed in place, use |<A HREF="#flattennew()">flattennew()</A>| if you <A HREF="diff.html#do">do</A>
		not want that.
		In <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> <A HREF="#flatten()">flatten()</A> cannot be used, you must always use
		|<A HREF="#flattennew()">flattennew()</A>|.

								*<A NAME="E900"></A><B>E900</B>*
		{maxdepth} means how deep in nested lists changes are made.
		{list} is not modified when {maxdepth} is 0.
		{maxdepth} must be positive number.

		If there is an error the number zero is returned.

		Example:
<B>			:echo flatten([1, [2, [3, 4]], 5])</B>
 			[1, 2, 3, 4, 5]
<B>			:echo flatten([1, [2, [3, 4]], 5], 1)</B>
 			[1, 2, [3, 4], 5]

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;flatten()</B>
 

flattennew({list} [, {maxdepth}])			*<A NAME="flattennew()"></A><B>flattennew()</B>*
		Like |<A HREF="#flatten()">flatten()</A>| but first make a copy of {list}.



float2nr({expr})					*<A NAME="float2nr()"></A><B>float2nr()</B>*
		Convert {expr} to a <A HREF="eval.html#Number">Number</A> by omitting the part after the
		decimal point.
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a <A HREF="eval.html#Number">Number</A>.
		Returns 0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		When the value of {expr} is out of range for a |<A HREF="eval.html#Number">Number</A>| the
		result is truncated to 0x7fffffff or -0x7fffffff (or when
		64-bit <A HREF="eval.html#Number">Number</A> support is enabled, 0x7fffffffffffffff or
		-0x7fffffffffffffff).  NaN results in -0x80000000 (or when
		64-bit <A HREF="eval.html#Number">Number</A> support is enabled, -0x8000000000000000).
		Examples:
<B>			echo float2nr(3.95)</B>
 			3 
<B>			echo float2nr(-23.45)</B>
 			-23 
<B>			echo float2nr(1.0e100)</B>
 			2147483647  (or 9223372036854775807)
<B>			echo float2nr(-1.0e150)</B>
 			-2147483647 (or -9223372036854775807)
<B>			echo float2nr(1.0e-100)</B>
 			0

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;float2nr()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



floor({expr})							*<A NAME="floor()"></A><B>floor()</B>*
		Return the largest integral value <A HREF="various.html#less">less</A> than or equal to
		{expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| (round down).
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			echo floor(1.856)</B>
 			1.0 
<B>			echo floor(-5.456)</B>
 			-6.0 
<B>			echo floor(4.0)</B>
 			4.0

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;floor()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



fmod({expr1}, {expr2})					*<A NAME="fmod()"></A><B>fmod()</B>*
		Return the remainder of {expr1} / {expr2}, even if the
		division is not representable.  Returns {expr1} - <A HREF="insert.html#i">i</A> &#42; {expr2}
		for some integer <A HREF="insert.html#i">i</A> such that if {expr2} is non-zero, the
		result has the same sign <A HREF="motion.html#as">as</A> {expr1} and magnitude <A HREF="various.html#less">less</A> than
		the magnitude of {expr2}.  If {expr2} is zero, the value
		returned is zero.  The value returned is a |<A HREF="eval.html#Float">Float</A>|.
		{expr1} and {expr2} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr1} or {expr2} is not a |<A HREF="eval.html#Float">Float</A>| or a
		|<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo fmod(12.33, 1.22)</B>
 			0.13
<B>			:echo fmod(-12.33, 1.22)</B>
 			-0.13

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;fmod(1.22)</B>
 
		{only available when compiled with |<A HREF="various.html#+float">+float</A>| feature}



fnameescape({string})					*<A NAME="fnameescape()"></A><B>fnameescape()</B>*
		Escape {string} for use <A HREF="motion.html#as">as</A> file name command argument.  All
		characters that have a special meaning, such <A HREF="motion.html#as">as</A> '<A HREF="motion.html#&#37;">&#37;</A>' and '&#124;'
		are escaped with a <A HREF="intro.html#backslash">backslash</A>.
		For most systems the characters escaped are
		&quot; \t\n*?[{`$\\&#37;#'\&quot;|!&lt;&quot;.  For systems where a <A HREF="intro.html#backslash">backslash</A>
		appears in a filename, <A HREF="motion.html#it">it</A> depends on the value of <A HREF="options.html#'isfname'">'isfname'</A>.
		A leading '<A HREF="motion.html#+">+</A>' and '<A HREF="change.html#&gt;">&gt;</A>' is also escaped (special after |<A HREF="editing.html#:edit">:edit</A>|
		and |<A HREF="editing.html#:write">:write</A>|).  And a &quot;<A HREF="motion.html#-">-</A>&quot; by itself (special after |<A HREF="editing.html#:cd">:cd</A>|).
		Returns an empty <A HREF="eval.html#string">string</A> on error.
		Example:
<B>			:let fname = '+some str%nge|name'</B>
<B>			:exe "edit " .. fnameescape(fname)</B>
 		results in executing:
<B>			edit \+some\ str\%nge\|name</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;fnameescape()</B>


fnamemodify({fname}, {mods})				*<A NAME="fnamemodify()"></A><B>fnamemodify()</B>*
		Modify file name {fname} according to {mods}.  {mods} is a
		<A HREF="eval.html#string">string</A> of characters like <A HREF="motion.html#it">it</A> is used for file names on the
		command line.  See |<A HREF="cmdline.html#filename-modifiers">filename-modifiers</A>|.
		Example:
<B>			:echo fnamemodify("main.c", ":p:h")</B>
 		results in:
<B>			/home/user/vim/vim/src</B>
 		If {mods} is empty or an unsupported modifier is used then
		{fname} is returned.
		Note: Environment <A HREF="eval.html#variables">variables</A> don't work in {fname}, use
		|<A HREF="#expand()">expand()</A>| first then.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;fnamemodify(':p:h')</B>


foldclosed({lnum})					*<A NAME="foldclosed()"></A><B>foldclosed()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>.  If the line {lnum} is in a closed
		fold, the result is the number of the first line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.  Thus &quot;<A HREF="repeat.html#.">.</A>&quot; is the current
		line, &quot;'m&quot; <A HREF="motion.html#mark">mark</A> <A HREF="motion.html#m">m</A>, etc.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;foldclosed()</B>


foldclosedend({lnum})					*<A NAME="foldclosedend()"></A><B>foldclosedend()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>.  If the line {lnum} is in a closed
		fold, the result is the number of the last line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.  Thus &quot;<A HREF="repeat.html#.">.</A>&quot; is the current
		line, &quot;'m&quot; <A HREF="motion.html#mark">mark</A> <A HREF="motion.html#m">m</A>, etc.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;foldclosedend()</B>


foldlevel({lnum})					*<A NAME="foldlevel()"></A><B>foldlevel()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the foldlevel of line {lnum}
		in the current buffer.  For nested <A HREF="fold.html#folds">folds</A> the deepest level is
		returned.  If there is no fold at line {lnum}, zero is
		returned.  It doesn't matter if the <A HREF="fold.html#folds">folds</A> are open or closed.
		When used while updating <A HREF="fold.html#folds">folds</A> (from <A HREF="options.html#'foldexpr'">'foldexpr'</A>) -1 is
		returned for lines where <A HREF="fold.html#folds">folds</A> are still to be updated and the
		foldlevel is unknown.  As a special <A HREF="change.html#case">case</A> the level of the
		previous line is usually available.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.  Thus &quot;<A HREF="repeat.html#.">.</A>&quot; is the current
		line, &quot;'m&quot; <A HREF="motion.html#mark">mark</A> <A HREF="motion.html#m">m</A>, etc.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;foldlevel()</B>
 

							*<A NAME="foldtext()"></A><B>foldtext()</B>*
<A HREF="#foldtext()">foldtext()</A>	Returns a <A HREF="eval.html#String">String</A>, to be displayed for a closed fold.  This is
		the default function used for the <A HREF="options.html#'foldtext'">'foldtext'</A> option and should
		only be called from evaluating <A HREF="options.html#'foldtext'">'foldtext'</A>.  It uses the
		|<A HREF="eval.html#v:foldstart">v:foldstart</A>|, |<A HREF="eval.html#v:foldend">v:foldend</A>| and |<A HREF="eval.html#v:folddashes">v:folddashes</A>| <A HREF="eval.html#variables">variables</A>.
		The returned <A HREF="eval.html#string">string</A> looks like this:
<B>			+-- 45 lines: abcdef</B>
 		The number of leading dashes depends on the foldlevel.  The
		&quot;45&quot; is the number of lines in the fold.  &quot;abcdef&quot; is the text
		in the first non-blank line of the fold.  Leading white space,
		&quot;<A HREF="version7.html#//">//</A>&quot; or &quot;/*&quot; and the text from the <A HREF="options.html#'foldmarker'">'foldmarker'</A> and
		<A HREF="options.html#'commentstring'">'commentstring'</A> <A HREF="options.html#options">options</A> is removed.
		When used to draw the actual foldtext, the rest of the line
		will be filled with the fold char from the <A HREF="options.html#'fillchars'">'fillchars'</A>
		setting.
		Returns an empty <A HREF="eval.html#string">string</A> when there is no fold.
		{not available when compiled without the |<A HREF="various.html#+folding">+folding</A>| feature}


foldtextresult({lnum})					*<A NAME="foldtextresult()"></A><B>foldtextresult()</B>*
		Returns the text that is displayed for the closed fold at line
		{lnum}.  Evaluates <A HREF="options.html#'foldtext'">'foldtext'</A> in the appropriate context.
		When there is no closed fold at {lnum} an empty <A HREF="eval.html#string">string</A> is
		returned.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.  Thus &quot;<A HREF="repeat.html#.">.</A>&quot; is the current
		line, &quot;'m&quot; <A HREF="motion.html#mark">mark</A> <A HREF="motion.html#m">m</A>, etc.
		Useful when exporting folded text, e.g., to HTML.
		{not available when compiled without the |<A HREF="various.html#+folding">+folding</A>| feature}


		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;foldtextresult()</B>
 

							*<A NAME="foreground()"></A><B>foreground()</B>*
<A HREF="#foreground()">foreground()</A>	Move the Vim <A HREF="windows.html#window">window</A> to the foreground.  Useful when sent from
		a client to a Vim server. |<A HREF="#remote_send()">remote_send()</A>|
		On <A HREF="os_win32.html#Win32">Win32</A> systems this might not work, the OS does not always
		allow a <A HREF="windows.html#window">window</A> to bring itself to the foreground.  Use
		|<A HREF="#remote_foreground()">remote_foreground()</A>| instead.
		{only in the <A HREF="os_win32.html#Win32">Win32</A>, <A HREF="gui_x11.html#Motif">Motif</A> and <A HREF="gui_x11.html#GTK">GTK</A> <A HREF="gui.html#GUI">GUI</A> versions and the
		<A HREF="os_win32.html#Win32">Win32</A> console version}


fullcommand({name})						*<A NAME="fullcommand()"></A><B>fullcommand()</B>*
		Get the full command name from a short abbreviated command
		name; see |<A HREF="usr_20.html#20.2">20.2</A>| for details on command <A HREF="map.html#abbreviations">abbreviations</A>.

		The <A HREF="eval.html#string">string</A> argument {name} may start with a `:` and can
		include a <A HREF="cmdline.html#[range]">[range]</A>, these are skipped and not returned.
		Returns an empty <A HREF="eval.html#string">string</A> if a command doesn't exist or if it's
		ambiguous (for user-defined commands).

		For example `fullcommand('s')`, `fullcommand('sub')`,
		`fullcommand(':&#37;substitute')` all return &quot;substitute&quot;.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;fullcommand()</B>
 

						*<A NAME="funcref()"></A><B>funcref()</B>*
funcref({name} [, {arglist}] [, {dict}])
		Just like |<A HREF="#function()">function()</A>|, but the returned <A HREF="eval.html#Funcref">Funcref</A> will lookup
		the function by reference, not by name.  This matters when the
		function {name} is redefined later.

		Unlike |<A HREF="#function()">function()</A>|, {name} must be an existing user function.
		It only works for an autoloaded function if <A HREF="motion.html#it">it</A> has already
		been loaded (to avoid mistakenly loading the <A HREF="eval.html#autoload">autoload</A> <A HREF="usr_41.html#script">script</A>
		when only intending to use the function name, use |<A HREF="#function()">function()</A>|
		instead). {name} cannot be a builtin function.
		Returns 0 on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFuncname()-&gt;funcref([arg])</B>
 

				*<A NAME="function()"></A><B>function()</B>* *<A NAME="partial"></A><B>partial</B>* *<A NAME="E700"></A><B>E700</B>* *<A NAME="E922"></A><B>E922</B>* *<A NAME="E923"></A><B>E923</B>*
function({name} [, {arglist}] [, {dict}])
		Return a |<A HREF="eval.html#Funcref">Funcref</A>| variable that refers to function {name}.
		{name} can be the name of a user defined function or an
		internal function.

		{name} can also be a <A HREF="eval.html#Funcref">Funcref</A> or a <A HREF="#partial">partial</A>.  When <A HREF="motion.html#it">it</A> is a
		<A HREF="#partial">partial</A> the <A HREF="eval.html#dict">dict</A> stored in <A HREF="motion.html#it">it</A> will be used and the {dict}
		argument is not allowed. E.g.:
<B>			let FuncWithArg = function(dict.Func, [arg])</B>
<B>			let Broken = function(dict.Func, [arg], dict)</B>
 
		When using the <A HREF="eval.html#Funcref">Funcref</A> the function will be found by {name},
		also when <A HREF="motion.html#it">it</A> was redefined later.  Use |<A HREF="#funcref()">funcref()</A>| to keep the
		same function.

		When <A HREF="editing.html#{arglist}">{arglist}</A> or {dict} is present this creates a <A HREF="#partial">partial</A>.
		That means the argument <A HREF="eval.html#list">list</A> and/or the dictionary is stored in
		the <A HREF="eval.html#Funcref">Funcref</A> and will be used when the <A HREF="eval.html#Funcref">Funcref</A> is called.

		The arguments are passed to the function in front of other
		arguments, but after any argument from |<A HREF="eval.html#method">method</A>|.  Example:
<B>			func Callback(arg1, arg2, name)</B>
<B>			...</B>
<B>			let Partial = function('Callback', ['one', 'two'])</B>
<B>			...</B>
<B>			call Partial('name')</B>
 		Invokes the function <A HREF="motion.html#as">as</A> with:
<B>			call Callback('one', 'two', 'name')</B>

 		With a YXXYmethod|:
<B>			func Callback(one, two, three)</B>
<B>			...</B>
<B>			let Partial = function('Callback', ['two'])</B>
<B>			...</B>
<B>			eval 'one'-&gt;Partial('three')</B>
 		Invokes the function <A HREF="motion.html#as">as</A> with:
<B>			call Callback('one', 'two', 'three')</B>

 		The <A HREF="#function()">function()</A> call can be nested to add more arguments to the
		<A HREF="eval.html#Funcref">Funcref</A>.  The extra arguments are appended to the <A HREF="eval.html#list">list</A> of
		arguments.  Example:
<B>			func Callback(arg1, arg2, name)</B>
<B>			...</B>
<B>			let Func = function('Callback', ['one'])</B>
<B>			let Func2 = function(Func, ['two'])</B>
<B>			...</B>
<B>			call Func2('name')</B>
 		Invokes the function <A HREF="motion.html#as">as</A> with:
<B>			call Callback('one', 'two', 'name')</B>

 		The <A HREF="eval.html#Dictionary">Dictionary</A> is only useful when calling a &quot;<A HREF="eval.html#dict">dict</A>&quot; function.
		In that <A HREF="change.html#case">case</A> the {dict} is passed in <A HREF="motion.html#as">as</A> &quot;<A HREF="eval.html#self">self</A>&quot;. Example:
<B>			function Callback() dict</B>
<B>			   echo "called for " .. self.name</B>
<B>			endfunction</B>
<B>			...</B>
<B>			let context = {"name": "example"}</B>
<B>			let Func = function('Callback', context)</B>
<B>			...</B>
<B>			call Func()	" will echo: called for example</B>
 		The use of <A HREF="#function()">function()</A> is not needed when there are no extra
		arguments, these two are equivalent:
<B>			let Func = function('Callback', context)</B>
<B>			let Func = context.Callback</B>

 		The argument <A HREF="eval.html#list">list</A> and the <A HREF="eval.html#Dictionary">Dictionary</A> can be combined:
<B>			function Callback(arg1, count) dict</B>
<B>			...</B>
<B>			let context = {"name": "example"}</B>
<B>			let Func = function('Callback', ['one'], context)</B>
<B>			...</B>
<B>			call Func(500)</B>
 		Invokes the function <A HREF="motion.html#as">as</A> with:
<B>			call context.Callback('one', 500)</B>
 
		Returns 0 on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFuncname()-&gt;function([arg])</B>



garbagecollect([{atexit}])				*<A NAME="garbagecollect()"></A><B>garbagecollect()</B>*
		Cleanup unused |<A HREF="eval.html#Lists">Lists</A>|, |<A HREF="eval.html#Dictionaries">Dictionaries</A>|, |<A HREF="eval.html#Channels">Channels</A>| and |<A HREF="eval.html#Jobs">Jobs</A>|
		that have circular references.

		There is hardly ever a need to invoke this function, <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> is
		automatically done when Vim runs out of memory or is waiting
		for the user to press a key after <A HREF="options.html#'updatetime'">'updatetime'</A>.  Items without
		circular references are always freed when they become unused.
		This is useful if you have deleted a very big |<A HREF="eval.html#List">List</A>| and/or
		|<A HREF="eval.html#Dictionary">Dictionary</A>| with circular references in a <A HREF="usr_41.html#script">script</A> that runs
		for a long time.

		When the optional {atexit} argument is one, garbage
		collection will also be done when <A HREF="starting.html#exiting">exiting</A> Vim, if <A HREF="motion.html#it">it</A> wasn't
		done before.  This is useful when checking for memory leaks.

		The garbage collection is not done immediately but only when
		it's safe to perform.  This is when waiting for the user to
		type a character.  To force garbage collection immediately use
		|<A HREF="testing.html#test_garbagecollect_now()">test_garbagecollect_now()</A>|.


get({list}, {idx} [, {default}])			*<A NAME="get()"></A><B>get()</B>*
		Get item {idx} from |<A HREF="eval.html#List">List</A>| {list}.  When this item is not
		available return {default}.  Return zero when {default} is
		omitted.
		Preferably used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;get(idx)</B>
get({blob}, {idx} [, {default}])
		Get byte {idx} from |<A HREF="eval.html#Blob">Blob</A>| {blob}.  When this byte is not
		available return {default}.  Return -1 when {default} is
		omitted.
		Preferably used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			myblob-&gt;get(idx)</B>
get({dict}, {key} [, {default}])
		Get item with key {key} from |<A HREF="eval.html#Dictionary">Dictionary</A>| {dict}.  When this
		item is not available return {default}.  Return zero when
		{default} is omitted.  Useful example:
<B>			let val = get(g:, 'var_name', 'default')</B>
 		This gets the value of g:var_name if <A HREF="motion.html#it">it</A> exists, and uses
		'default' when <A HREF="motion.html#it">it</A> does not exist.
		Preferably used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mydict-&gt;get(key)</B>
get({func}, {what})
		Get item {what} from <A HREF="eval.html#Funcref">Funcref</A> {func}.  Possible values for
		{what} are:
			&quot;name&quot;	The function name
			&quot;func&quot;	The function
			&quot;<A HREF="eval.html#dict">dict</A>&quot;	The dictionary
			&quot;args&quot;	The <A HREF="eval.html#list">list</A> with arguments
		Returns zero on error.
		Preferably used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			myfunc-&gt;get(what)</B>
 

							*<A NAME="getbufinfo()"></A><B>getbufinfo()</B>*
getbufinfo([{buf}])
getbufinfo([{dict}])
		Get information about <A HREF="windows.html#buffers">buffers</A> <A HREF="motion.html#as">as</A> a <A HREF="eval.html#List">List</A> of <A HREF="eval.html#Dictionaries">Dictionaries</A>.

		Without an argument information about all the <A HREF="windows.html#buffers">buffers</A> is
		returned.

		When the argument is a |<A HREF="eval.html#Dictionary">Dictionary</A>| only the <A HREF="windows.html#buffers">buffers</A> matching
		the specified criteria are returned.  The following keys can
		be specified in {dict}:
			buflisted	include only listed <A HREF="windows.html#buffers">buffers</A>.
			bufloaded	include only loaded <A HREF="windows.html#buffers">buffers</A>.
			bufmodified	include only modified <A HREF="windows.html#buffers">buffers</A>.

		Otherwise, {buf} specifies a particular buffer to return
		information for.  For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>|
		above.  If the buffer is found the returned <A HREF="eval.html#List">List</A> has one item.
		Otherwise the result is an empty <A HREF="eval.html#list">list</A>.

		Each returned <A HREF="eval.html#List">List</A> item is a dictionary with the following
		entries:
			bufnr		Buffer number.
			changed		<A HREF="eval.html#TRUE">TRUE</A> if the buffer is modified.
			changedtick	<A HREF="eval.html#Number">Number</A> of changes made to the buffer.
			hidden		<A HREF="eval.html#TRUE">TRUE</A> if the buffer is hidden.
			lastused	Timestamp in seconds, like
					|<A HREF="#localtime()">localtime()</A>|, when the buffer was
					last used.
					{only with the |<A HREF="various.html#+viminfo">+viminfo</A>| feature}
			listed		<A HREF="eval.html#TRUE">TRUE</A> if the buffer is listed.
			lnum		Line number used for the buffer when
					opened in the current <A HREF="windows.html#window">window</A>.
					Only valid if the buffer has been
					displayed in the <A HREF="windows.html#window">window</A> in the past.
					If you want the line number of the
					last known cursor position in a given
					<A HREF="windows.html#window">window</A>, use YXXYline()|:
<B>						:echo line('.', {winid})</B>
 
			linecount	<A HREF="eval.html#Number">Number</A> of lines in the buffer (only
					valid when loaded)
			loaded		<A HREF="eval.html#TRUE">TRUE</A> if the buffer is loaded.
			name		Full path to the file in the buffer.
			<A HREF="sign.html#signs">signs</A>		<A HREF="eval.html#List">List</A> of <A HREF="sign.html#signs">signs</A> placed in the buffer.
					Each <A HREF="eval.html#list">list</A> item is a dictionary with
					the following fields:
					    id	  sign identifier
					    lnum  line number
					    name  sign name
			<A HREF="eval.html#variables">variables</A>	A reference to the dictionary with
					buffer-local <A HREF="eval.html#variables">variables</A>.
			<A HREF="windows.html#windows">windows</A>		<A HREF="eval.html#List">List</A> of |<A HREF="windows.html#window-ID">window-ID</A>|<A HREF="change.html#s">s</A> that display this
					buffer
			popups		<A HREF="eval.html#List">List</A> of <A HREF="popup.html#popup">popup</A> |<A HREF="windows.html#window-ID">window-ID</A>|<A HREF="change.html#s">s</A> that
					display this buffer

		Examples:
<B>			for buf in getbufinfo()</B>
<B>			    echo buf.name</B>
<B>			endfor</B>
<B>			for buf in getbufinfo({'buflisted':1})</B>
<B>			    if buf.changed</B>
<B>				....</B>
<B>			    endif</B>
<B>			endfor</B>
 
		To get buffer-local <A HREF="options.html#options">options</A> use:
<B>			getbufvar({bufnr}, '&amp;option_name')</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBufnr()-&gt;getbufinfo()</B>
 


							*<A NAME="getbufline()"></A><B>getbufline()</B>*
getbufline({buf}, {lnum} [, {end}])
		Return a |<A HREF="eval.html#List">List</A>| with the lines starting from {lnum} to {end}
		(inclusive) in the buffer {buf}.  If {end} is omitted, a
		|<A HREF="eval.html#List">List</A>| with only the line {lnum} is returned.

		For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>| above.

		For {lnum} and {end} &quot;<A HREF="motion.html#$">$</A>&quot; can be used for the last line of the
		buffer.  Otherwise a number must be used.

		When {lnum} is smaller than 1 or bigger than the number of
		lines in the buffer, an empty |<A HREF="eval.html#List">List</A>| is returned.

		When {end} is greater than the number of lines in the buffer,
		<A HREF="motion.html#it">it</A> is treated <A HREF="motion.html#as">as</A> {end} is set to the number of lines in the
		buffer.  When {end} is before {lnum} an empty |<A HREF="eval.html#List">List</A>| is
		returned.

		This function works only for loaded <A HREF="windows.html#buffers">buffers</A>.  For unloaded and
		non-existing <A HREF="windows.html#buffers">buffers</A>, an empty |<A HREF="eval.html#List">List</A>| is returned.

		Example:
<B>			:let lines = getbufline(bufnr("myfile"), 1, "$")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBufnr()-&gt;getbufline(lnum)</B>


getbufvar({buf}, {varname} [, {def}])				*<A NAME="getbufvar()"></A><B>getbufvar()</B>*
		The result is the value of option or local buffer variable
		{varname} in buffer {buf}.  Note that the name without &quot;<A HREF="eval.html#b:">b:</A>&quot;
		must be used.
		The {varname} argument is a <A HREF="eval.html#string">string</A>.
		When {varname} is empty returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| with all the
		buffer-local <A HREF="eval.html#variables">variables</A>.
		When {varname} is equal to &quot;<A HREF="change.html#&amp;">&amp;</A>&quot; returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| with all
		the buffer-local <A HREF="options.html#options">options</A>.
		Otherwise, when {varname} starts with &quot;<A HREF="change.html#&amp;">&amp;</A>&quot; returns the value of
		a buffer-local option.
		This also works for a global or buffer-local option, but <A HREF="motion.html#it">it</A>
		doesn't work for a global variable, window-local variable or
		window-local option.
		For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>| above.
		When the buffer or variable doesn't exist {def} or an empty
		<A HREF="eval.html#string">string</A> is returned, there is no error message.
		Examples:
<B>			:let bufmodified = getbufvar(1, "&amp;mod")</B>
<B>			:echo "todo myvar = " .. getbufvar("todo", "myvar")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBufnr()-&gt;getbufvar(varname)</B>
 

getchangelist([{buf}])					*<A NAME="getchangelist()"></A><B>getchangelist()</B>*
		Returns the |<A HREF="motion.html#changelist">changelist</A>| for the buffer {buf}. For the use
		of {buf}, see |<A HREF="#bufname()">bufname()</A>| above. If buffer {buf} doesn't
		exist, an empty <A HREF="eval.html#list">list</A> is returned.

		The returned <A HREF="eval.html#list">list</A> contains two entries: a <A HREF="eval.html#list">list</A> with the change
		locations and the current position in the <A HREF="eval.html#list">list</A>.  Each
		entry in the change <A HREF="eval.html#list">list</A> is a dictionary with the following
		entries:
			col		column number
			coladd		column offset for <A HREF="options.html#'virtualedit'">'virtualedit'</A>
			lnum		line number
		If buffer {buf} is the current buffer, then the current
		position refers to the position in the <A HREF="eval.html#list">list</A>. For other
		<A HREF="windows.html#buffers">buffers</A>, <A HREF="motion.html#it">it</A> is set to the length of the <A HREF="eval.html#list">list</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBufnr()-&gt;getchangelist()</B>


getchar([expr])						*<A NAME="getchar()"></A><B>getchar()</B>*
		Get a single character from the user or input stream.
		If [expr] is omitted, wait until a character is available.
		If [expr] is 0, only get a character when one is available.
			Return zero otherwise.
		If [expr] is 1, only check if a character is available, <A HREF="motion.html#it">it</A> is
			not consumed.  Return zero if no character available.
		If you prefer always getting a <A HREF="eval.html#string">string</A> use |<A HREF="#getcharstr()">getcharstr()</A>|.

		Without [expr] and when [expr] is 0 a whole character or
		special key is returned.  If <A HREF="motion.html#it">it</A> is a single character, the
		result is a <A HREF="eval.html#Number">Number</A>.  Use |<A HREF="#nr2char()">nr2char()</A>| to convert <A HREF="motion.html#it">it</A> to a <A HREF="eval.html#String">String</A>.
		Otherwise a <A HREF="eval.html#String">String</A> is returned with the encoded character.
		For a special key it's a <A HREF="eval.html#String">String</A> with a sequence of bytes
		starting with 0x80 (decimal: 128).  This is the same value <A HREF="motion.html#as">as</A>
		the <A HREF="eval.html#String">String</A> &quot;\&lt;Key&gt;&quot;, e.g., &quot;\&lt;Left&gt;&quot;.  The returned value is
		also a <A HREF="eval.html#String">String</A> when a modifier (shift, <A HREF="intro.html#control">control</A>, <A HREF="intro.html#alt">alt</A>) was used
		that is not included in the character.

		When [expr] is 0 and Esc is typed, there will be a short delay
		while Vim waits to see if this is the start of an <A HREF="intro.html#escape">escape</A>
		sequence.

		When [expr] is 1 only the first byte is returned.  For a
		one-byte character <A HREF="motion.html#it">it</A> is the character itself <A HREF="motion.html#as">as</A> a number.
		Use <A HREF="#nr2char()">nr2char()</A> to convert <A HREF="motion.html#it">it</A> to a <A HREF="eval.html#String">String</A>.

		Use <A HREF="#getcharmod()">getcharmod()</A> to obtain any additional modifiers.

		When the user clicks a mouse button, the mouse event will be
		returned.  The position can then be found in |<A HREF="eval.html#v:mouse_col">v:mouse_col</A>|,
		|<A HREF="eval.html#v:mouse_lnum">v:mouse_lnum</A>|, |<A HREF="eval.html#v:mouse_winid">v:mouse_winid</A>| and |<A HREF="eval.html#v:mouse_win">v:mouse_win</A>|.
		|<A HREF="#getmousepos()">getmousepos()</A>| can also be used.  Mouse move events will be
		ignored.
		This example positions the mouse <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> would normally happen:
<B>			let c = getchar()</B>
<B>			if c == "\&lt;LeftMouse&gt;" &amp;&amp; v:mouse_win &gt; 0</B>
<B>			  exe v:mouse_win .. "wincmd w"</B>
<B>			  exe v:mouse_lnum</B>
<B>			  exe "normal " .. v:mouse_col .. "|"</B>
<B>			endif</B>
 
		When using bracketed paste only the first character is
		returned, the rest of the pasted text is dropped.
		|<A HREF="term.html#xterm-bracketed-paste">xterm-bracketed-paste</A>|.

		There is no prompt, you will somehow have to make clear to the
		user that a character has to be typed.  The screen is not
		redrawn, e.g. when resizing the <A HREF="windows.html#window">window</A>.  When using a <A HREF="popup.html#popup">popup</A>
		<A HREF="windows.html#window">window</A> <A HREF="motion.html#it">it</A> should work better with a |<A HREF="popup.html#popup-filter">popup-filter</A>|.

		There is no <A HREF="map.html#mapping">mapping</A> for the character.
		Key codes are replaced, thus when the user presses the <A HREF="change.html#&lt;Del&gt;">&lt;Del&gt;</A>
		key you get the code for the <A HREF="change.html#&lt;Del&gt;">&lt;Del&gt;</A> key, not the raw character
		sequence.  Examples:
<B>			getchar() == "\&lt;Del&gt;"</B>
<B>			getchar() == "\&lt;S-Left&gt;"</B>
 		This example redefines &quot;<A HREF="motion.html#f">f</A>&quot; to ignore <A HREF="change.html#case">case</A>:
<B>			:nmap f :call FindChar()&lt;CR&gt;</B>
<B>			:function FindChar()</B>
<B>			:  let c = nr2char(getchar())</B>
<B>			:  while col('.') &lt; col('$') - 1</B>
<B>			:    normal l</B>
<B>			:    if getline('.')[col('.') - 1] ==? c</B>
<B>			:      break</B>
<B>			:    endif</B>
<B>			:  endwhile</B>
<B>			:endfunction</B>
 
		You may also receive synthetic characters, such <A HREF="motion.html#as">as</A>
		|<A HREF="autocmd.html#&lt;CursorHold&gt;">&lt;CursorHold&gt;</A>|. Often you will want to ignore this and get
		another character:
<B>			:function GetKey()</B>
<B>			:  let c = getchar()</B>
<B>			:  while c == "\&lt;CursorHold&gt;"</B>
<B>			:    let c = getchar()</B>
<B>			:  endwhile</B>
<B>			:  return c</B>
<B>			:endfunction</B>


<A HREF="#getcharmod()">getcharmod()</A>						*<A NAME="getcharmod()"></A><B>getcharmod()</B>*
		The result is a <A HREF="eval.html#Number">Number</A> which is the state of the modifiers for
		the last obtained character with <A HREF="#getchar()">getchar()</A> or in another way.
		These values are added together:
			2	<A HREF="intro.html#shift">shift</A>
			4	<A HREF="intro.html#control">control</A>
			8	<A HREF="intro.html#alt">alt</A> (meta)
			16	<A HREF="intro.html#meta">meta</A> (when it's different from ALT)
			32	mouse double click
			64	mouse triple click
			96	mouse quadruple click (== 32 + 64)
			128	command (Macintosh only)
		Only the modifiers that have not been included in the
		character itself are obtained.  Thus Shift-a results in &quot;<A HREF="insert.html#A">A</A>&quot;
		without a modifier.  Returns 0 if no modifiers are used.


							*<A NAME="getcharpos()"></A><B>getcharpos()</B>*
getcharpos({expr})
		Get the position for <A HREF="eval.html#String">String</A> {expr}. Same <A HREF="motion.html#as">as</A> |<A HREF="#getpos()">getpos()</A>| but the
		column number in the returned <A HREF="eval.html#List">List</A> is a character index
		instead of a byte index.
		If |<A HREF="#getpos()">getpos()</A>| returns a very large column number, equal to
		|<A HREF="eval.html#v:maxcol">v:maxcol</A>|, then <A HREF="#getcharpos()">getcharpos()</A> will return the character index
		of the last character.

		Example:
		With the cursor on '' in line 5 with text &quot;&quot;:
<B>			getcharpos('.')		returns [0, 5, 3, 0]</B>
<B>			getpos('.')		returns [0, 5, 7, 0]</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMark()-&gt;getcharpos()</B>


<A HREF="#getcharsearch()">getcharsearch()</A>						*<A NAME="getcharsearch()"></A><B>getcharsearch()</B>*
		Return the current character search information <A HREF="motion.html#as">as</A> a {dict}
		with the following entries:

		    char	character previously used for a character
				search (|<A HREF="motion.html#t">t</A>|, |<A HREF="motion.html#f">f</A>|, |<A HREF="motion.html#T">T</A>|, or |<A HREF="motion.html#F">F</A>|); empty <A HREF="eval.html#string">string</A>
				if no character search has been performed
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |<A HREF="motion.html#t">t</A>| or |<A HREF="motion.html#T">T</A>|
				character search, 0 for an |<A HREF="motion.html#f">f</A>| or |<A HREF="motion.html#F">F</A>|
				character search

		This can be useful to always have |<A HREF="motion.html#;">;</A>| and |<A HREF="motion.html#,">,</A>| search
		forward/backward regardless of the direction of the previous
		character search:
<B>			:nnoremap &lt;expr&gt; ; getcharsearch().forward ? ';' : ','</B>
<B>			:nnoremap &lt;expr&gt; , getcharsearch().forward ? ',' : ';'</B>
 		Also see |<A HREF="#setcharsearch()">setcharsearch()</A>|.



getcharstr([expr])					*<A NAME="getcharstr()"></A><B>getcharstr()</B>*
		Get a single character from the user or input stream <A HREF="motion.html#as">as</A> a
		<A HREF="eval.html#string">string</A>.
		If [expr] is omitted, wait until a character is available.
		If [expr] is 0 or <A HREF="vim9.html#false">false</A>, only get a character when one is
			available.  Return an empty <A HREF="eval.html#string">string</A> otherwise.
		If [expr] is 1 or <A HREF="vim9.html#true">true</A>, only check if a character is
			available, <A HREF="motion.html#it">it</A> is not consumed.  Return an empty <A HREF="eval.html#string">string</A>
			if no character is available.
		Otherwise this works like |<A HREF="#getchar()">getchar()</A>|, except that a number
		result is converted to a <A HREF="eval.html#string">string</A>.


<A HREF="#getcmdcompltype()">getcmdcompltype()</A>					*<A NAME="getcmdcompltype()"></A><B>getcmdcompltype()</B>*
		Return the type of the current command-line completion.
		Only works when the command line is being edited, thus
		requires use of |<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>| or |<A HREF="cmdline.html#c_CTRL-R_=">c_CTRL-R_=</A>|.
		See |<A HREF="map.html#:command-completion">:command-completion</A>| for the return <A HREF="eval.html#string">string</A>.
		Also see |<A HREF="#getcmdtype()">getcmdtype()</A>|, |<A HREF="#setcmdpos()">setcmdpos()</A>| and |<A HREF="#getcmdline()">getcmdline()</A>|.
		Returns an empty <A HREF="eval.html#string">string</A> when completion is not defined.


<A HREF="#getcmdline()">getcmdline()</A>						*<A NAME="getcmdline()"></A><B>getcmdline()</B>*
		Return the current command-line.  Only works when the command
		line is being edited, thus requires use of |<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>| or
		|<A HREF="cmdline.html#c_CTRL-R_=">c_CTRL-R_=</A>|.
		Example:
<B>			:cmap &lt;F7&gt; &lt;C-\&gt;eescape(getcmdline(), ' \')&lt;CR&gt;</B>
 		Also see |<A HREF="#getcmdtype()">getcmdtype()</A>|, |<A HREF="#getcmdpos()">getcmdpos()</A>| and |<A HREF="#setcmdpos()">setcmdpos()</A>|.
		Returns an empty <A HREF="eval.html#string">string</A> when entering a password or using
		|<A HREF="#inputsecret()">inputsecret()</A>|.


<A HREF="#getcmdpos()">getcmdpos()</A>						*<A NAME="getcmdpos()"></A><B>getcmdpos()</B>*
		Return the position of the cursor in the command line <A HREF="motion.html#as">as</A> a
		byte <A HREF="intro.html#count">count</A>.  The first column is 1.
		Only works when editing the command line, thus requires use of
		|<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>| or |<A HREF="cmdline.html#c_CTRL-R_=">c_CTRL-R_=</A>| or an <A HREF="eval.html#expression">expression</A> <A HREF="map.html#mapping">mapping</A>.
		Returns 0 otherwise.
		Also see |<A HREF="#getcmdtype()">getcmdtype()</A>|, |<A HREF="#setcmdpos()">setcmdpos()</A>| and |<A HREF="#getcmdline()">getcmdline()</A>|.


<A HREF="#getcmdscreenpos()">getcmdscreenpos()</A>					*<A NAME="getcmdscreenpos()"></A><B>getcmdscreenpos()</B>*
		Return the screen position of the cursor in the command line
		<A HREF="motion.html#as">as</A> a byte <A HREF="intro.html#count">count</A>.  The first column is 1.
		Instead of |<A HREF="#getcmdpos()">getcmdpos()</A>|, <A HREF="motion.html#it">it</A> adds the prompt position.
		Only works when editing the command line, thus requires use of
		|<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>| or |<A HREF="cmdline.html#c_CTRL-R_=">c_CTRL-R_=</A>| or an <A HREF="eval.html#expression">expression</A> <A HREF="map.html#mapping">mapping</A>.
		Returns 0 otherwise.
		Also see |<A HREF="#getcmdpos()">getcmdpos()</A>|, |<A HREF="#setcmdpos()">setcmdpos()</A>|.


<A HREF="#getcmdtype()">getcmdtype()</A>						*<A NAME="getcmdtype()"></A><B>getcmdtype()</B>*
		Return the current command-line type. Possible return values
		are:
		    :	normal <A HREF="intro.html#Ex">Ex</A> command
		    <A HREF="change.html#&gt;">&gt;</A>	debug mode command |<A HREF="repeat.html#debug-mode">debug-mode</A>|
		    /	forward search command
		    ?	backward search command
		    @	|<A HREF="#input()">input()</A>| command
		    -	|<A HREF="insert.html#:insert">:insert</A>| or |<A HREF="insert.html#:append">:append</A>| command
		    =	|<A HREF="insert.html#i_CTRL-R_=">i_CTRL-R_=</A>|
		Only works when editing the command line, thus requires use of
		|<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>| or |<A HREF="cmdline.html#c_CTRL-R_=">c_CTRL-R_=</A>| or an <A HREF="eval.html#expression">expression</A> <A HREF="map.html#mapping">mapping</A>.
		Returns an empty <A HREF="eval.html#string">string</A> otherwise.
		Also see |<A HREF="#getcmdpos()">getcmdpos()</A>|, |<A HREF="#setcmdpos()">setcmdpos()</A>| and |<A HREF="#getcmdline()">getcmdline()</A>|.


<A HREF="#getcmdwintype()">getcmdwintype()</A>						*<A NAME="getcmdwintype()"></A><B>getcmdwintype()</B>*
		Return the current |<A HREF="cmdline.html#command-line-window">command-line-window</A>| type. Possible return
		values are the same <A HREF="motion.html#as">as</A> |<A HREF="#getcmdtype()">getcmdtype()</A>|. Returns an empty <A HREF="eval.html#string">string</A>
		when not in the command-line <A HREF="windows.html#window">window</A>.


getcompletion({pat}, {type} [, {filtered}])		*<A NAME="getcompletion()"></A><B>getcompletion()</B>*
		Return a <A HREF="eval.html#list">list</A> of command-line completion matches. The <A HREF="eval.html#String">String</A>
		{type} argument specifies what for.  The following completion
		types are supported:

		<A HREF="editing.html#arglist">arglist</A>		file names in argument <A HREF="eval.html#list">list</A>
		augroup		autocmd groups
		buffer		buffer names
		behave		|<A HREF="gui.html#:behave">:behave</A>| suboptions
		breakpoint	|<A HREF="repeat.html#:breakadd">:breakadd</A>| and |<A HREF="repeat.html#:breakdel">:breakdel</A>| suboptions
		color		color schemes
		command		<A HREF="intro.html#Ex">Ex</A> command
		cmdline		|<A HREF="cmdline.html#cmdline-completion">cmdline-completion</A>| result
		compiler	compilers
		cscope		|<A HREF="if_cscop.html#:cscope">:cscope</A>| suboptions
		diff_buffer     |<A HREF="diff.html#:diffget">:diffget</A>| and |<A HREF="diff.html#:diffput">:diffput</A>| completion
		dir		directory names
		environment	environment variable names
		event		<A HREF="autocmd.html#autocommand">autocommand</A> events
		<A HREF="eval.html#expression">expression</A>	Vim <A HREF="eval.html#expression">expression</A>
		file		file and directory names
		file_in_path	file and directory names in |<A HREF="options.html#'path'">'path'</A>|
		filetype	filetype names |<A HREF="options.html#'filetype'">'filetype'</A>|
		function	function name
		help		help subjects
		highlight	highlight groups
		history		|<A HREF="cmdline.html#:history">:history</A>| suboptions
		<A HREF="mbyte.html#locale">locale</A>		<A HREF="mbyte.html#locale">locale</A> names (as output of <A HREF="mbyte.html#locale">locale</A> -a)
		mapclear	buffer argument
		<A HREF="map.html#mapping">mapping</A>		<A HREF="map.html#mapping">mapping</A> name
		menu		<A HREF="gui.html#menus">menus</A>
		messages	|<A HREF="message.html#:messages">:messages</A>| suboptions
		option		<A HREF="options.html#options">options</A>
		packadd		optional package |<A HREF="repeat.html#pack-add">pack-add</A>| names
		scriptnames	sourced script names |<A HREF="repeat.html#:scriptnames">:scriptnames</A>|
		shellcmd	Shell command
		sign		|<A HREF="sign.html#:sign">:sign</A>| suboptions
		syntax		syntax file names |<A HREF="options.html#'syntax'">'syntax'</A>|
		syntime		|<A HREF="syntax.html#:syntime">:syntime</A>| suboptions
		<A HREF="tagsrch.html#tag">tag</A>		<A HREF="tagsrch.html#tags">tags</A>
		tag_listfiles	<A HREF="tagsrch.html#tags">tags</A>, file names
		user		user names
		var		user <A HREF="eval.html#variables">variables</A>

		If {pat} is an empty <A HREF="eval.html#string">string</A>, then all the matches are
		returned.  Otherwise only items matching {pat} are returned.
		See |<A HREF="editing.html#wildcards">wildcards</A>| for the use of special characters in {pat}.

		If the optional {filtered} flag is set to 1, then <A HREF="options.html#'wildignore'">'wildignore'</A>
		is applied to <A HREF="change.html#filter">filter</A> the results.  Otherwise all the matches
		are returned. The <A HREF="options.html#'wildignorecase'">'wildignorecase'</A> option always applies.

		If the <A HREF="options.html#'wildoptions'">'wildoptions'</A> option contains 'fuzzy', then fuzzy
		matching is used to get the completion matches. Otherwise
		regular <A HREF="eval.html#expression">expression</A> matching is used.  Thus this function
		follows the user preference, what happens on the command line.
		If you <A HREF="diff.html#do">do</A> not want this you can make <A HREF="options.html#'wildoptions'">'wildoptions'</A> empty
		before calling <A HREF="#getcompletion()">getcompletion()</A> and restore <A HREF="motion.html#it">it</A> afterwards.

		If {type} is &quot;cmdline&quot;, then the |<A HREF="cmdline.html#cmdline-completion">cmdline-completion</A>| result is
		returned.  For example, to complete the possible values after
		a &quot;<A HREF="eval.html#:call">:call</A>&quot; command:
<B>			echo getcompletion('call ', 'cmdline')</B>
 
		If there are no matches, an empty <A HREF="eval.html#list">list</A> is returned.  An
		invalid value for {type} produces an error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPattern()-&gt;getcompletion('color')</B>
 

							*<A NAME="getcurpos()"></A><B>getcurpos()</B>*
getcurpos([{winid}])
		Get the position of the cursor.  This is like getpos('.'), but
		includes an extra &quot;curswant&quot; item in the <A HREF="eval.html#list">list</A>:
<B><FONT COLOR="PURPLE">		    [0, lnum, col, off, curswant] </FONT></B>
		The &quot;curswant&quot; number is the preferred column when moving the
		cursor vertically.  After |<A HREF="motion.html#$">$</A>| command <A HREF="motion.html#it">it</A> will be a very large
		number equal to |<A HREF="eval.html#v:maxcol">v:maxcol</A>|.  Also see |<A HREF="#getcursorcharpos()">getcursorcharpos()</A>| and
		|<A HREF="#getpos()">getpos()</A>|.
		The first &quot;bufnum&quot; item is always zero. The byte position of
		the cursor is returned in 'col'. To get the character
		position, use |<A HREF="#getcursorcharpos()">getcursorcharpos()</A>|.

		The optional {winid} argument can specify the <A HREF="windows.html#window">window</A>.  It can
		be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.  The last known
		cursor position is returned, this may be invalid for the
		current value of the buffer if <A HREF="motion.html#it">it</A> is not the current <A HREF="windows.html#window">window</A>.
		If {winid} is invalid a <A HREF="eval.html#list">list</A> with zeroes is returned.

		This can be used to save and restore the cursor position:
<B>			let save_cursor = getcurpos()</B>
<B>			MoveTheCursorAround</B>
<B>			call setpos('.', save_cursor)</B>
 		Note that this only works within the <A HREF="windows.html#window">window</A>.  See
		|<A HREF="#winrestview()">winrestview()</A>| for restoring more state.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;getcurpos()</B>
 

							*<A NAME="getcursorcharpos()"></A><B>getcursorcharpos()</B>*
getcursorcharpos([{winid}])
		Same <A HREF="motion.html#as">as</A> |<A HREF="#getcurpos()">getcurpos()</A>| but the column number in the returned
		<A HREF="eval.html#List">List</A> is a character index instead of a byte index.

		Example:
		With the cursor on '' in line 3 with text &quot;&quot;:
<B>			getcursorcharpos()	returns [0, 3, 2, 0, 3]</B>
<B>			getcurpos()		returns [0, 3, 4, 0, 3]</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;getcursorcharpos()</B>


 							*<A NAME="getcwd()"></A><B>getcwd()</B>*
getcwd([{winnr} [, {tabnr}]])
		The result is a <A HREF="eval.html#String">String</A>, which is the name of the current
		working directory.  <A HREF="options.html#'autochdir'">'autochdir'</A> is ignored.

		With {winnr} return the local current directory of this <A HREF="windows.html#window">window</A>
		in the current <A HREF="intro.html#tab">tab</A> page.  {winnr} can be the <A HREF="windows.html#window">window</A> number or
		the |<A HREF="windows.html#window-ID">window-ID</A>|.
		If {winnr} is -1 return the name of the global working
		directory.  See also |<A HREF="#haslocaldir()">haslocaldir()</A>|.

		With {winnr} and {tabnr} return the local current directory of
		the <A HREF="windows.html#window">window</A> in the specified <A HREF="intro.html#tab">tab</A> page. If {winnr} is -1 return
		the working directory of the <A HREF="tabpage.html#tabpage">tabpage</A>.
		If {winnr} is zero use the current <A HREF="windows.html#window">window</A>, if {tabnr} is zero
		use the current <A HREF="tabpage.html#tabpage">tabpage</A>.
		Without any arguments, return the actual working directory of
		the current <A HREF="windows.html#window">window</A>.
		Return an empty <A HREF="eval.html#string">string</A> if the arguments are invalid.

		Examples:
<B>			" Get the working directory of the current window</B>
<B>			:echo getcwd()</B>
<B>			:echo getcwd(0)</B>
<B>			:echo getcwd(0, 0)</B>
<B>			" Get the working directory of window 3 in tabpage 2</B>
<B>			:echo getcwd(3, 2)</B>
<B>			" Get the global working directory</B>
<B>			:echo getcwd(-1)</B>
<B>			" Get the working directory of tabpage 3</B>
<B>			:echo getcwd(-1, 3)</B>
<B>			" Get the working directory of current tabpage</B>
<B>			:echo getcwd(-1, 0)</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;getcwd()</B>


getenv({name})						*<A NAME="getenv()"></A><B>getenv()</B>*
		Return the value of environment variable {name}.  The {name}
		argument is a <A HREF="eval.html#string">string</A>, without a leading '<A HREF="motion.html#$">$</A>'.  Example:
<B>			myHome = getenv('HOME')</B>

 		When the variable does not exist |<A HREF="eval.html#v:null">v:null</A>| is returned.  That
		is different from a variable set to an empty <A HREF="eval.html#string">string</A>, although
		some systems interpret the empty value <A HREF="motion.html#as">as</A> the variable being
		deleted.  See also |<A HREF="eval.html#expr-env">expr-env</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetVarname()-&gt;getenv()</B>


getfontname([{name}])					*<A NAME="getfontname()"></A><B>getfontname()</B>*
		Without an argument returns the name of the normal font being
		used.  Like what is used for the <A HREF="intro.html#Normal">Normal</A> highlight group
		|<A HREF="syntax.html#hl-Normal">hl-Normal</A>|.
		With an argument a check is done whether <A HREF="eval.html#String">String</A> {name} is a
		valid font name.  If not then an empty <A HREF="eval.html#string">string</A> is returned.
		Otherwise the actual font name is returned, or {name} if the
		<A HREF="gui.html#GUI">GUI</A> does not support obtaining the real name.
		Only works when the <A HREF="gui.html#GUI">GUI</A> is running, thus not in your <A HREF="starting.html#vimrc">vimrc</A> or
		<A HREF="gui.html#gvimrc">gvimrc</A> file.  Use the |<A HREF="autocmd.html#GUIEnter">GUIEnter</A>| <A HREF="autocmd.html#autocommand">autocommand</A> to use this
		function just after the <A HREF="gui.html#GUI">GUI</A> has started.
		Note that the <A HREF="gui_x11.html#GTK">GTK</A> <A HREF="gui.html#GUI">GUI</A> accepts any font name, thus checking for
		a valid name does not work.


getfperm({fname})					*<A NAME="getfperm()"></A><B>getfperm()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is the read, write, and execute
		permissions of the given file {fname}.
		If {fname} does not exist or its directory cannot be read, an
		empty <A HREF="eval.html#string">string</A> is returned.
		The result is of the form &quot;rwxrwxrwx&quot;, where each group of
		&quot;rwx&quot; flags represent, in turn, the permissions of the owner
		of the file, the group the file belongs to, and other users.
		If a user does not have a given permission the flag for this
		is replaced with the <A HREF="eval.html#string">string</A> &quot;<A HREF="motion.html#-">-</A>&quot;.  Examples:
<B>			:echo getfperm("/etc/passwd")</B>
<B>			:echo getfperm(expand("~/.vimrc"))</B>
 		This will hopefully (from a security point of <A HREF="starting.html#view">view</A>) display
		the <A HREF="eval.html#string">string</A> &quot;rw-r--r--&quot; or even &quot;rw-------&quot;.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFilename()-&gt;getfperm()</B>
 
		For setting permissions use |<A HREF="#setfperm()">setfperm()</A>|.


getfsize({fname})					*<A NAME="getfsize()"></A><B>getfsize()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the size in bytes of the
		given file {fname}.
		If {fname} is a directory, 0 is returned.
		If the file {fname} can't be found, -1 is returned.
		If the size of {fname} is too big to fit in a <A HREF="eval.html#Number">Number</A> then -2
		is returned.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFilename()-&gt;getfsize()</B>


getftime({fname})					*<A NAME="getftime()"></A><B>getftime()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the last modification time of
		the given file {fname}.  The value is measured <A HREF="motion.html#as">as</A> seconds
		since 1st Jan 1970, and may be passed to <A HREF="#strftime()">strftime()</A>.  See also
		|<A HREF="#localtime()">localtime()</A>| and |<A HREF="#strftime()">strftime()</A>|.
		If the file {fname} can't be found -1 is returned.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFilename()-&gt;getftime()</B>


getftype({fname})					*<A NAME="getftype()"></A><B>getftype()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is a description of the kind of
		file of the given file {fname}.
		If {fname} does not exist an empty <A HREF="eval.html#string">string</A> is returned.
		Here is a table over different kinds of files and their
		results:
			<A HREF="intro.html#Normal">Normal</A> file		&quot;file&quot;
			Directory		&quot;dir&quot;
			Symbolic link		&quot;link&quot;
			Block device		&quot;bdev&quot;
			Character device	&quot;cdev&quot;
			Socket			&quot;socket&quot;
			FIFO			&quot;fifo&quot;
			All other		&quot;other&quot;
		Example:
<B>			getftype("/home")</B>
 		Note that a type such <A HREF="motion.html#as">as</A> &quot;link&quot; will only be returned on
		systems that support <A HREF="motion.html#it">it</A>.  On some systems only &quot;dir&quot; and
		&quot;file&quot; are returned.  On <A HREF="os_win32.html#MS-Windows">MS-Windows</A> a symbolic link to a
		directory returns &quot;dir&quot; instead of &quot;link&quot;.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFilename()-&gt;getftype()</B>


<A HREF="#getimstatus()">getimstatus()</A>						*<A NAME="getimstatus()"></A><B>getimstatus()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| when the <A HREF="mbyte.html#IME">IME</A> status is
		active and |<A HREF="eval.html#FALSE">FALSE</A>| otherwise.
		See <A HREF="options.html#'imstatusfunc'">'imstatusfunc'</A>.


getjumplist([{winnr} [, {tabnr}]])			*<A NAME="getjumplist()"></A><B>getjumplist()</B>*
		Returns the |<A HREF="motion.html#jumplist">jumplist</A>| for the specified <A HREF="windows.html#window">window</A>.

		Without arguments use the current <A HREF="windows.html#window">window</A>.
		With {winnr} only use this <A HREF="windows.html#window">window</A> in the current <A HREF="intro.html#tab">tab</A> page.
		{winnr} can also be a |<A HREF="windows.html#window-ID">window-ID</A>|.
		With {winnr} and {tabnr} use the <A HREF="windows.html#window">window</A> in the specified <A HREF="intro.html#tab">tab</A>
		page.  If {winnr} or {tabnr} is invalid, an empty <A HREF="eval.html#list">list</A> is
		returned.

		The returned <A HREF="eval.html#list">list</A> contains two entries: a <A HREF="eval.html#list">list</A> with the jump
		locations and the last used jump position number in the <A HREF="eval.html#list">list</A>.
		Each entry in the jump location <A HREF="eval.html#list">list</A> is a dictionary with
		the following entries:
			bufnr		buffer number
			col		column number
			coladd		column offset for <A HREF="options.html#'virtualedit'">'virtualedit'</A>
			filename	filename if available
			lnum		line number

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;getjumplist()</B>


 							*<A NAME="getline()"></A><B>getline()</B>*
getline({lnum} [, {end}])
		Without {end} the result is a <A HREF="eval.html#String">String</A>, which is line {lnum}
		from the current buffer.  Example:
<B>			getline(1)</B>
 		When {lnum} is a <A HREF="eval.html#String">String</A> that doesn't start with a
		digit, |<A HREF="#line()">line()</A>| is called to translate the <A HREF="eval.html#String">String</A> into a <A HREF="eval.html#Number">Number</A>.
		To get the line under the cursor:
<B>			getline(".")</B>
 		When {lnum} is a number smaller than 1 or bigger than the
		number of lines in the buffer, an empty <A HREF="eval.html#string">string</A> is returned.

		When {end} is given the result is a |<A HREF="eval.html#List">List</A>| where each item is
		a line from the current buffer in the range {lnum} to {end},
		including line {end}.
		{end} is used in the same way <A HREF="motion.html#as">as</A> {lnum}.
		Non-existing lines are silently omitted.
		When {end} is before {lnum} an empty |<A HREF="eval.html#List">List</A>| is returned.
		Example:
<B>			:let start = line('.')</B>
<B>			:let end = search("^$") - 1</B>
<B>			:let lines = getline(start, end)</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ComputeLnum()-&gt;getline()</B>

 		To get lines from another buffer see |<A HREF="#getbufline()">getbufline()</A>|


getloclist({nr} [, {what}])				*<A NAME="getloclist()"></A><B>getloclist()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| with all the entries in the location <A HREF="eval.html#list">list</A> for
		window {nr}.  {nr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {nr} is zero the current <A HREF="windows.html#window">window</A> is used.

		For a location <A HREF="eval.html#list">list</A> <A HREF="windows.html#window">window</A>, the displayed location <A HREF="eval.html#list">list</A> is
		returned.  For an invalid <A HREF="windows.html#window">window</A> number {nr}, an empty <A HREF="eval.html#list">list</A> is
		returned. Otherwise, same <A HREF="motion.html#as">as</A> |<A HREF="#getqflist()">getqflist()</A>|.

		If the optional {what} dictionary argument is supplied, then
		returns the items listed in {what} <A HREF="motion.html#as">as</A> a dictionary. Refer to
		|<A HREF="#getqflist()">getqflist()</A>| for the supported items in {what}.

		In addition to the items supported by |<A HREF="#getqflist()">getqflist()</A>| in {what},
		the following item is supported by YXXYgetloclist()|:

			filewinid	id of the <A HREF="windows.html#window">window</A> used to display files
					from the location <A HREF="eval.html#list">list</A>. This field is
					applicable only when called from a
					location <A HREF="eval.html#list">list</A> <A HREF="windows.html#window">window</A>. See
					|<A HREF="quickfix.html#location-list-file-window">location-list-file-window</A>| for more
					details.

		Returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| with default values if there is no
		location <A HREF="eval.html#list">list</A> for the <A HREF="windows.html#window">window</A> {nr}.
		Returns an empty <A HREF="eval.html#Dictionary">Dictionary</A> if <A HREF="windows.html#window">window</A> {nr} does not exist.

		Examples (See also |<A HREF="quickfix.html#getqflist-examples">getqflist-examples</A>|):
<B>			:echo getloclist(3, {'all': 0})</B>
<B>			:echo getloclist(5, {'filewinid': 0})</B>



getmarklist([{buf}])					*<A NAME="getmarklist()"></A><B>getmarklist()</B>*
		Without the {buf} argument returns a |<A HREF="eval.html#List">List</A>| with information
		about all the global marks. |<A HREF="motion.html#mark">mark</A>|

		If the optional {buf} argument is specified, returns the
		local marks defined in buffer {buf}.  For the use of {buf},
		see |<A HREF="#bufname()">bufname()</A>|.  If {buf} is invalid, an empty <A HREF="eval.html#list">list</A> is
		returned.

		Each item in the returned <A HREF="eval.html#List">List</A> is a |<A HREF="eval.html#Dict">Dict</A>| with the following:
		    <A HREF="motion.html#mark">mark</A>   name of the <A HREF="motion.html#mark">mark</A> prefixed by &quot;&#39;&#34;'
		    pos	   a |<A HREF="eval.html#List">List</A>| with the position of the <A HREF="motion.html#mark">mark</A>:
				[bufnum, lnum, col, off]
			   Refer to |<A HREF="#getpos()">getpos()</A>| for more information.
		    file   file name

		Refer to |<A HREF="#getpos()">getpos()</A>| for getting information about a specific
		<A HREF="motion.html#mark">mark</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBufnr()-&gt;getmarklist()</B>


getmatches([{win}])					*<A NAME="getmatches()"></A><B>getmatches()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| with all matches previously defined for the
		current <A HREF="windows.html#window">window</A> by |<A HREF="#matchadd()">matchadd()</A>| and the |<A HREF="pattern.html#:match">:match</A>| commands.
		|<A HREF="#getmatches()">getmatches()</A>| is useful in combination with |<A HREF="#setmatches()">setmatches()</A>|,
		<A HREF="motion.html#as">as</A> |<A HREF="#setmatches()">setmatches()</A>| can restore a <A HREF="eval.html#list">list</A> of matches saved by
		|<A HREF="#getmatches()">getmatches()</A>|.
		If {win} is specified, use the <A HREF="windows.html#window">window</A> with this number or
		<A HREF="windows.html#window">window</A> ID instead of the current <A HREF="windows.html#window">window</A>.  If {win} is invalid,
		an empty <A HREF="eval.html#list">list</A> is returned.
		Example:
<B>			:echo getmatches()</B>
 			[{'group': 'MyGroup1', '<A HREF="pattern.html#pattern">pattern</A>': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'<A HREF="pattern.html#pattern">pattern</A>': 'FIXME', 'priority': 10, 'id': 2}]
<B>			:let m = getmatches()</B>
<B>			:call clearmatches()</B>
<B>			:echo getmatches()</B>
 			<A HREF="motion.html#[]">[]</A>
<B>			:call setmatches(m)</B>
<B>			:echo getmatches()</B>
 			[{'group': 'MyGroup1', '<A HREF="pattern.html#pattern">pattern</A>': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'<A HREF="pattern.html#pattern">pattern</A>': 'FIXME', 'priority': 10, 'id': 2}]
<B>			:unlet m</B>
 

<A HREF="#getmousepos()">getmousepos()</A>						*<A NAME="getmousepos()"></A><B>getmousepos()</B>*
		Returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| with the last known position of the
		mouse.  This can be used in a <A HREF="map.html#mapping">mapping</A> for a mouse click or in
		a <A HREF="change.html#filter">filter</A> of a <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>.  The items are:
			screenrow	screen row
			screencol	screen column
			<A HREF="windows.html#winid">winid</A>		Window ID of the click
			winrow		row inside &quot;<A HREF="windows.html#winid">winid</A>&quot;
			wincol		column inside &quot;<A HREF="windows.html#winid">winid</A>&quot;
			line		text line inside &quot;<A HREF="windows.html#winid">winid</A>&quot;
			column		text column inside &quot;<A HREF="windows.html#winid">winid</A>&quot;
		All numbers are 1-based.

		If not over a <A HREF="windows.html#window">window</A>, e.g. when in the command line, then only
		&quot;screenrow&quot; and &quot;screencol&quot; are valid, the others are zero.

		When on the status line below a <A HREF="windows.html#window">window</A> or the vertical
		separator right of a <A HREF="windows.html#window">window</A>, the &quot;line&quot; and &quot;column&quot; values
		are zero.

		When the position is after the text then &quot;column&quot; is the
		length of the text in bytes plus one.

		If the mouse is over a <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> then that <A HREF="windows.html#window">window</A> is used.

		When using |<A HREF="#getchar()">getchar()</A>| the Vim <A HREF="eval.html#variables">variables</A> |<A HREF="eval.html#v:mouse_lnum">v:mouse_lnum</A>|,
		|<A HREF="eval.html#v:mouse_col">v:mouse_col</A>| and |<A HREF="eval.html#v:mouse_winid">v:mouse_winid</A>| also provide these values.


							*<A NAME="getpid()"></A><B>getpid()</B>*
<A HREF="#getpid()">getpid()</A>	Return a <A HREF="eval.html#Number">Number</A> which is the process ID of the Vim process.
		On <A HREF="os_unix.html#Unix">Unix</A> and <A HREF="os_win32.html#MS-Windows">MS-Windows</A> this is a unique number, until Vim
		exits.


							*<A NAME="getpos()"></A><B>getpos()</B>*
getpos({expr})	Get the position for <A HREF="eval.html#String">String</A> {expr}.  For possible values of
		{expr} see |<A HREF="#line()">line()</A>|.  For getting the cursor position see
		|<A HREF="#getcurpos()">getcurpos()</A>|.
		The result is a |<A HREF="eval.html#List">List</A>| with four numbers:
		    [bufnum, lnum, col, off]
		&quot;bufnum&quot; is zero, unless a <A HREF="motion.html#mark">mark</A> like <A HREF="motion.html#'0">'0</A> or <A HREF="motion.html#'A">'A</A> is used, then <A HREF="motion.html#it">it</A>
		is the buffer number of the <A HREF="motion.html#mark">mark</A>.
		&quot;lnum&quot; and &quot;col&quot; are the position in the buffer.  The first
		column is 1.
		The &quot;off&quot; number is zero, unless <A HREF="options.html#'virtualedit'">'virtualedit'</A> is used.  Then
		<A HREF="motion.html#it">it</A> is the offset in screen columns from the start of the
		character.  E.g., a position within a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> or after the last
		character.
		Note that for <A HREF="motion.html#'&lt;">'&lt;</A> and <A HREF="motion.html#'&gt;">'&gt;</A> <A HREF="visual.html#Visual">Visual</A> mode matters: when <A HREF="motion.html#it">it</A> is &quot;<A HREF="visual.html#V">V</A>&quot;
		(visual line mode) the column of <A HREF="motion.html#'&lt;">'&lt;</A> is zero and the column of
		<A HREF="motion.html#'&gt;">'&gt;</A> is a large number equal to |<A HREF="eval.html#v:maxcol">v:maxcol</A>|.
		The column number in the returned <A HREF="eval.html#List">List</A> is the byte position
		within the line. To get the character position in the line,
		use |<A HREF="#getcharpos()">getcharpos()</A>|.
		A very large column number equal to |<A HREF="eval.html#v:maxcol">v:maxcol</A>| can be returned,
		in which <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> means &quot;after the end of the line&quot;.
		If {expr} is invalid, returns a <A HREF="eval.html#list">list</A> with all zeros.
		This can be used to save and restore the position of a <A HREF="motion.html#mark">mark</A>:
<B>			let save_a_mark = getpos("'a")</B>
<B>			...</B>
<B>			call setpos("'a", save_a_mark)</B>
 		Also see |<A HREF="#getcharpos()">getcharpos()</A>|, |<A HREF="#getcurpos()">getcurpos()</A>| and |<A HREF="#setpos()">setpos()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMark()-&gt;getpos()</B>


getqflist([{what}])					*<A NAME="getqflist()"></A><B>getqflist()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| with all the current <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="message.html#errors">errors</A>.  Each
		<A HREF="eval.html#list">list</A> item is a dictionary with these entries:
			bufnr	number of buffer that has the file name, use
				<A HREF="#bufname()">bufname()</A> to get the name
			module	module name
			lnum	line number in the buffer (first line is 1)
			end_lnum
				end of line number if the item is multiline
			col	column number (first column is 1)
			end_col	end of column number if the item has range
			vcol	|TRUE|: &quot;col&quot; is visual column
				|FALSE|: &quot;col&quot; is byte index
			nr	error number
			<A HREF="pattern.html#pattern">pattern</A>	search <A HREF="pattern.html#pattern">pattern</A> used to locate the error
			text	description of the error
			type	type of the error, '<A HREF="motion.html#E">E</A>', '1', etc.
			valid	|TRUE|: recognized error message

		When there is no error <A HREF="eval.html#list">list</A> or it's empty, an empty <A HREF="eval.html#list">list</A> is
		returned. <A HREF="quickfix.html#Quickfix">Quickfix</A> <A HREF="eval.html#list">list</A> entries with a non-existing buffer
		number are returned with &quot;bufnr&quot; set to zero (Note: some
		<A HREF="eval.html#functions">functions</A> accept buffer number zero for the alternate buffer,
		you may need to explicitly check for zero).

		Useful application: Find <A HREF="pattern.html#pattern">pattern</A> matches in multiple files and
		<A HREF="diff.html#do">do</A> something with them:
<B>			:vimgrep /theword/jg *.c</B>
<B>			:for d in getqflist()</B>
<B>			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text</B>
<B>			:endfor</B>
 
		If the optional {what} dictionary argument is supplied, then
		returns only the items listed in {what} <A HREF="motion.html#as">as</A> a dictionary. The
		following <A HREF="eval.html#string">string</A> items are supported in {what}:
			changedtick	get the total number of changes made
					to the <A HREF="eval.html#list">list</A> |<A HREF="quickfix.html#quickfix-changedtick">quickfix-changedtick</A>|
			context	get the |<A HREF="quickfix.html#quickfix-context">quickfix-context</A>|
			efm	<A HREF="quickfix.html#errorformat">errorformat</A> to use when parsing &quot;lines&quot;. If
				not present, then the <A HREF="options.html#'errorformat'">'errorformat'</A> option
				value is used.
			id	get information for the <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> with
				|<A HREF="quickfix.html#quickfix-ID">quickfix-ID</A>|; zero means the id for the
				current <A HREF="eval.html#list">list</A> or the <A HREF="eval.html#list">list</A> specified by &quot;nr&quot;
			idx	get information for the <A HREF="quickfix.html#quickfix">quickfix</A> entry at this
				index in the <A HREF="eval.html#list">list</A> specified by 'id' or 'nr'.
				If set to zero, then uses the current entry.
				See |<A HREF="quickfix.html#quickfix-index">quickfix-index</A>|
			items	<A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> entries
			lines	parse a <A HREF="eval.html#list">list</A> of lines using <A HREF="options.html#'efm'">'efm'</A> and return
				the resulting entries.  Only a |<A HREF="eval.html#List">List</A>| type is
				accepted.  The current <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> is not
				modified. See |<A HREF="quickfix.html#quickfix-parse">quickfix-parse</A>|.
			nr	get information for this <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>; zero
				means the current <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> and &quot;<A HREF="motion.html#$">$</A>&quot; means
				the last <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>
			qfbufnr number of the buffer displayed in the <A HREF="quickfix.html#quickfix">quickfix</A>
				<A HREF="windows.html#window">window</A>. Returns 0 if the <A HREF="quickfix.html#quickfix">quickfix</A> buffer is
				not present. See |<A HREF="quickfix.html#quickfix-buffer">quickfix-buffer</A>|.
			size	number of entries in the <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>
			title	get the <A HREF="eval.html#list">list</A> title |<A HREF="quickfix.html#quickfix-title">quickfix-title</A>|
			<A HREF="windows.html#winid">winid</A>	get the <A HREF="quickfix.html#quickfix">quickfix</A> |<A HREF="windows.html#window-ID">window-ID</A>|
			all	all of the above <A HREF="quickfix.html#quickfix">quickfix</A> properties
		Non-string items in {what} are ignored. To get the value of a
		particular item, set <A HREF="motion.html#it">it</A> to zero.
		If &quot;nr&quot; is not present then the current <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> is used.
		If both &quot;nr&quot; and a non-zero &quot;id&quot; are specified, then the <A HREF="eval.html#list">list</A>
		specified by &quot;id&quot; is used.
		To get the number of lists in the <A HREF="quickfix.html#quickfix">quickfix</A> stack, set &quot;nr&quot; to
		&quot;<A HREF="motion.html#$">$</A>&quot; in {what}. The &quot;nr&quot; value in the returned dictionary
		contains the <A HREF="quickfix.html#quickfix">quickfix</A> stack size.
		When &quot;lines&quot; is specified, all the other items except &quot;efm&quot;
		are ignored.  The returned dictionary contains the entry
		&quot;items&quot; with the <A HREF="eval.html#list">list</A> of entries.

		The returned dictionary contains the following entries:
			changedtick	total number of changes made to the
					<A HREF="eval.html#list">list</A> |<A HREF="quickfix.html#quickfix-changedtick">quickfix-changedtick</A>|
			context	quickfix <A HREF="eval.html#list">list</A> context. See |<A HREF="quickfix.html#quickfix-context">quickfix-context</A>|
				If not present, set to &quot;&quot;.
			id	quickfix <A HREF="eval.html#list">list</A> ID |<A HREF="quickfix.html#quickfix-ID">quickfix-ID</A>|. If not
				present, set to 0.
			idx	index of the <A HREF="quickfix.html#quickfix">quickfix</A> entry in the <A HREF="eval.html#list">list</A>. If not
				present, set to 0.
			items	<A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> entries. If not present, set to
				an empty <A HREF="eval.html#list">list</A>.
			nr	<A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> number. If not present, set to 0
			qfbufnr	number of the buffer displayed in the <A HREF="quickfix.html#quickfix">quickfix</A>
				<A HREF="windows.html#window">window</A>. If not present, set to 0.
			size	number of entries in the <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>. If not
				present, set to 0.
			title	<A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> title text. If not present, set
				to &quot;&quot;.
			<A HREF="windows.html#winid">winid</A>	<A HREF="quickfix.html#quickfix">quickfix</A> |<A HREF="windows.html#window-ID">window-ID</A>|. If not present, set to 0

		Examples (See also |<A HREF="quickfix.html#getqflist-examples">getqflist-examples</A>|):
<B>			:echo getqflist({'all': 1})</B>
<B>			:echo getqflist({'nr': 2, 'title': 1})</B>
<B>			:echo getqflist({'lines' : ["F1:10:L10"]})</B>
 

getreg([{regname} [, 1 [, {list}]]])			*<A NAME="getreg()"></A><B>getreg()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is the contents of <A HREF="sponsor.html#register">register</A>
		{regname}.  Example:
<B>			:let cliptext = getreg('*')</B>
 		When <A HREF="sponsor.html#register">register</A> {regname} was not set the result is an empty
		<A HREF="eval.html#string">string</A>.

		The {regname} argument must be a <A HREF="eval.html#string">string</A>.  *<A NAME="E1162"></A><B>E1162</B>*

		getreg('=') returns the last evaluated value of the <A HREF="eval.html#expression">expression</A>
		<A HREF="sponsor.html#register">register</A>.  (For use in maps.)
		getreg('=', 1) returns the <A HREF="eval.html#expression">expression</A> itself, so that <A HREF="motion.html#it">it</A> can
		be restored with |<A HREF="#setreg()">setreg()</A>|.  For other <A HREF="change.html#registers">registers</A> the extra
		argument is ignored, thus you can always give <A HREF="motion.html#it">it</A>.

		If {list} is present and |<A HREF="eval.html#TRUE">TRUE</A>|, the result type is changed
		to |<A HREF="eval.html#List">List</A>|. Each <A HREF="eval.html#list">list</A> item is one text line. Use <A HREF="motion.html#it">it</A> if you care
		about zero bytes possibly present inside <A HREF="sponsor.html#register">register</A>: without
		third argument both NLs and zero bytes are represented <A HREF="motion.html#as">as</A> NLs
		(see |<A HREF="pattern.html#NL-used-for-Nul">NL-used-for-Nul</A>|).
		When the <A HREF="sponsor.html#register">register</A> was not set an empty <A HREF="eval.html#list">list</A> is returned.

		If {regname} is &quot;&quot;, the unnamed <A HREF="sponsor.html#register">register</A> &#39;&#34;'' is used.
		If {regname} is not specified, |<A HREF="eval.html#v:register">v:register</A>| is used.
		In |<A HREF="vim9.html#Vim9-script">Vim9-script</A>| {regname} must be one character.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRegname()-&gt;getreg()</B>


getreginfo([{regname}])					*<A NAME="getreginfo()"></A><B>getreginfo()</B>*
		Returns detailed information about <A HREF="sponsor.html#register">register</A> {regname} <A HREF="motion.html#as">as</A> a
		<A HREF="eval.html#Dictionary">Dictionary</A> with the following entries:
			regcontents	<A HREF="eval.html#List">List</A> of lines contained in <A HREF="sponsor.html#register">register</A>
					{regname}, like
					|getreg|({regname}, 1, 1).
			regtype		the type of <A HREF="sponsor.html#register">register</A> {regname}, <A HREF="motion.html#as">as</A> in
					|<A HREF="#getregtype()">getregtype()</A>|.
			isunnamed	<A HREF="eval.html#Boolean">Boolean</A> flag, <A HREF="eval.html#v:true">v:true</A> if this <A HREF="sponsor.html#register">register</A>
					is currently pointed to by the unnamed
					<A HREF="sponsor.html#register">register</A>.
			points_to	for the unnamed <A HREF="sponsor.html#register">register</A>, gives the
					single <A HREF="print.html#letter">letter</A> name of the <A HREF="sponsor.html#register">register</A>
					currently pointed to (see |<A HREF="change.html#quotequote">quotequote</A>|).
					For example, after <A HREF="change.html#deleting">deleting</A> a line
					with `dd`, this field will be &quot;1&quot;,
					which is the <A HREF="sponsor.html#register">register</A> that got the
					deleted text.

		The {regname} argument is a <A HREF="eval.html#string">string</A>.  If {regname} is invalid
		or not set, an empty <A HREF="eval.html#Dictionary">Dictionary</A> will be returned.
		If {regname} is &quot;&quot; or &quot;<A HREF="repeat.html#@">@</A>&quot;, the unnamed <A HREF="sponsor.html#register">register</A> &#39;&#34;'' is used.
		If {regname} is not specified, |<A HREF="eval.html#v:register">v:register</A>| is used.
		The returned <A HREF="eval.html#Dictionary">Dictionary</A> can be passed to |<A HREF="#setreg()">setreg()</A>|.
		In |<A HREF="vim9.html#Vim9-script">Vim9-script</A>| {regname} must be one character.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRegname()-&gt;getreginfo()</B>


getregtype([{regname}])					*<A NAME="getregtype()"></A><B>getregtype()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is type of <A HREF="sponsor.html#register">register</A> {regname}.
		The value will be one of:
		    &quot;<A HREF="visual.html#v">v</A>&quot;			for |<A HREF="motion.html#characterwise">characterwise</A>| text
		    &quot;<A HREF="visual.html#V">V</A>&quot;			for |<A HREF="motion.html#linewise">linewise</A>| text
		    &quot;&lt;CTRL-V&gt;{width}&quot;	for |<A HREF="visual.html#blockwise-visual">blockwise-visual</A>| text
		    &quot;&quot;			for an empty or unknown <A HREF="sponsor.html#register">register</A>
		&lt;CTRL-V&gt; is one character with value 0x16.
		The {regname} argument is a <A HREF="eval.html#string">string</A>.  If {regname} is &quot;&quot;, the
		unnamed <A HREF="sponsor.html#register">register</A> &#39;&#34;'' is used.  If {regname} is not specified,
		|<A HREF="eval.html#v:register">v:register</A>| is used.
		In |<A HREF="vim9.html#Vim9-script">Vim9-script</A>| {regname} must be one character.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRegname()-&gt;getregtype()</B>


gettabinfo([{tabnr}])					*<A NAME="gettabinfo()"></A><B>gettabinfo()</B>*
		If {tabnr} is not specified, then information about all the
		<A HREF="intro.html#tab">tab</A> pages is returned <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#List">List</A>|. Each List item is a
		|<A HREF="eval.html#Dictionary">Dictionary</A>|.  Otherwise, {tabnr} specifies the <A HREF="intro.html#tab">tab</A> page
		number and information about that one is returned.  If the <A HREF="intro.html#tab">tab</A>
		page does not exist an empty <A HREF="eval.html#List">List</A> is returned.

		Each <A HREF="eval.html#List">List</A> item is a |<A HREF="eval.html#Dictionary">Dictionary</A>| with the following entries:
			tabnr		<A HREF="intro.html#tab">tab</A> page number.
			<A HREF="eval.html#variables">variables</A>	a reference to the dictionary with
					tabpage-local <A HREF="eval.html#variables">variables</A>
			<A HREF="windows.html#windows">windows</A>		<A HREF="eval.html#List">List</A> of |<A HREF="windows.html#window-ID">window-ID</A>|<A HREF="change.html#s">s</A> in the <A HREF="intro.html#tab">tab</A> page.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTabnr()-&gt;gettabinfo()</B>


gettabvar({tabnr}, {varname} [, {def}])				*<A NAME="gettabvar()"></A><B>gettabvar()</B>*
		Get the value of a tab-local variable {varname} in <A HREF="intro.html#tab">tab</A> page
		{tabnr}. |<A HREF="eval.html#t:var">t:var</A>|
		Tabs are numbered starting with one.
		The {varname} argument is a <A HREF="eval.html#string">string</A>.  When {varname} is empty a
		dictionary with all tab-local <A HREF="eval.html#variables">variables</A> is returned.
		Note that the name without &quot;<A HREF="eval.html#t:">t:</A>&quot; must be used.
		When the <A HREF="intro.html#tab">tab</A> or variable doesn't exist {def} or an empty
		<A HREF="eval.html#string">string</A> is returned, there is no error message.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTabnr()-&gt;gettabvar(varname)</B>


gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*<A NAME="gettabwinvar()"></A><B>gettabwinvar()</B>*
		Get the value of window-local variable {varname} in <A HREF="windows.html#window">window</A>
		{winnr} in <A HREF="intro.html#tab">tab</A> page {tabnr}.
		The {varname} argument is a <A HREF="eval.html#string">string</A>.  When {varname} is empty a
		dictionary with all window-local <A HREF="eval.html#variables">variables</A> is returned.
		When {varname} is equal to &quot;<A HREF="change.html#&amp;">&amp;</A>&quot; get the values of all
		window-local <A HREF="options.html#options">options</A> in a |<A HREF="eval.html#Dictionary">Dictionary</A>|.
		Otherwise, when {varname} starts with &quot;<A HREF="change.html#&amp;">&amp;</A>&quot; get the value of a
		window-local option.
		Note that {varname} must be the name without &quot;<A HREF="eval.html#w:">w:</A>&quot;.
		Tabs are numbered starting with one.  For the current <A HREF="tabpage.html#tabpage">tabpage</A>
		use |<A HREF="#getwinvar()">getwinvar()</A>|.
		{winnr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {winnr} is zero the current <A HREF="windows.html#window">window</A> is used.
		This also works for a global option, buffer-local option and
		window-local option, but <A HREF="motion.html#it">it</A> doesn't work for a global variable
		or buffer-local variable.
		When the <A HREF="intro.html#tab">tab</A>, <A HREF="windows.html#window">window</A> or variable doesn't exist {def} or an
		empty <A HREF="eval.html#string">string</A> is returned, there is no error message.
		Examples:
<B>			:let list_is_on = gettabwinvar(1, 2, '&amp;list')</B>
<B>			:echo "myvar = " .. gettabwinvar(3, 1, 'myvar')</B>
 
		To obtain all window-local <A HREF="eval.html#variables">variables</A> use:
<B>			gettabwinvar({tabnr}, {winnr}, '&amp;')</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTabnr()-&gt;gettabwinvar(winnr, varname)</B>


gettagstack([{winnr}])					*<A NAME="gettagstack()"></A><B>gettagstack()</B>*
		The result is a <A HREF="eval.html#Dict">Dict</A>, which is the <A HREF="tagsrch.html#tag">tag</A> stack of <A HREF="windows.html#window">window</A> {winnr}.
		{winnr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {winnr} is not specified, the current <A HREF="windows.html#window">window</A> is used.
		When <A HREF="windows.html#window">window</A> {winnr} doesn't exist, an empty <A HREF="eval.html#Dict">Dict</A> is returned.

		The returned dictionary contains the following entries:
			curidx		Current index in the stack. When at
					top of the stack, set to (length + 1).
					Index of bottom of the stack is 1.
			items		<A HREF="eval.html#List">List</A> of items in the stack. Each item
					is a dictionary containing the
					entries described below.
			length		<A HREF="eval.html#Number">Number</A> of entries in the stack.

		Each item in the stack is a dictionary with the following
		entries:
			bufnr		buffer number of the current jump
			from		cursor position before the <A HREF="tagsrch.html#tag">tag</A> jump.
					See |<A HREF="#getpos()">getpos()</A>| for the format of the
					returned <A HREF="eval.html#list">list</A>.
			matchnr		current matching <A HREF="tagsrch.html#tag">tag</A> number. Used when
					multiple matching <A HREF="tagsrch.html#tags">tags</A> are found for a
					name.
			tagname		name of the <A HREF="tagsrch.html#tag">tag</A>

		See |<A HREF="tagsrch.html#tagstack">tagstack</A>| for more information about the tag stack.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;gettagstack()</B>



gettext({text})						*<A NAME="gettext()"></A><B>gettext()</B>*
		Translate <A HREF="eval.html#String">String</A> {text} if possible.
		This is mainly for use in the distributed Vim scripts.  When
		generating message translations the {text} is extracted by
		xgettext, the translator can add the translated message in the
		.po file and Vim will lookup the translation when <A HREF="#gettext()">gettext()</A> is
		called.
		For {text} double quoted strings are preferred, because
		xgettext does not understand escaping in single quoted
		strings.



getwininfo([{winid}])					*<A NAME="getwininfo()"></A><B>getwininfo()</B>*
		Returns information about <A HREF="windows.html#windows">windows</A> <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#List">List</A>| with <A HREF="eval.html#Dictionaries">Dictionaries</A>.

		If {winid} is given Information about the <A HREF="windows.html#window">window</A> with that ID
		is returned, <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#List">List</A>| with one item.  If the <A HREF="windows.html#window">window</A> does not
		exist the result is an empty <A HREF="eval.html#list">list</A>.

		Without {winid} information about all the <A HREF="windows.html#windows">windows</A> in all the
		<A HREF="intro.html#tab">tab</A> pages is returned.

		Each <A HREF="eval.html#List">List</A> item is a |<A HREF="eval.html#Dictionary">Dictionary</A>| with the following entries:
			botline		last complete displayed buffer line
			bufnr		number of buffer in the <A HREF="windows.html#window">window</A>
			height		<A HREF="windows.html#window">window</A> height (excluding winbar)
			loclist		1 if showing a location <A HREF="eval.html#list">list</A>
					{only with the <A HREF="various.html#+quickfix">+quickfix</A> feature}
			<A HREF="quickfix.html#quickfix">quickfix</A>	1 if <A HREF="quickfix.html#quickfix">quickfix</A> or location <A HREF="eval.html#list">list</A> <A HREF="windows.html#window">window</A>
					{only with the <A HREF="various.html#+quickfix">+quickfix</A> feature}
			<A HREF="terminal.html#terminal">terminal</A>	1 if a <A HREF="terminal.html#terminal">terminal</A> <A HREF="windows.html#window">window</A>
					{only with the <A HREF="various.html#+terminal">+terminal</A> feature}
			tabnr		<A HREF="intro.html#tab">tab</A> page number
			topline		first displayed buffer line
			<A HREF="eval.html#variables">variables</A>	a reference to the dictionary with
					window-local <A HREF="eval.html#variables">variables</A>
			width		<A HREF="windows.html#window">window</A> width
			winbar		1 if the <A HREF="windows.html#window">window</A> has a toolbar, 0
					otherwise
			wincol		leftmost screen column of the <A HREF="windows.html#window">window</A>;
					&quot;col&quot; from |<A HREF="#win_screenpos()">win_screenpos()</A>|
			textoff		number of columns occupied by any
					<A HREF="options.html#'foldcolumn'">'foldcolumn'</A>, <A HREF="options.html#'signcolumn'">'signcolumn'</A> and line
					number in front of the text
			<A HREF="windows.html#winid">winid</A>		|<A HREF="windows.html#window-ID">window-ID</A>|
			winnr		<A HREF="windows.html#window">window</A> number
			winrow		topmost screen line of the <A HREF="windows.html#window">window</A>;
					&quot;row&quot; from |<A HREF="#win_screenpos()">win_screenpos()</A>|

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;getwininfo()</B>


getwinpos([{timeout}])					*<A NAME="getwinpos()"></A><B>getwinpos()</B>*
		The result is a |<A HREF="eval.html#List">List</A>| with two numbers, the result of
		|<A HREF="#getwinposx()">getwinposx()</A>| and |<A HREF="#getwinposy()">getwinposy()</A>| combined:
			[x-pos, y-pos]
		{timeout} can be used to specify how long to wait in msec for
		a response from the <A HREF="terminal.html#terminal">terminal</A>.  When omitted 100 msec is used.
		Use a longer time for a remote <A HREF="terminal.html#terminal">terminal</A>.
		When using a value <A HREF="various.html#less">less</A> than 10 and no response is received
		within that time, a previously reported position is returned,
		if available.  This can be used to poll for the position and
		<A HREF="diff.html#do">do</A> some work in the meantime:
<B>			while 1</B>
<B>			  let res = getwinpos(1)</B>
<B>			  if res[0] &gt;= 0</B>
<B>			    break</B>
<B>			  endif</B>
<B>			  " Do some work here</B>
<B>			endwhile</B>
 

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTimeout()-&gt;getwinpos()</B>
 

							*<A NAME="getwinposx()"></A><B>getwinposx()</B>*
<A HREF="#getwinposx()">getwinposx()</A>	The result is a <A HREF="eval.html#Number">Number</A>, which is the X coordinate in pixels of
		the left hand side of the <A HREF="gui.html#GUI">GUI</A> Vim <A HREF="windows.html#window">window</A>. Also works for an
		xterm (uses a timeout of 100 msec).
		The result will be -1 if the information is not available.
		The value can be used with `:winpos`.


							*<A NAME="getwinposy()"></A><B>getwinposy()</B>*
<A HREF="#getwinposy()">getwinposy()</A>	The result is a <A HREF="eval.html#Number">Number</A>, which is the <A HREF="change.html#Y">Y</A> coordinate in pixels of
		the top of the <A HREF="gui.html#GUI">GUI</A> Vim <A HREF="windows.html#window">window</A>.  Also works for an xterm (uses
		a timeout of 100 msec).
		The result will be -1 if the information is not available.
		The value can be used with `:winpos`.


getwinvar({winnr}, {varname} [, {def}])				*<A NAME="getwinvar()"></A><B>getwinvar()</B>*
		Like |<A HREF="#gettabwinvar()">gettabwinvar()</A>| for the current <A HREF="tabpage.html#tabpage">tabpage</A>.
		Examples:
<B>			:let list_is_on = getwinvar(2, '&amp;list')</B>
<B>			:echo "myvar = " .. getwinvar(1, 'myvar')</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;getwinvar(varname)</B>
 

glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])		*<A NAME="glob()"></A><B>glob()</B>*
		Expand the file wildcards in {expr}.  See |<A HREF="editing.html#wildcards">wildcards</A>| for the
		use of special characters.

		Unless the optional {nosuf} argument is given and is |<A HREF="eval.html#TRUE">TRUE</A>|,
		the <A HREF="options.html#'suffixes'">'suffixes'</A> and <A HREF="options.html#'wildignore'">'wildignore'</A> <A HREF="options.html#options">options</A> apply: Names matching
		one of the patterns in <A HREF="options.html#'wildignore'">'wildignore'</A> will be skipped and
		<A HREF="options.html#'suffixes'">'suffixes'</A> affect the ordering of matches.
		<A HREF="options.html#'wildignorecase'">'wildignorecase'</A> always applies.

		When {list} is present and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>| the result is a |<A HREF="eval.html#List">List</A>|
		with all matching files. The advantage of using a <A HREF="eval.html#List">List</A> is,
		you also get filenames containing newlines correctly.
		Otherwise the result is a <A HREF="eval.html#String">String</A> and when there are several
		matches, they are separated by <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A> characters.

		If the expansion fails, the result is an empty <A HREF="eval.html#String">String</A> or <A HREF="eval.html#List">List</A>.

		You can also use |<A HREF="#readdir()">readdir()</A>| if you need to <A HREF="diff.html#do">do</A> complicated
		things, such <A HREF="motion.html#as">as</A> limiting the number of matches.

		A name for a non-existing file is not included.  A symbolic
		link is only included if <A HREF="motion.html#it">it</A> points to an existing file.
		However, when the {alllinks} argument is present and <A HREF="motion.html#it">it</A> is
		|<A HREF="eval.html#TRUE">TRUE</A>| then all symbolic links are included.

		For most systems backticks can be used to get files names from
		any external command.  Example:
<B>			:let tagfiles = glob("`find . -name tags -print`")</B>
<B>			:let &amp;tags = substitute(tagfiles, "\n", ",", "g")</B>
 		The result of the program inside the backticks should be one
		item per line.  Spaces inside an item are allowed.

		See |<A HREF="#expand()">expand()</A>| for expanding special Vim <A HREF="eval.html#variables">variables</A>.  See
		|<A HREF="#system()">system()</A>| for getting the raw output of an external command.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;glob()</B>


glob2regpat({string})					 *<A NAME="glob2regpat()"></A><B>glob2regpat()</B>*
		Convert a file <A HREF="pattern.html#pattern">pattern</A>, <A HREF="motion.html#as">as</A> used by <A HREF="#glob()">glob()</A>, into a search
		<A HREF="pattern.html#pattern">pattern</A>.  The result can be used to match with a <A HREF="eval.html#string">string</A> that
		is a file name.  E.g.
<B>			if filename =~ glob2regpat('Make*.mak')</B>
 		This is equivalent to:
<B>			if filename =~ '^Make.*\.mak$'</B>
 		When {string} is an empty <A HREF="eval.html#string">string</A> the result is &quot;^$&quot;, match an
		empty <A HREF="eval.html#string">string</A>.
		Note that the result depends on the system.  On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>
		a <A HREF="intro.html#backslash">backslash</A> usually means a path separator.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;glob2regpat()</B>

 								*<A NAME="globpath()"></A><B>globpath()</B>*
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
		Perform <A HREF="#glob()">glob()</A> for <A HREF="eval.html#String">String</A> {expr} on all directories in {path}
		and concatenate the results.  Example:
<B>			:echo globpath(&amp;rtp, "syntax/c.vim")</B>
 
		{path} is a comma-separated <A HREF="eval.html#list">list</A> of directory names.  Each
		directory name is prepended to {expr} and expanded like with
		|<A HREF="#glob()">glob()</A>|.  A path separator is inserted when needed.
		To add a comma inside a directory name <A HREF="intro.html#escape">escape</A> <A HREF="motion.html#it">it</A> with a
		<A HREF="intro.html#backslash">backslash</A>.  Note that on <A HREF="os_win32.html#MS-Windows">MS-Windows</A> a directory may have a
		trailing <A HREF="intro.html#backslash">backslash</A>, remove <A HREF="motion.html#it">it</A> if you put a comma after <A HREF="motion.html#it">it</A>.
		If the expansion fails for one of the directories, there is no
		error message.

		Unless the optional {nosuf} argument is given and is |<A HREF="eval.html#TRUE">TRUE</A>|,
		the <A HREF="options.html#'suffixes'">'suffixes'</A> and <A HREF="options.html#'wildignore'">'wildignore'</A> <A HREF="options.html#options">options</A> apply: Names matching
		one of the patterns in <A HREF="options.html#'wildignore'">'wildignore'</A> will be skipped and
		<A HREF="options.html#'suffixes'">'suffixes'</A> affect the ordering of matches.

		When {list} is present and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>| the result is a |<A HREF="eval.html#List">List</A>|
		with all matching files. The advantage of using a <A HREF="eval.html#List">List</A> is, you
		also get filenames containing newlines correctly. Otherwise
		the result is a <A HREF="eval.html#String">String</A> and when there are several matches,
		they are separated by <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A> characters.  Example:
<B>			:echo globpath(&amp;rtp, "syntax/c.vim", 0, 1)</B>
 
		{alllinks} is used <A HREF="motion.html#as">as</A> with |<A HREF="#glob()">glob()</A>|.

		The &quot;**&quot; item can be used to search in a directory tree.
		For example, to find all &quot;README.txt&quot; files in the directories
		in <A HREF="options.html#'runtimepath'">'runtimepath'</A> and below:
<B>			:echo globpath(&amp;rtp, "**/README.txt")</B>
 		Upwards search and limiting the depth of &quot;**&quot; is not
		supported, thus using <A HREF="options.html#'path'">'path'</A> will not always work properly.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetExpr()-&gt;globpath(&amp;rtp)</B>
 

							*<A NAME="has()"></A><B>has()</B>*
has({feature} [, {check}])
		When {check} is omitted or is zero: The result is a <A HREF="eval.html#Number">Number</A>,
		which is 1 if the feature {feature} is supported, zero
		otherwise.  The {feature} argument is a <A HREF="eval.html#string">string</A>, <A HREF="change.html#case">case</A> is
		ignored.  See |<A HREF="#feature-list">feature-list</A>| below.

		When {check} is present and not zero: The result is a <A HREF="eval.html#Number">Number</A>,
		which is 1 if the feature {feature} could ever be supported,
		zero otherwise.  This is useful to check for a typo in
		{feature} and to detect dead code.  Keep in mind that an older
		Vim version will not know about a feature added later and
		features that have been abandoned will not be known by the
		current Vim version.

		Also see |<A HREF="#exists()">exists()</A>| and |<A HREF="#exists_compiled()">exists_compiled()</A>|.

		Note that to skip code that has a <A HREF="syntax.html#syntax">syntax</A> error when the
		feature is not available, Vim may skip the rest of the line
		and miss a following `endif`.  Therefore put the `endif` on a
		separate line:
<B>			if has('feature')</B>
<B>			  let x = this-&gt;breaks-&gt;without-&gt;the-&gt;feature</B>
<B>			endif</B>
 		If the `endif` would be moved to the second line <A HREF="motion.html#as">as</A> &quot;| endif&quot; <A HREF="motion.html#it">it</A>
		would not be found.



has_key({dict}, {key})					*<A NAME="has_key()"></A><B>has_key()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is <A HREF="eval.html#TRUE">TRUE</A> if |<A HREF="eval.html#Dictionary">Dictionary</A>| {dict}
		has an entry with key {key}.  <A HREF="eval.html#FALSE">FALSE</A> otherwise. The {key}
		argument is a <A HREF="eval.html#string">string</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mydict-&gt;has_key(key)</B>


haslocaldir([{winnr} [, {tabnr}]])			*<A NAME="haslocaldir()"></A><B>haslocaldir()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>:
		    1   when the <A HREF="windows.html#window">window</A> has set a local directory via |<A HREF="editing.html#:lcd">:lcd</A>|
		    2   when the <A HREF="tabpage.html#tab-page">tab-page</A> has set a local directory via |<A HREF="editing.html#:tcd">:tcd</A>|
		    0   otherwise.

		Without arguments use the current <A HREF="windows.html#window">window</A>.
		With {winnr} use this <A HREF="windows.html#window">window</A> in the current <A HREF="intro.html#tab">tab</A> page.
		With {winnr} and {tabnr} use the <A HREF="windows.html#window">window</A> in the specified <A HREF="intro.html#tab">tab</A>
		page.
		{winnr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		If {winnr} is -1 <A HREF="motion.html#it">it</A> is ignored and only the <A HREF="tabpage.html#tabpage">tabpage</A> is used.
		Return 0 if the arguments are invalid.
		Examples:
<B>			if haslocaldir() == 1</B>
<B>			  " window local directory case</B>
<B>			elseif haslocaldir() == 2</B>
<B>			  " tab-local directory case</B>
<B>			else</B>
<B>			  " global directory case</B>
<B>			endif</B>

<B>			" current window</B>
<B>			:echo haslocaldir()</B>
<B>			:echo haslocaldir(0)</B>
<B>			:echo haslocaldir(0, 0)</B>
<B>			" window n in current tab page</B>
<B>			:echo haslocaldir(n)</B>
<B>			:echo haslocaldir(n, 0)</B>
<B>			" window n in tab page m</B>
<B>			:echo haslocaldir(n, m)</B>
<B>			" tab page m</B>
<B>			:echo haslocaldir(-1, m)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;haslocaldir()</B>


hasmapto({what} [, {mode} [, {abbr}]])			*<A NAME="hasmapto()"></A><B>hasmapto()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is <A HREF="eval.html#TRUE">TRUE</A> if there is a <A HREF="map.html#mapping">mapping</A>
		that contains {what} in somewhere in the rhs (what <A HREF="motion.html#it">it</A> is
		mapped to) and this <A HREF="map.html#mapping">mapping</A> exists in one of the modes
		indicated by {mode}.
		The arguments {what} and {mode} are strings.
		When {abbr} is there and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>| use <A HREF="map.html#abbreviations">abbreviations</A>
		instead of mappings.  Don't forget to specify <A HREF="insert.html#Insert">Insert</A> and/or
		<A HREF="cmdline.html#Command-line">Command-line</A> mode.
		Both the global mappings and the mappings local to the current
		buffer are checked for a match.
		If no matching <A HREF="map.html#mapping">mapping</A> is found <A HREF="eval.html#FALSE">FALSE</A> is returned.
		The following characters are recognized in {mode}:
			<A HREF="pattern.html#n">n</A>	<A HREF="intro.html#Normal">Normal</A> mode
			<A HREF="visual.html#v">v</A>	<A HREF="visual.html#Visual">Visual</A> and <A HREF="visual.html#Select">Select</A> mode
			<A HREF="change.html#x">x</A>	<A HREF="visual.html#Visual">Visual</A> mode
			<A HREF="change.html#s">s</A>	<A HREF="visual.html#Select">Select</A> mode
			<A HREF="insert.html#o">o</A>	<A HREF="intro.html#Operator-pending">Operator-pending</A> mode
			<A HREF="insert.html#i">i</A>	<A HREF="insert.html#Insert">Insert</A> mode
			<A HREF="motion.html#l">l</A>	Language-Argument (&quot;r&quot;, &quot;<A HREF="motion.html#f">f</A>&quot;, &quot;<A HREF="motion.html#t">t</A>&quot;, etc.)
			<A HREF="change.html#c">c</A>	<A HREF="cmdline.html#Command-line">Command-line</A> mode
		When {mode} is omitted, &quot;nvo&quot; is used.

		This function is useful to check if a <A HREF="map.html#mapping">mapping</A> already exists
		to a function in a Vim <A HREF="usr_41.html#script">script</A>.  Example:
<B>			:if !hasmapto('\ABCdoit')</B>
<B>			:   map &lt;Leader&gt;d \ABCdoit</B>
<B>			:endif</B>
 		This installs the <A HREF="map.html#mapping">mapping</A> to &quot;\ABCdoit&quot; only if there isn't
		already a <A HREF="map.html#mapping">mapping</A> to &quot;\ABCdoit&quot;.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRHS()-&gt;hasmapto()</B>


histadd({history}, {item})				*<A NAME="histadd()"></A><B>histadd()</B>*
		Add the <A HREF="eval.html#String">String</A> {item} to the <A HREF="cmdline.html#history">history</A> {history} which can be

		one of:					*<A NAME="hist-names"></A><B>hist-names</B>*
			&quot;cmd&quot;	 or &quot;<A HREF="cmdline.html#:">:</A>&quot;	  command line <A HREF="cmdline.html#history">history</A>
			&quot;search&quot; or &quot;<A HREF="pattern.html#/">/</A>&quot;   search <A HREF="pattern.html#pattern">pattern</A> <A HREF="cmdline.html#history">history</A>
			&quot;<A HREF="eval.html#expr">expr</A>&quot;	 or &quot;<A HREF="change.html#=">=</A>&quot;   typed <A HREF="eval.html#expression">expression</A> <A HREF="cmdline.html#history">history</A>
			&quot;input&quot;  or &quot;<A HREF="repeat.html#@">@</A>&quot;	  input line <A HREF="cmdline.html#history">history</A>
			&quot;debug&quot;  or &quot;<A HREF="change.html#&gt;">&gt;</A>&quot;   debug command <A HREF="cmdline.html#history">history</A>
			empty		  the current or last used <A HREF="cmdline.html#history">history</A>
		The {history} <A HREF="eval.html#string">string</A> does not need to be the whole name, one
		character is sufficient.
		If {item} does already exist in the <A HREF="cmdline.html#history">history</A>, <A HREF="motion.html#it">it</A> will be
		shifted to become the newest entry.
		The result is a <A HREF="eval.html#Number">Number</A>: <A HREF="eval.html#TRUE">TRUE</A> if the operation was successful,
		otherwise <A HREF="eval.html#FALSE">FALSE</A> is returned.

		Example:
<B>			:call histadd("input", strftime("%Y %b %d"))</B>
<B>			:let date=input("Enter date: ")</B>
 		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetHistory()-&gt;histadd('search')</B>


histdel({history} [, {item}])				*<A NAME="histdel()"></A><B>histdel()</B>*
		Clear {history}, i.e. delete all its entries.  See |<A HREF="#hist-names">hist-names</A>|
		for the possible values of {history}.

		If the parameter {item} evaluates to a <A HREF="eval.html#String">String</A>, <A HREF="motion.html#it">it</A> is used <A HREF="motion.html#as">as</A> a
		regular <A HREF="eval.html#expression">expression</A>.  All entries matching that <A HREF="eval.html#expression">expression</A> will
		be removed from the <A HREF="cmdline.html#history">history</A> (if there are any).
		Upper/lowercase must match, unless &quot;\c&quot; is used |<A HREF="pattern.html#/\c">/\c</A>|.
		If {item} evaluates to a <A HREF="eval.html#Number">Number</A>, <A HREF="motion.html#it">it</A> will be interpreted <A HREF="motion.html#as">as</A>
		an index, see |<A HREF="cmdline.html#:history-indexing">:history-indexing</A>|.  The respective entry will
		be removed if <A HREF="motion.html#it">it</A> exists.

		The result is <A HREF="eval.html#TRUE">TRUE</A> for a successful operation, otherwise <A HREF="eval.html#FALSE">FALSE</A>
		is returned.

		Examples:
		Clear <A HREF="eval.html#expression">expression</A> <A HREF="sponsor.html#register">register</A> <A HREF="cmdline.html#history">history</A>:
<B>			:call histdel("expr")</B>
 
		Remove all entries starting with &quot;*&quot; from the search <A HREF="cmdline.html#history">history</A>:
<B>			:call histdel("/", '^\*')</B>
 
		The following three are equivalent:
<B>			:call histdel("search", histnr("search"))</B>
<B>			:call histdel("search", -1)</B>
<B>			:call histdel("search", '^' .. histget("search", -1) .. '$')</B>
 
		To delete the last search <A HREF="pattern.html#pattern">pattern</A> and use the last-but-one for
		the &quot;<A HREF="pattern.html#n">n</A>&quot; command and <A HREF="options.html#'hlsearch'">'hlsearch'</A>:
<B>			:call histdel("search", -1)</B>
<B>			:let @/ = histget("search", -1)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetHistory()-&gt;histdel()</B>


histget({history} [, {index}])				*<A NAME="histget()"></A><B>histget()</B>*
		The result is a <A HREF="eval.html#String">String</A>, the entry with <A HREF="eval.html#Number">Number</A> {index} from
		{history}.  See |<A HREF="#hist-names">hist-names</A>| for the possible values of
		{history}, and |<A HREF="cmdline.html#:history-indexing">:history-indexing</A>| for {index}.  If there is
		no such entry, an empty <A HREF="eval.html#String">String</A> is returned.  When {index} is
		omitted, the most recent item from the <A HREF="cmdline.html#history">history</A> is used.

		Examples:
		Redo the second last search from <A HREF="cmdline.html#history">history</A>.
<B>			:execute '/' .. histget("search", -2)</B>

 		Define an <A HREF="intro.html#Ex">Ex</A> command &quot;:H {num}&quot; that supports re-execution of
		the {num}th entry from the output of |<A HREF="cmdline.html#:history">:history</A>|.
<B>			:command -nargs=1 H execute histget("cmd", 0+&lt;args&gt;)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetHistory()-&gt;histget()</B>


histnr({history})					*<A NAME="histnr()"></A><B>histnr()</B>*
		The result is the <A HREF="eval.html#Number">Number</A> of the current entry in {history}.
		See |<A HREF="#hist-names">hist-names</A>| for the possible values of {history}.
		If an error occurred, -1 is returned.

		Example:
<B>			:let inp_index = histnr("expr")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetHistory()-&gt;histnr()</B>
 

hlexists({name})					*<A NAME="hlexists()"></A><B>hlexists()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is <A HREF="eval.html#TRUE">TRUE</A> if a highlight group
		called {name} exists.  This is when the group has been
		defined in some way.  Not necessarily when highlighting has
		been defined for <A HREF="motion.html#it">it</A>, <A HREF="motion.html#it">it</A> may also have been used for a <A HREF="syntax.html#syntax">syntax</A>
		item.

							*<A NAME="highlight_exists()"></A><B>highlight_exists()</B>*
		Obsolete name: <A HREF="#highlight_exists()">highlight_exists()</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;hlexists()</B>
 

hlget([{name} [, {resolve}]])				*<A NAME="hlget()"></A><B>hlget()</B>*
		Returns a <A HREF="eval.html#List">List</A> of all the highlight group attributes.  If the
		optional {name} is specified, then returns a <A HREF="eval.html#List">List</A> with only
		the attributes of the specified highlight group.  Returns an
		empty <A HREF="eval.html#List">List</A> if the highlight group {name} is not present.

		If the optional {resolve} argument is set to <A HREF="eval.html#v:true">v:true</A> and the
		highlight group {name} is linked to another group, then the
		link is resolved recursively and the attributes of the
		resolved highlight group are returned.

		Each entry in the returned <A HREF="eval.html#List">List</A> is a <A HREF="eval.html#Dictionary">Dictionary</A> with the
		following items:
			cleared	<A HREF="options.html#boolean">boolean</A> flag, set to <A HREF="eval.html#v:true">v:true</A> if the highlight
				group attributes are cleared or not yet
				specified.  See |<A HREF="syntax.html#highlight-clear">highlight-clear</A>|.
			cterm	cterm attributes. See |<A HREF="syntax.html#highlight-cterm">highlight-cterm</A>|.
			ctermbg	cterm background color.
				See |<A HREF="syntax.html#highlight-ctermbg">highlight-ctermbg</A>|.
			ctermfg	cterm foreground color.
				See |<A HREF="syntax.html#highlight-ctermfg">highlight-ctermfg</A>|.
			ctermul	cterm <A HREF="syntax.html#underline">underline</A> color.  See |<A HREF="syntax.html#highlight-ctermul">highlight-ctermul</A>|.
			default <A HREF="options.html#boolean">boolean</A> flag, set to <A HREF="eval.html#v:true">v:true</A> if the highlight
				group link is a default link. See
				|<A HREF="syntax.html#highlight-default">highlight-default</A>|.
			font	highlight group font.  See |<A HREF="syntax.html#highlight-font">highlight-font</A>|.
			gui	gui attributes. See |<A HREF="syntax.html#highlight-gui">highlight-gui</A>|.
			guibg	gui background color.  See |<A HREF="syntax.html#highlight-guibg">highlight-guibg</A>|.
			guifg	gui foreground color.  See |<A HREF="syntax.html#highlight-guifg">highlight-guifg</A>|.
			guisp	gui special color.  See |<A HREF="syntax.html#highlight-guisp">highlight-guisp</A>|.
			id	highlight group ID.
			linksto	linked highlight group name.
				See |<A HREF="syntax.html#:highlight-link">:highlight-link</A>|.
			name	highlight group name. See |<A HREF="syntax.html#group-name">group-name</A>|.
			start	start <A HREF="terminal.html#terminal">terminal</A> keycode.  See |<A HREF="syntax.html#highlight-start">highlight-start</A>|.
			stop	stop <A HREF="terminal.html#terminal">terminal</A> keycode.  See |<A HREF="syntax.html#highlight-stop">highlight-stop</A>|.
			term	term attributes.  See |<A HREF="syntax.html#highlight-term">highlight-term</A>|.

		The <A HREF="options.html#'term'">'term'</A>, 'cterm' and '<A HREF="gui.html#gui">gui</A>' items in the above <A HREF="eval.html#Dictionary">Dictionary</A>
		have a dictionary value with the following optional <A HREF="options.html#boolean">boolean</A>
		items: '<A HREF="syntax.html#bold">bold</A>', '<A HREF="syntax.html#standout">standout</A>', '<A HREF="syntax.html#underline">underline</A>', '<A HREF="syntax.html#undercurl">undercurl</A>', '<A HREF="syntax.html#italic">italic</A>',
		'reverse', '<A HREF="syntax.html#inverse">inverse</A>' and '<A HREF="syntax.html#strikethrough">strikethrough</A>'.

		Example(s):
<B>			:echo hlget()</B>
<B>			:echo hlget('ModeMsg')</B>
<B>			:echo hlget('Number', v:true)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;hlget()</B>
 

hlset({list})						*<A NAME="hlset()"></A><B>hlset()</B>*
		Creates or modifies the attributes of a <A HREF="eval.html#List">List</A> of highlight
		groups.  Each item in {list} is a dictionary containing the
		attributes of a highlight group. See |<A HREF="#hlget()">hlget()</A>| for the <A HREF="eval.html#list">list</A> of
		supported items in this dictionary.

		In addition to the items described in |<A HREF="#hlget()">hlget()</A>|, the following
		additional items are supported in the dictionary:

			force		<A HREF="options.html#boolean">boolean</A> flag to force the creation of
					a link for an existing highlight group
					with attributes.

		The highlight group is identified using the 'name' item and
		the 'id' item (if supplied) is ignored.  If a highlight group
		with a specified name doesn't exist, then <A HREF="motion.html#it">it</A> is created.
		Otherwise the attributes of an existing highlight group are
		modified.

		If an empty dictionary value is used for the <A HREF="options.html#'term'">'term'</A> or 'cterm'
		or '<A HREF="gui.html#gui">gui</A>' entries, then the corresponding attributes are
		cleared.  If the 'cleared' item is set to <A HREF="eval.html#v:true">v:true</A>, then all the
		attributes of the highlight group are cleared.

		The 'linksto' item can be used to link a highlight group to
		another highlight group.  See |<A HREF="syntax.html#:highlight-link">:highlight-link</A>|.

		Returns zero for success, -1 for failure.

		Example(s):
<B>			" add bold attribute to the Visual highlight group</B>
<B>			:call hlset([#{name: 'Visual',</B>
<B>					\ term: #{reverse: 1 , bold: 1}}])</B>
<B>			:call hlset([#{name: 'Type', guifg: 'DarkGreen'}])</B>
<B>			:let l = hlget()</B>
<B>			:call hlset(l)</B>
<B>			" clear the Search highlight group</B>
<B>			:call hlset([#{name: 'Search', cleared: v:true}])</B>
<B>			" clear the 'term' attributes for a highlight group</B>
<B>			:call hlset([#{name: 'Title', term: {}}])</B>
<B>			" create the MyHlg group linking it to DiffAdd</B>
<B>			:call hlset([#{name: 'MyHlg', linksto: 'DiffAdd'}])</B>
<B>			" remove the MyHlg group link</B>
<B>			:call hlset([#{name: 'MyHlg', linksto: 'NONE'}])</B>
<B>			" clear the attributes and a link</B>
<B>			:call hlset([#{name: 'MyHlg', cleared: v:true,</B>
<B>					\ linksto: 'NONE'}])</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetAttrList()-&gt;hlset()</B>
 

							*<A NAME="hlID()"></A><B>hlID()</B>*
hlID({name})	The result is a <A HREF="eval.html#Number">Number</A>, which is the ID of the highlight group
		with name {name}.  When the highlight group doesn't exist,
		zero is returned.
		This can be used to retrieve information about the highlight
		group.  For example, to get the background color of the
		&quot;Comment&quot; group:
<B>	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")</B>

 							*<A NAME="highlightID()"></A><B>highlightID()</B>*
		Obsolete name: <A HREF="#highlightID()">highlightID()</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;hlID()</B>


<A HREF="#hostname()">hostname()</A>						*<A NAME="hostname()"></A><B>hostname()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is the name of the machine on
		which Vim is currently running.  Machine names greater than
		256 characters long are truncated.


iconv({string}, {from}, {to})				*<A NAME="iconv()"></A><B>iconv()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is the text {string} converted
		from encoding {from} to encoding {to}.
		When the conversion completely fails an empty <A HREF="eval.html#string">string</A> is
		returned.  When some characters could not be converted they
		are replaced with &quot;<A HREF="pattern.html#?">?</A>&quot;.
		The encoding names are whatever the <A HREF="#iconv()">iconv()</A> library function
		can accept, see &quot;:!man 3 iconv&quot;.
		Most conversions require Vim to be compiled with the |<A HREF="various.html#+iconv">+iconv</A>|
		feature.  Otherwise only <A HREF="mbyte.html#UTF-8">UTF-8</A> to latin1 conversion and back
		can be done.
		This can be used to display <A HREF="message.html#messages">messages</A> with special characters,
		no matter what <A HREF="options.html#'encoding'">'encoding'</A> is set to.  Write the message in
		<A HREF="mbyte.html#UTF-8">UTF-8</A> and use:
<B>			echo iconv(utf8_str, "utf-8", &amp;enc)</B>
 		Note that Vim uses <A HREF="mbyte.html#UTF-8">UTF-8</A> for all <A HREF="mbyte.html#Unicode">Unicode</A> encodings, conversion
		from/to UCS-2 is automatically changed to use <A HREF="mbyte.html#UTF-8">UTF-8</A>.  You
		cannot use UCS-2 in a <A HREF="eval.html#string">string</A> anyway, because of the NUL bytes.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;iconv('latin1', 'utf-8')</B>
 

							*<A NAME="indent()"></A><B>indent()</B>*
indent({lnum})	The result is a <A HREF="eval.html#Number">Number</A>, which is indent of line {lnum} in the
		current buffer.  The indent is counted in spaces, the value
		of <A HREF="options.html#'tabstop'">'tabstop'</A> is relevant.  {lnum} is used just like in
		|<A HREF="#getline()">getline()</A>|.
		When {lnum} is invalid -1 is returned.  In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an
		error is given.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;indent()</B>


index({object}, {expr} [, {start} [, {ic}]])			*<A NAME="index()"></A><B>index()</B>*
		If {object} is a |<A HREF="eval.html#List">List</A>| return the lowest index where the item
		has a value equal to {expr}.  There is no automatic
		conversion, so the <A HREF="eval.html#String">String</A> &quot;4&quot; is different from the <A HREF="eval.html#Number">Number</A> 4.
		And the number 4 is different from the <A HREF="eval.html#Float">Float</A> 4.0.  The value
		of <A HREF="options.html#'ignorecase'">'ignorecase'</A> is not used here, <A HREF="change.html#case">case</A> always matters.

		If {object} is |<A HREF="eval.html#Blob">Blob</A>| return the lowest index where the byte
		value is equal to {expr}.

		If {start} is given then start looking at the item with index
		{start} (may be negative for an item relative to the end).
		When {ic} is given and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>|, ignore <A HREF="change.html#case">case</A>.  Otherwise
		<A HREF="change.html#case">case</A> must match.
		-1 is returned when {expr} is not found in {object}.
		Example:
<B>			:let idx = index(words, "the")</B>
<B>			:if index(numbers, 123) &gt;= 0</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetObject()-&gt;index(what)</B>


input({prompt} [, {text} [, {completion}]])		*<A NAME="input()"></A><B>input()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is whatever the user typed on
		the command-line.  The {prompt} argument is either a prompt
		<A HREF="eval.html#string">string</A>, or a blank <A HREF="eval.html#string">string</A> (for no prompt).  A '\n' can be used
		in the prompt to start a new line.
		The highlighting set with |<A HREF="eval.html#:echohl">:echohl</A>| is used for the prompt.
		The input is entered just like a command-line, with the same
		editing commands and mappings.  There is a separate <A HREF="cmdline.html#history">history</A>
		for lines typed for <A HREF="#input()">input()</A>.
		Example:
<B>			:if input("Coffee or beer? ") == "beer"</B>
<B>			:  echo "Cheers!"</B>
<B>			:endif</B>
 
		If the optional {text} argument is present and not empty, this
		is used for the default reply, <A HREF="motion.html#as">as</A> if the user typed this.
		Example:
<B>			:let color = input("Color? ", "white")</B>

 		The optional {completion} argument specifies the type of
		completion supported for the input.  Without <A HREF="motion.html#it">it</A> completion is
		not performed.  The supported completion types are the same <A HREF="motion.html#as">as</A>
		that can be supplied to a user-defined command using the
		&quot;-complete=&quot; argument.  Refer to |<A HREF="map.html#:command-completion">:command-completion</A>| for
		more information.  Example:
<B>			let fname = input("File: ", "", "file")</B>
 
		NOTE: This function must not be used in a <A HREF="starting.html#startup">startup</A> file, for
		the versions that only run in <A HREF="gui.html#GUI">GUI</A> mode (e.g., the <A HREF="os_win32.html#Win32">Win32</A> <A HREF="gui.html#GUI">GUI</A>).
		Note: When <A HREF="#input()">input()</A> is called from within a <A HREF="map.html#mapping">mapping</A> <A HREF="motion.html#it">it</A> will
		consume remaining characters from that <A HREF="map.html#mapping">mapping</A>, because a
		<A HREF="map.html#mapping">mapping</A> is handled like the characters were typed.
		Use |<A HREF="#inputsave()">inputsave()</A>| before <A HREF="#input()">input()</A> and |<A HREF="#inputrestore()">inputrestore()</A>|
		after <A HREF="#input()">input()</A> to avoid that.  Another solution is to avoid
		that further characters follow in the <A HREF="map.html#mapping">mapping</A>, e.g., by using
		|<A HREF="eval.html#:execute">:execute</A>| or |<A HREF="various.html#:normal">:normal</A>|.

		Example with a <A HREF="map.html#mapping">mapping</A>:
<B>			:nmap \x :call GetFoo()&lt;CR&gt;:exe "/" .. Foo&lt;CR&gt;</B>
<B>			:function GetFoo()</B>
<B>			:  call inputsave()</B>
<B>			:  let g:Foo = input("enter search pattern: ")</B>
<B>			:  call inputrestore()</B>
<B>			:endfunction</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPrompt()-&gt;input()</B>


inputdialog({prompt} [, {text} [, {cancelreturn}]])		*<A NAME="inputdialog()"></A><B>inputdialog()</B>*
		Like |<A HREF="#input()">input()</A>|, but when the <A HREF="gui.html#GUI">GUI</A> is running and text dialogs
		are supported, a <A HREF="gui_w32.html#dialog">dialog</A> <A HREF="windows.html#window">window</A> pops up to input the text.
		Example:
<B>		   :let n = inputdialog("value for shiftwidth", shiftwidth())</B>
<B>		   :if n != ""</B>
<B>		   :  let &amp;sw = n</B>
<B>		   :endif</B>
 		When the <A HREF="gui_w32.html#dialog">dialog</A> is cancelled {cancelreturn} is returned.  When
		omitted an empty <A HREF="eval.html#string">string</A> is returned.
		Hitting <A HREF="intro.html#&lt;Enter&gt;">&lt;Enter&gt;</A> works like pressing the OK button.  Hitting
		<A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> works like pressing the Cancel button.
		NOTE: <A HREF="cmdline.html#Command-line">Command-line</A> completion is not supported.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPrompt()-&gt;inputdialog()</B>


inputlist({textlist})					*<A NAME="inputlist()"></A><B>inputlist()</B>*
		{textlist} must be a |<A HREF="eval.html#List">List</A>| of strings.  This |<A HREF="eval.html#List">List</A>| is
		displayed, one <A HREF="eval.html#string">string</A> per line.  The user will be prompted to
		enter a number, which is returned.
		The user can also select an item by clicking on <A HREF="motion.html#it">it</A> with the
		mouse, if the mouse is enabled in the command line ('mouse' is
		&quot;<A HREF="insert.html#a">a</A>&quot; or includes &quot;c&quot;).  For the first <A HREF="eval.html#string">string</A> 0 is returned.
		When clicking above the first item a negative number is
		returned.  When clicking on the prompt one more than the
		length of {textlist} is returned.
		Make sure {textlist} has <A HREF="various.html#less">less</A> than <A HREF="options.html#'lines'">'lines'</A> entries, otherwise
		<A HREF="motion.html#it">it</A> won't work.  It's a good idea to put the entry number at
		the start of the <A HREF="eval.html#string">string</A>.  And put a prompt in the first item.
		Example:
<B>			let color = inputlist(['Select color:', '1. red',</B>
<B>				\ '2. green', '3. blue'])</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetChoices()-&gt;inputlist()</B>


<A HREF="#inputrestore()">inputrestore()</A>						*<A NAME="inputrestore()"></A><B>inputrestore()</B>*
		Restore typeahead that was saved with a previous |<A HREF="#inputsave()">inputsave()</A>|.
		Should be called the same number of times <A HREF="#inputsave()">inputsave()</A> is
		called.  Calling <A HREF="motion.html#it">it</A> more often is harmless though.
		Returns <A HREF="eval.html#TRUE">TRUE</A> when there is nothing to restore, <A HREF="eval.html#FALSE">FALSE</A> otherwise.


<A HREF="#inputsave()">inputsave()</A>						*<A NAME="inputsave()"></A><B>inputsave()</B>*
		Preserve typeahead (also from mappings) and clear <A HREF="motion.html#it">it</A>, so that
		a following prompt gets input from the user.  Should be
		followed by a matching <A HREF="#inputrestore()">inputrestore()</A> after the prompt.  Can
		be used several times, in which <A HREF="change.html#case">case</A> there must be just <A HREF="motion.html#as">as</A>
		many <A HREF="#inputrestore()">inputrestore()</A> calls.
		Returns <A HREF="eval.html#TRUE">TRUE</A> when out of memory, <A HREF="eval.html#FALSE">FALSE</A> otherwise.


inputsecret({prompt} [, {text}])			*<A NAME="inputsecret()"></A><B>inputsecret()</B>*
		This function acts much like the |<A HREF="#input()">input()</A>| function with but
		two exceptions:
		<A HREF="motion.html#a)">a)</A> the user's response will be displayed <A HREF="motion.html#as">as</A> a sequence of
		asterisks (&quot;*&quot;) thereby keeping the entry secret, and
		<A HREF="motion.html#b">b</A>) the user's response will not be recorded on the input
		|<A HREF="cmdline.html#history">history</A>| stack.
		The result is a <A HREF="eval.html#String">String</A>, which is whatever the user actually
		typed on the command-line in response to the issued prompt.
		NOTE: <A HREF="cmdline.html#Command-line">Command-line</A> completion is not supported.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPrompt()-&gt;inputsecret()</B>


insert({object}, {item} [, {idx}])			*<A NAME="insert()"></A><B>insert()</B>*
		When {object} is a |<A HREF="eval.html#List">List</A>| or a |<A HREF="eval.html#Blob">Blob</A>| insert {item} at the start
		of <A HREF="motion.html#it">it</A>.

		If {idx} is specified insert {item} before the item with index
		{idx}.  If {idx} is zero <A HREF="motion.html#it">it</A> goes before the first item, just
		like omitting {idx}.  A negative {idx} is also possible, see
		|<A HREF="eval.html#list-index">list-index</A>|.  -1 inserts just before the last item.

		Returns the resulting |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Blob">Blob</A>|.  Examples:
<B>			:let mylist = insert([2, 3, 5], 1)</B>
<B>			:call insert(mylist, 4, -1)</B>
<B>			:call insert(mylist, 6, len(mylist))</B>
 		The last example can be done simpler with |<A HREF="#add()">add()</A>|.
		Note that when {item} is a |<A HREF="eval.html#List">List</A>| <A HREF="motion.html#it">it</A> is inserted <A HREF="motion.html#as">as</A> a single
		item.  Use |<A HREF="#extend()">extend()</A>| to concatenate |<A HREF="eval.html#Lists">Lists</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;insert(item)</B>


<A HREF="#interrupt()">interrupt()</A>						*<A NAME="interrupt()"></A><B>interrupt()</B>*
		Interrupt <A HREF="usr_41.html#script">script</A> execution.  It works more or <A HREF="various.html#less">less</A> like the
		user typing <A HREF="pattern.html#CTRL-C">CTRL-C</A>, most commands won't execute and <A HREF="intro.html#control">control</A>
		returns to the user.  This is useful to abort execution
		from lower down, e.g. in an <A HREF="autocmd.html#autocommand">autocommand</A>.  Example:
<B>		:function s:check_typoname(file)</B>
<B>		:   if fnamemodify(a:file, ':t') == '['</B>
<B>		:       echomsg 'Maybe typo'</B>
<B>		:       call interrupt()</B>
<B>		:   endif</B>
<B>		:endfunction</B>
<B>		:au BufWritePre * call s:check_typoname(expand('&lt;amatch&gt;'))</B>


invert({expr})						*<A NAME="invert()"></A><B>invert()</B>*
		Bitwise invert.  The argument is converted to a number.  A
		<A HREF="eval.html#List">List</A>, <A HREF="eval.html#Dict">Dict</A> or <A HREF="eval.html#Float">Float</A> argument causes an error.  Example:
<B>			:let bits = invert(bits)</B>
 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			:let bits = bits-&gt;invert()</B>


isabsolutepath({path})					*<A NAME="isabsolutepath()"></A><B>isabsolutepath()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| when {path} is an
		absolute path.
		On <A HREF="os_unix.html#Unix">Unix</A>, a path is considered absolute when <A HREF="motion.html#it">it</A> starts with '<A HREF="pattern.html#/">/</A>'.
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, <A HREF="motion.html#it">it</A> is considered absolute when <A HREF="motion.html#it">it</A> starts with an
		optional drive prefix and is followed by a '\' or '<A HREF="pattern.html#/">/</A>'. UNC paths
		are always absolute.
		Example:
<B>			echo isabsolutepath('/usr/share/')	" 1</B>
<B>			echo isabsolutepath('./foobar')		" 0</B>
<B>			echo isabsolutepath('C:\Windows')	" 1</B>
<B>			echo isabsolutepath('foobar')		" 0</B>
<B>			echo isabsolutepath('\\remote\file')	" 1</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;isabsolutepath()</B>



isdirectory({directory})				*<A NAME="isdirectory()"></A><B>isdirectory()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| when a directory
		with the name {directory} exists.  If {directory} doesn't
		exist, or isn't a directory, the result is |<A HREF="eval.html#FALSE">FALSE</A>|.  {directory}
		is any <A HREF="eval.html#expression">expression</A>, which is used <A HREF="motion.html#as">as</A> a <A HREF="eval.html#String">String</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;isdirectory()</B>


isinf({expr})						*<A NAME="isinf()"></A><B>isinf()</B>*
		Return 1 if {expr} is a positive infinity, or -1 a negative
		infinity, otherwise 0.
<B>			:echo isinf(1.0 / 0.0)</B>
 			1
<B>			:echo isinf(-1.0 / 0.0)</B>
 			-1

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;isinf()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


islocked({expr})					*<A NAME="islocked()"></A><B>islocked()</B>* *<A NAME="E786"></A><B>E786</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is |<A HREF="eval.html#TRUE">TRUE</A>| when {expr} is the
		name of a locked variable.
		The <A HREF="eval.html#string">string</A> argument {expr} must be the name of a variable,
		|<A HREF="eval.html#List">List</A>| item or |<A HREF="eval.html#Dictionary">Dictionary</A>| entry, not the variable itself!
		Example:
<B>			:let alist = [0, ['a', 'b'], 2, 3]</B>
<B>			:lockvar 1 alist</B>
<B>			:echo islocked('alist')		" 1</B>
<B>			:echo islocked('alist[1]')	" 0</B>

 		When {expr} is a variable that does not exist -1 is returned.
		If {expr} uses a range, <A HREF="eval.html#list">list</A> or <A HREF="eval.html#dict">dict</A> index that is out of
		range or does not exist you get an error message.  Use
		|<A HREF="#exists()">exists()</A>| to check for existence.
		In <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> does not work for local function <A HREF="eval.html#variables">variables</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;islocked()</B>


isnan({expr})						*<A NAME="isnan()"></A><B>isnan()</B>*
		Return |<A HREF="eval.html#TRUE">TRUE</A>| if {expr} is a float with value NaN.
<B>			echo isnan(0.0 / 0.0)</B>
 			1

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;isnan()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


items({dict})						*<A NAME="items()"></A><B>items()</B>*
		Return a |<A HREF="eval.html#List">List</A>| with all the key-value pairs of {dict}.  Each
		|<A HREF="eval.html#List">List</A>| item is a <A HREF="eval.html#list">list</A> with two items: the key of a {dict}
		entry and the value of this entry.  The |<A HREF="eval.html#List">List</A>| is in arbitrary
		order.  Also see |<A HREF="#keys()">keys()</A>| and |<A HREF="#values()">values()</A>|.
		Example:
<B>			for [key, value] in items(mydict)</B>
<B>			   echo key .. ': ' .. value</B>
<B>			endfor</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mydict-&gt;items()</B>

job_ functions are documented here: |<A HREF="channel.html#job-functions-details">job-functions-details</A>|



join({list} [, {sep}])					*<A NAME="join()"></A><B>join()</B>*
		Join the items in {list} together into one <A HREF="eval.html#String">String</A>.
		When {sep} is specified <A HREF="motion.html#it">it</A> is put in between the items.  If
		{sep} is omitted a single space is used.
		Note that {sep} is not added at the end.  You might want to
		add <A HREF="motion.html#it">it</A> there too:
<B>			let lines = join(mylist, "\n") .. "\n"</B>
 		<A HREF="eval.html#String">String</A> items are used as-is.  |<A HREF="eval.html#Lists">Lists</A>| and |<A HREF="eval.html#Dictionaries">Dictionaries</A>| are
		converted into a string like with |<A HREF="#string()">string()</A>|.
		The opposite function is |<A HREF="#split()">split()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;join()</B>


js_decode({string})					*<A NAME="js_decode()"></A><B>js_decode()</B>*
		This is similar to |<A HREF="#json_decode()">json_decode()</A>| with these differences:
		- Object key names <A HREF="diff.html#do">do</A> not have to be in <A HREF="quotes.html#quotes">quotes</A>.
		- Strings can be in single <A HREF="quotes.html#quotes">quotes</A>.
		- Empty items in an array (between two commas) are allowed and
		  result in <A HREF="eval.html#v:none">v:none</A> items.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ReadObject()-&gt;js_decode()</B>


js_encode({expr})					*<A NAME="js_encode()"></A><B>js_encode()</B>*
		This is similar to |<A HREF="#json_encode()">json_encode()</A>| with these differences:
		- Object key names are not in <A HREF="quotes.html#quotes">quotes</A>.
		- <A HREF="eval.html#v:none">v:none</A> items in an array result in an empty item between
		  commas.
		For example, the Vim object:
<B><FONT COLOR="PURPLE">			[1,v:none,{"one":1},v:none] </FONT></B>
		Will be encoded <A HREF="motion.html#as">as</A>:
<B><FONT COLOR="PURPLE">			[1,,{one:1},,] </FONT></B>
		While <A HREF="#json_encode()">json_encode()</A> would produce:
<B><FONT COLOR="PURPLE">			[1,null,{"one":1},null] </FONT></B>
		This encoding is valid for JavaScript. It is more efficient
		than JSON, especially when using an array with optional items.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetObject()-&gt;js_encode()</B>


json_decode({string})				*<A NAME="json_decode()"></A><B>json_decode()</B>* *<A NAME="E491"></A><B>E491</B>*
		This parses a JSON formatted <A HREF="eval.html#string">string</A> and returns the equivalent
		in Vim values.  See |<A HREF="#json_encode()">json_encode()</A>| for the relation between
		JSON and Vim values.
		The decoding is permissive:
		- A trailing comma in an array and object is ignored, e.g.
		  &quot;[1, 2, ]&quot; is the same <A HREF="motion.html#as">as</A> &quot;[1, 2]&quot;.
		- <A HREF="eval.html#Integer">Integer</A> keys are accepted in <A HREF="index.html#objects">objects</A>, e.g. {1:2} is the
		  same <A HREF="motion.html#as">as</A> {&quot;1&quot;:2}.
		- More floating point numbers are recognized, e.g. &quot;1.&quot; for
		  &quot;1.0&quot;, or &quot;001.2&quot; for &quot;1.2&quot;. <A HREF="eval.html#Special">Special</A> floating point values
		  &quot;Infinity&quot;, &quot;-Infinity&quot; and &quot;NaN&quot; (capitalization ignored)
		  are accepted.
		- Leading zeroes in integer numbers are ignored, e.g. &quot;012&quot;
		  for &quot;12&quot; or &quot;-012&quot; for &quot;-12&quot;.
		- Capitalization is ignored in literal names <A HREF="vim9.html#null">null</A>, <A HREF="vim9.html#true">true</A> or
		  <A HREF="vim9.html#false">false</A>, e.g. &quot;NULL&quot; for &quot;<A HREF="vim9.html#null">null</A>&quot;, &quot;True&quot; for &quot;<A HREF="vim9.html#true">true</A>&quot;.
		- Control characters U+0000 through U+001F which are not
		  escaped in strings are accepted, e.g. &quot;	&quot; (tab
		  character in <A HREF="eval.html#string">string</A>) for &quot;\t&quot;.
		- An empty JSON <A HREF="eval.html#expression">expression</A> or made of only spaces is accepted
		  and results in <A HREF="eval.html#v:none">v:none</A>.
		- Backslash in an invalid 2-character sequence <A HREF="intro.html#escape">escape</A> is
		  ignored, e.g. &quot;\a&quot; is decoded <A HREF="motion.html#as">as</A> &quot;<A HREF="insert.html#a">a</A>&quot;.
		- A correct surrogate pair in JSON strings should normally be
		  a 12 character sequence such <A HREF="motion.html#as">as</A> &quot;\uD834\uDD1E&quot;, but
		  <A HREF="#json_decode()">json_decode()</A> silently accepts truncated surrogate pairs
		  such <A HREF="motion.html#as">as</A> &quot;\uD834&quot; or &quot;\uD834\u&quot;

								*<A NAME="E938"></A><B>E938</B>*
		A duplicate key in an object, valid in rfc7159, is not
		accepted by <A HREF="#json_decode()">json_decode()</A> <A HREF="motion.html#as">as</A> the result must be a valid Vim
		type, e.g. this fails: {&quot;a&quot;:&quot;b&quot;, &quot;a&quot;:&quot;c&quot;}

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ReadObject()-&gt;json_decode()</B>


json_encode({expr})					*<A NAME="json_encode()"></A><B>json_encode()</B>*
		Encode {expr} <A HREF="motion.html#as">as</A> JSON and return this <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>.
		The encoding is specified in:
		https://tools.ietf.org/html/rfc7159.html

		Vim values are converted <A HREF="motion.html#as">as</A> follows:   *<A NAME="E1161"></A><B>E1161</B>*
		   |<A HREF="eval.html#Number">Number</A>|		decimal number
		   |<A HREF="eval.html#Float">Float</A>|		floating point number
		   <A HREF="eval.html#Float">Float</A> nan		&quot;NaN&quot;
		   <A HREF="eval.html#Float">Float</A> inf		&quot;Infinity&quot;
		   <A HREF="eval.html#Float">Float</A> -inf		&quot;-Infinity&quot;
		   |<A HREF="eval.html#String">String</A>|		in double <A HREF="quotes.html#quotes">quotes</A> (possibly <A HREF="vim9.html#null">null</A>)
		   |<A HREF="eval.html#Funcref">Funcref</A>|		not possible, error
		   |<A HREF="eval.html#List">List</A>|		<A HREF="motion.html#as">as</A> an array (possibly null); when
					used recursively: <A HREF="motion.html#[]">[]</A>
		   |<A HREF="eval.html#Dict">Dict</A>|		<A HREF="motion.html#as">as</A> an object (possibly null); when
					used recursively: <A HREF="intro.html#{}">{}</A>
		   |<A HREF="eval.html#Blob">Blob</A>|		<A HREF="motion.html#as">as</A> an array of the individual bytes
		   <A HREF="eval.html#v:false">v:false</A>		&quot;<A HREF="vim9.html#false">false</A>&quot;
		   <A HREF="eval.html#v:true">v:true</A>		&quot;<A HREF="vim9.html#true">true</A>&quot;
		   <A HREF="eval.html#v:none">v:none</A>		&quot;<A HREF="vim9.html#null">null</A>&quot;
		   <A HREF="eval.html#v:null">v:null</A>		&quot;<A HREF="vim9.html#null">null</A>&quot;
		Note that NaN and Infinity are passed on <A HREF="motion.html#as">as</A> values.  This is
		missing in the JSON standard, but several implementations <A HREF="diff.html#do">do</A>
		allow <A HREF="motion.html#it">it</A>.  If not then you will get an error.
		If a <A HREF="eval.html#string">string</A> contains an illegal character then the replacement
		character 0xfffd is used.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetObject()-&gt;json_encode()</B>


keys({dict})						*<A NAME="keys()"></A><B>keys()</B>*
		Return a |<A HREF="eval.html#List">List</A>| with all the keys of {dict}.  The |<A HREF="eval.html#List">List</A>| is in
		arbitrary order.  Also see |<A HREF="#items()">items()</A>| and |<A HREF="#values()">values()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mydict-&gt;keys()</B>


 							*<A NAME="len()"></A><B>len()</B>* *<A NAME="E701"></A><B>E701</B>*
len({expr})	The result is a <A HREF="eval.html#Number">Number</A>, which is the length of the argument.
		When {expr} is a <A HREF="eval.html#String">String</A> or a <A HREF="eval.html#Number">Number</A> the length in bytes is
		used, <A HREF="motion.html#as">as</A> with |<A HREF="#strlen()">strlen()</A>|.
		When {expr} is a |<A HREF="eval.html#List">List</A>| the number of items in the |<A HREF="eval.html#List">List</A>| is
		returned.
		When {expr} is a |<A HREF="eval.html#Blob">Blob</A>| the number of bytes is returned.
		When {expr} is a |<A HREF="eval.html#Dictionary">Dictionary</A>| the number of entries in the
		|<A HREF="eval.html#Dictionary">Dictionary</A>| is returned.
		Otherwise an error is given and returns zero.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;len()</B>


 						*<A NAME="libcall()"></A><B>libcall()</B>* *<A NAME="E364"></A><B>E364</B>* *<A NAME="E368"></A><B>E368</B>*
libcall({libname}, {funcname}, {argument})
		Call function {funcname} in the run-time library {libname}
		with single argument {argument}.
		This is useful to call <A HREF="eval.html#functions">functions</A> in a library that you
		especially made to be used with Vim.  Since only one argument
		is possible, calling standard library <A HREF="eval.html#functions">functions</A> is rather
		limited.
		The result is the <A HREF="eval.html#String">String</A> returned by the function.  If the
		function returns NULL, this will appear <A HREF="motion.html#as">as</A> an empty <A HREF="eval.html#string">string</A> &quot;&quot;
		to Vim.
		If the function returns a number, use <A HREF="#libcallnr()">libcallnr()</A>!
		If {argument} is a number, <A HREF="motion.html#it">it</A> is passed to the function <A HREF="motion.html#as">as</A> an
		int; if {argument} is a <A HREF="eval.html#string">string</A>, <A HREF="motion.html#it">it</A> is passed <A HREF="motion.html#as">as</A> a
		null-terminated <A HREF="eval.html#string">string</A>.
		This function will fail in |<A HREF="starting.html#restricted-mode">restricted-mode</A>|.

		<A HREF="#libcall()">libcall()</A> allows you to write your own 'plug-in' extensions to
		Vim without having to recompile the program.  It is NOT a
		means to call system <A HREF="eval.html#functions">functions</A>!  If you try to <A HREF="diff.html#do">do</A> so Vim will
		very probably crash.

		For <A HREF="os_win32.html#Win32">Win32</A>, the <A HREF="eval.html#functions">functions</A> you write must be placed in a DLL
		and use the normal C calling convention (NOT Pascal which is
		used in Windows System DLLs).  The function must take exactly
		one parameter, either a character pointer or a long integer,
		and must return a character pointer or NULL.  The character
		pointer returned must point to memory that will remain valid
		after the function has returned (e.g. in static data in the
		DLL).  If <A HREF="motion.html#it">it</A> points to allocated memory, that memory will
		leak away.  Using a static buffer in the function should work,
		it's then freed when the DLL is unloaded.

		WARNING: If the function returns a non-valid pointer, Vim may
		crash!	This also happens if the function returns a number,
		because Vim thinks it's a pointer.
		For <A HREF="os_win32.html#Win32">Win32</A> systems, {libname} should be the filename of the DLL
		without the &quot;.DLL&quot; suffix.  A full path is only required if
		the DLL is not in the usual places.
		For <A HREF="os_unix.html#Unix">Unix</A>: When compiling your own plugins, remember that the
		object code must be compiled <A HREF="motion.html#as">as</A> position-independent ('PIC').
		{only in <A HREF="os_win32.html#Win32">Win32</A> and some <A HREF="os_unix.html#Unix">Unix</A> versions, when the |<A HREF="various.html#+libcall">+libcall</A>|
		feature is present}
		Examples:
<B>			:echo libcall("libc.so", "getenv", "HOME")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		third argument:
<B>			GetValue()-&gt;libcall("libc.so", "getenv")</B>
 

							*<A NAME="libcallnr()"></A><B>libcallnr()</B>*
libcallnr({libname}, {funcname}, {argument})
		Just like |<A HREF="#libcall()">libcall()</A>|, but used for a function that returns an
		int instead of a <A HREF="eval.html#string">string</A>.
		{only in <A HREF="os_win32.html#Win32">Win32</A> on some <A HREF="os_unix.html#Unix">Unix</A> versions, when the |<A HREF="various.html#+libcall">+libcall</A>|
		feature is present}
		Examples:
<B>			:echo libcallnr("/usr/lib/libc.so", "getpid", "")</B>
<B>			:call libcallnr("libc.so", "printf", "Hello World!\n")</B>
<B>			:call libcallnr("libc.so", "sleep", 10)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		third argument:
<B>			GetValue()-&gt;libcallnr("libc.so", "printf")</B>
 


line({expr} [, {winid}])				*<A NAME="line()"></A><B>line()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the line number of the file
		position given with {expr}.  The {expr} argument is a <A HREF="eval.html#string">string</A>.

		The accepted positions are:			 *<A NAME="E1209"></A><B>E1209</B>*
		    .	    the cursor position
		    $	    the last line in the current buffer
		    'x	    position of <A HREF="motion.html#mark">mark</A> <A HREF="change.html#x">x</A> (if the <A HREF="motion.html#mark">mark</A> is not set, 0 is
			    returned)
		    w0	    first line visible in current <A HREF="windows.html#window">window</A> (one if the
			    display isn't updated, e.g. in silent <A HREF="intro.html#Ex">Ex</A> mode)
		    w$	    last line visible in current <A HREF="windows.html#window">window</A> (this is one
			    <A HREF="various.html#less">less</A> than &quot;w0&quot; if no lines are visible)
		    <A HREF="visual.html#v">v</A>	    In <A HREF="visual.html#Visual">Visual</A> mode: the start of the <A HREF="visual.html#Visual">Visual</A> area (the
			    cursor is the end).  When not in <A HREF="visual.html#Visual">Visual</A> mode
			    returns the cursor position.  Differs from |<A HREF="motion.html#'&lt;">'&lt;</A>| in
			    that it's updated right away.
		Note that a <A HREF="motion.html#mark">mark</A> in another file can be used.  The line number
		then applies to another buffer.
		To get the column number use |<A HREF="#col()">col()</A>|.  To get both use
		|<A HREF="#getpos()">getpos()</A>|.
		With the optional {winid} argument the values are obtained for
		that <A HREF="windows.html#window">window</A> instead of the current <A HREF="windows.html#window">window</A>.
		Returns 0 for invalid values of {expr} and {winid}.
		Examples:
<B>			line(".")		line number of the cursor</B>
<B>			line(".", winid)	idem, in window "winid"</B>
<B>			line("'t")		line number of mark t</B>
<B>			line("'" .. marker)	line number of mark marker</B>
 
		To jump to the last known position when opening a file see
		|<A HREF="usr_05.html#last-position-jump">last-position-jump</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetValue()-&gt;line()</B>


line2byte({lnum})					*<A NAME="line2byte()"></A><B>line2byte()</B>*
		Return the byte <A HREF="intro.html#count">count</A> from the start of the buffer for line
		{lnum}.  This includes the end-of-line character, depending on
		the <A HREF="options.html#'fileformat'">'fileformat'</A> option for the current buffer.  The first
		line returns 1. <A HREF="options.html#'encoding'">'encoding'</A> matters, <A HREF="options.html#'fileencoding'">'fileencoding'</A> is ignored.
		This can also be used to get the byte <A HREF="intro.html#count">count</A> for the line just
		below the last line:
<B>			line2byte(line("$") + 1)</B>
 		This is the buffer size plus one.  If <A HREF="options.html#'fileencoding'">'fileencoding'</A> is empty
		<A HREF="motion.html#it">it</A> is the file size plus one.  {lnum} is used like with
		|<A HREF="#getline()">getline()</A>|.  When {lnum} is invalid, or the |<A HREF="various.html#+byte_offset">+byte_offset</A>|
		feature has been disabled at compile time, -1 is returned.
		Also see |<A HREF="#byte2line()">byte2line()</A>|, |<A HREF="motion.html#go">go</A>| and |<A HREF="motion.html#:goto">:goto</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;line2byte()</B>


lispindent({lnum})					*<A NAME="lispindent()"></A><B>lispindent()</B>*
		Get the amount of indent for line {lnum} according the lisp
		indenting rules, <A HREF="motion.html#as">as</A> with <A HREF="options.html#'lisp'">'lisp'</A>.
		The indent is counted in spaces, the value of <A HREF="options.html#'tabstop'">'tabstop'</A> is
		relevant.  {lnum} is used just like in |<A HREF="#getline()">getline()</A>|.
		When {lnum} is invalid -1 is returned.  In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an
		error is given.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;lispindent()</B>


list2blob({list})					*<A NAME="list2blob()"></A><B>list2blob()</B>*
		Return a <A HREF="eval.html#Blob">Blob</A> concatenating all the number values in {list}.
		Examples:
<B>			list2blob([1, 2, 3, 4])	returns 0z01020304</B>
<B>			list2blob([])		returns 0z</B>
 		Returns an empty <A HREF="eval.html#Blob">Blob</A> on error.  If one of the numbers is

		negative or more than 255 error *<A NAME="E1239"></A><B>E1239</B>* is given.

		|<A HREF="#blob2list()">blob2list()</A>| does the opposite.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetList()-&gt;list2blob()</B>


list2str({list} [, {utf8}])				*<A NAME="list2str()"></A><B>list2str()</B>*
		Convert each number in {list} to a character <A HREF="eval.html#string">string</A> can
		concatenate them all.  Examples:
<B>			list2str([32])		returns " "</B>
<B>			list2str([65, 66, 67])	returns "ABC"</B>
 		The same can be done (slowly) with:
<B>			join(map(list, {nr, val -&gt; nr2char(val)}), '')</B>
 		|<A HREF="#str2list()">str2list()</A>| does the opposite.

		When {utf8} is omitted or zero, the current <A HREF="options.html#'encoding'">'encoding'</A> is used.
		When {utf8} is <A HREF="eval.html#TRUE">TRUE</A>, always return <A HREF="mbyte.html#UTF-8">UTF-8</A> characters.
		With <A HREF="mbyte.html#UTF-8">UTF-8</A> composing characters work <A HREF="motion.html#as">as</A> expected:
<B>			list2str([97, 769])	returns "a"</B>
 
		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetList()-&gt;list2str()</B>


listener_add({callback} [, {buf}])			*<A NAME="listener_add()"></A><B>listener_add()</B>*
		Add a callback function that will be invoked when changes have
		been made to buffer {buf}.
		{buf} refers to a buffer name or number. For the accepted
		values, see |<A HREF="#bufname()">bufname()</A>|.  When {buf} is omitted the current
		buffer is used.
		Returns a unique ID that can be passed to |<A HREF="#listener_remove()">listener_remove()</A>|.

		The {callback} is invoked with five arguments:
		    bufnr	the buffer that was changed
		    start	first changed line number
		    end		first line number below the change
		    added	number of lines added, negative if lines were
				deleted
		    changes	a <A HREF="eval.html#List">List</A> of items with details about the changes

		Example:
<B>	    func Listener(bufnr, start, end, added, changes)</B>
<B>	      echo 'lines ' .. a:start .. ' until ' .. a:end .. ' changed'</B>
<B>	    endfunc</B>
<B>	    call listener_add('Listener', bufnr)</B>

 		The <A HREF="eval.html#List">List</A> cannot be changed.  Each item in &quot;changes&quot; is a
		dictionary with these entries:
		    lnum	the first line number of the change
		    end		the first line below the change
		    added	number of lines added; negative if lines were
				deleted
		    col		first column in &quot;lnum&quot; that was affected by
				the change; one if unknown or the whole line
				was affected; this is a byte index, first
				character has a value of one.
		When lines are inserted the values are:
		    lnum	line above which the new line is added
		    end		equal to &quot;lnum&quot;
		    added	number of lines inserted
		    col		1
		When lines are deleted the values are:
		    lnum	the first deleted line
		    end		the line below the first deleted line, before
				the deletion was done
		    added	negative, number of lines deleted
		    col		1
		When lines are changed:
		    lnum	the first changed line
		    end		the line below the last changed line
		    added	0
		    col		first column with a change or 1

		The entries are in the order the changes were made, thus the
		most recent change is at the end.  The line numbers are valid
		when the callback is invoked, but later changes may make them
		invalid, thus keeping a copy for later might not work.

		The {callback} is invoked just before the screen is updated,
		when |<A HREF="#listener_flush()">listener_flush()</A>| is called or when a change is being
		made that changes the line <A HREF="intro.html#count">count</A> in a way <A HREF="motion.html#it">it</A> causes a line
		number in the <A HREF="eval.html#list">list</A> of changes to become invalid.

		The {callback} is invoked with the text locked, see
		|<A HREF="eval.html#textlock">textlock</A>|.  If you <A HREF="diff.html#do">do</A> need to make changes to the buffer, use
		a timer to <A HREF="diff.html#do">do</A> this later |<A HREF="#timer_start()">timer_start()</A>|.

		The {callback} is not invoked when the buffer is first loaded.
		Use the |<A HREF="autocmd.html#BufReadPost">BufReadPost</A>| autocmd event to handle the initial text
		of a buffer.
		The {callback} is also not invoked when the buffer is
		unloaded, use the |<A HREF="autocmd.html#BufUnload">BufUnload</A>| autocmd event for that.

		Returns zero if {callback} or {buf} is invalid.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetBuffer()-&gt;listener_add(callback)</B>


listener_flush([{buf}])					*<A NAME="listener_flush()"></A><B>listener_flush()</B>*
		Invoke listener callbacks for buffer {buf}.  If there are no
		pending changes then no callbacks are invoked.

		{buf} refers to a buffer name or number. For the accepted
		values, see |<A HREF="#bufname()">bufname()</A>|.  When {buf} is omitted the current
		buffer is used.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBuffer()-&gt;listener_flush()</B>


listener_remove({id})					*<A NAME="listener_remove()"></A><B>listener_remove()</B>*
		Remove a listener previously added with <A HREF="#listener_add()">listener_add()</A>.
		Returns <A HREF="eval.html#FALSE">FALSE</A> when {id} could not be found, <A HREF="eval.html#TRUE">TRUE</A> when {id} was
		removed.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetListenerId()-&gt;listener_remove()</B>


<A HREF="#localtime()">localtime()</A>						*<A NAME="localtime()"></A><B>localtime()</B>*
		Return the current time, measured <A HREF="motion.html#as">as</A> seconds since 1st Jan
		1970.  See also |<A HREF="#strftime()">strftime()</A>|, |<A HREF="#strptime()">strptime()</A>| and |<A HREF="#getftime()">getftime()</A>|.



log({expr})						*<A NAME="log()"></A><B>log()</B>*
		Return the natural logarithm (base <A HREF="motion.html#e">e</A>) of {expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|.
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>| in the range
		(0, inf].
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo log(10)</B>
 			2.302585
<B>			:echo log(exp(5))</B>
 			5.0

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;log()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



log10({expr})						*<A NAME="log10()"></A><B>log10()</B>*
		Return the logarithm of Float {expr} to base 10 <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|.
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo log10(1000)</B>
 			3.0
<B>			:echo log10(0.01)</B>
 			-2.0

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;log10()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


luaeval({expr} [, {expr}])					*<A NAME="luaeval()"></A><B>luaeval()</B>*
		Evaluate <A HREF="if_lua.html#Lua">Lua</A> <A HREF="eval.html#expression">expression</A> {expr} and return its result converted
		to Vim data structures. Second {expr} may hold additional
		argument accessible <A HREF="motion.html#as">as</A> _A inside first {expr}.
		Strings are returned <A HREF="motion.html#as">as</A> they are.
		<A HREF="eval.html#Boolean">Boolean</A> <A HREF="index.html#objects">objects</A> are converted to numbers.
		Numbers are converted to |<A HREF="eval.html#Float">Float</A>| values if vim was compiled
		with |<A HREF="various.html#+float">+float</A>| and to numbers otherwise.
		<A HREF="eval.html#Dictionaries">Dictionaries</A> and lists obtained by vim.eval() are returned
		as-is.
		Other <A HREF="index.html#objects">objects</A> are returned <A HREF="motion.html#as">as</A> zero without any <A HREF="message.html#errors">errors</A>.
		See |<A HREF="if_lua.html#lua-luaeval">lua-luaeval</A>| for more details.
		Note that in a `:def` function local <A HREF="eval.html#variables">variables</A> are not visible
		to {expr}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;luaeval()</B>

 		{only available when compiled with the |<A HREF="various.html#+lua">+lua</A>| feature}


map({expr1}, {expr2})					*<A NAME="map()"></A><B>map()</B>*
		{expr1} must be a |<A HREF="eval.html#List">List</A>|, |<A HREF="eval.html#String">String</A>|, |<A HREF="eval.html#Blob">Blob</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>|.
		When {expr1} is a |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>|, replace each
		item in {expr1} with the result of evaluating {expr2}.
		For a |<A HREF="eval.html#Blob">Blob</A>| each byte is replaced.
		For a |<A HREF="eval.html#String">String</A>|, each character, including composing
		characters, is replaced.
		If the item type changes you may want to use |<A HREF="#mapnew()">mapnew()</A>| to
		create a new <A HREF="eval.html#List">List</A> or <A HREF="eval.html#Dictionary">Dictionary</A>.  This is required when using
		<A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A>.

		{expr2} must be a |<A HREF="eval.html#String">String</A>| or |<A HREF="eval.html#Funcref">Funcref</A>|.

		If {expr2} is a |<A HREF="eval.html#String">String</A>|, inside {expr2} |<A HREF="eval.html#v:val">v:val</A>| has the value
		of the current item.  For a |<A HREF="eval.html#Dictionary">Dictionary</A>| |<A HREF="eval.html#v:key">v:key</A>| has the key
		of the current item and for a |<A HREF="eval.html#List">List</A>| |<A HREF="eval.html#v:key">v:key</A>| has the index of
		the current item.  For a |<A HREF="eval.html#Blob">Blob</A>| |<A HREF="eval.html#v:key">v:key</A>| has the index of the
		current byte. For a |<A HREF="eval.html#String">String</A>| |<A HREF="eval.html#v:key">v:key</A>| has the index of the
		current character.
		Example:
<B>			:call map(mylist, '"&gt; " .. v:val .. " &lt;"')</B>
 		This puts &quot;<A HREF="change.html#&gt;">&gt;</A> &quot; before and &quot; &lt;&quot; after each item in &quot;mylist&quot;.

		Note that {expr2} is the result of an <A HREF="eval.html#expression">expression</A> and is then
		used <A HREF="motion.html#as">as</A> an <A HREF="eval.html#expression">expression</A> again.  Often <A HREF="motion.html#it">it</A> is good to use a
		|<A HREF="eval.html#literal-string">literal-string</A>| to avoid having to double backslashes.  You
		still have to double '' <A HREF="quotes.html#quotes">quotes</A>

		If {expr2} is a |<A HREF="eval.html#Funcref">Funcref</A>| <A HREF="motion.html#it">it</A> is called with two arguments:
			1. The key or the index of the current item.
			2. the value of the current item.
		The function must return the new value of the item. Example
		that changes each value by &quot;key-value&quot;:
<B>			func KeyValue(key, val)</B>
<B>			  return a:key .. '-' .. a:val</B>
<B>			endfunc</B>
<B>			call map(myDict, function('KeyValue'))</B>
 		It is shorter when using a YXXYlambda|:
<B>			call map(myDict, {key, val -&gt; key .. '-' .. val})</B>
 		If you <A HREF="diff.html#do">do</A> not use &quot;val&quot; you can leave <A HREF="motion.html#it">it</A> out:
<B>			call map(myDict, {key -&gt; 'item: ' .. key})</B>
 		If you <A HREF="diff.html#do">do</A> not use &quot;key&quot; you can use a short name:
<B>			call map(myDict, {_, val -&gt; 'item: ' .. val})</B>
 
		The operation is done in-place for a |<A HREF="eval.html#List">List</A>| and |<A HREF="eval.html#Dictionary">Dictionary</A>|.
		If you want <A HREF="motion.html#it">it</A> to remain unmodified make a copy first:
<B>			:let tlist = map(copy(mylist), ' v:val .. "\t"')</B>

 		Returns {expr1}, the |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| that was filtered,
		or a new |<A HREF="eval.html#Blob">Blob</A>| or |<A HREF="eval.html#String">String</A>|.
		When an error is encountered while evaluating {expr2} no
		further items in {expr1} are processed.
		When {expr2} is a <A HREF="eval.html#Funcref">Funcref</A> <A HREF="message.html#errors">errors</A> inside a function are ignored,
		unless <A HREF="motion.html#it">it</A> was defined with the &quot;abort&quot; flag.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;map(expr2)</B>



maparg({name} [, {mode} [, {abbr} [, {dict}]]])			*<A NAME="maparg()"></A><B>maparg()</B>*
		When {dict} is omitted or zero: Return the rhs of <A HREF="map.html#mapping">mapping</A>
		{name} in mode {mode}.  The returned <A HREF="eval.html#String">String</A> has special
		characters translated like in the output of the &quot;<A HREF="map.html#:map">:map</A>&quot; command
		listing. When {dict} is <A HREF="eval.html#TRUE">TRUE</A> a dictionary is returned, see
		below. To get a list of all mappings see |<A HREF="#maplist()">maplist()</A>|.

		When there is no <A HREF="map.html#mapping">mapping</A> for {name}, an empty <A HREF="eval.html#String">String</A> is
		returned if {dict} is <A HREF="eval.html#FALSE">FALSE</A>, otherwise returns an empty <A HREF="eval.html#Dict">Dict</A>.
		When the <A HREF="map.html#mapping">mapping</A> for {name} is empty, then &quot;<A HREF="map.html#&lt;Nop&gt;">&lt;Nop&gt;</A>&quot; is
		returned.

		The {name} can have special key names, like in the &quot;<A HREF="map.html#:map">:map</A>&quot;
		command.

		{mode} can be one of these strings:
			&quot;<A HREF="pattern.html#n">n</A>&quot;	<A HREF="intro.html#Normal">Normal</A>
			&quot;<A HREF="visual.html#v">v</A>&quot;	<A HREF="visual.html#Visual">Visual</A> (including <A HREF="visual.html#Select">Select</A>)
			&quot;<A HREF="insert.html#o">o</A>&quot;	<A HREF="intro.html#Operator-pending">Operator-pending</A>
			&quot;<A HREF="insert.html#i">i</A>&quot;	<A HREF="insert.html#Insert">Insert</A>
			&quot;<A HREF="change.html#c">c</A>&quot;	Cmd-line
			&quot;<A HREF="change.html#s">s</A>&quot;	<A HREF="visual.html#Select">Select</A>
			&quot;<A HREF="change.html#x">x</A>&quot;	<A HREF="visual.html#Visual">Visual</A>
			&quot;l&quot;	langmap |<A HREF="map.html#language-mapping">language-mapping</A>|
			&quot;<A HREF="motion.html#t">t</A>&quot;	<A HREF="terminal.html#Terminal-Job">Terminal-Job</A>
			&quot;&quot;	<A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
		When {mode} is omitted, the modes for &quot;&quot; are used.

		When {abbr} is there and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>| use <A HREF="map.html#abbreviations">abbreviations</A>
		instead of mappings.

		When {dict} is there and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>| return a dictionary
		containing all the information of the <A HREF="map.html#mapping">mapping</A> with the

		following items:			*<A NAME="mapping-dict"></A><B>mapping-dict</B>*
		  &quot;lhs&quot;	     The <A HREF="map.html#{lhs}">{lhs}</A> of the <A HREF="map.html#mapping">mapping</A> <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> would be typed
		  &quot;lhsraw&quot;   The <A HREF="map.html#{lhs}">{lhs}</A> of the <A HREF="map.html#mapping">mapping</A> <A HREF="motion.html#as">as</A> raw bytes
		  &quot;lhsrawalt&quot; The <A HREF="map.html#{lhs}">{lhs}</A> of the <A HREF="map.html#mapping">mapping</A> <A HREF="motion.html#as">as</A> raw bytes, alternate
			      form, only present when <A HREF="motion.html#it">it</A> differs from &quot;lhsraw&quot;
		  &quot;rhs&quot;	     The <A HREF="map.html#{rhs}">{rhs}</A> of the <A HREF="map.html#mapping">mapping</A> <A HREF="motion.html#as">as</A> typed.
		  &quot;silent&quot;   1 for a |<A HREF="map.html#:map-silent">:map-silent</A>| <A HREF="map.html#mapping">mapping</A>, else 0.
		  &quot;noremap&quot;  1 if the <A HREF="map.html#{rhs}">{rhs}</A> of the <A HREF="map.html#mapping">mapping</A> is not remappable.
		  &quot;<A HREF="usr_41.html#script">script</A>&quot;   1 if <A HREF="map.html#mapping">mapping</A> was defined with <A HREF="cmdline.html#&lt;script&gt;">&lt;script&gt;</A>.
		  &quot;expr&quot;     1 for an <A HREF="eval.html#expression">expression</A> <A HREF="map.html#mapping">mapping</A> (|<A HREF="map.html#:map-&lt;expr&gt;">:map-&lt;expr&gt;</A>|).
		  &quot;buffer&quot;   1 for a buffer local <A HREF="map.html#mapping">mapping</A> (|<A HREF="map.html#:map-local">:map-local</A>|).
		  &quot;mode&quot;     Modes for which the <A HREF="map.html#mapping">mapping</A> is defined. In
			     addition to the modes mentioned above, these
			     characters will be used:
			     &quot; &quot;     <A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
			     &quot;<A HREF="change.html#!">!</A>&quot;     <A HREF="insert.html#Insert">Insert</A> and Commandline mode
				     (|<A HREF="map.html#mapmode-ic">mapmode-ic</A>|)
		  &quot;sid&quot;	     The <A HREF="usr_41.html#script">script</A> local ID, used for &lt;sid&gt; mappings
			     (|<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>|).
		  &quot;<A HREF="eval.html#scriptversion">scriptversion</A>&quot;  The version of the <A HREF="usr_41.html#script">script</A>.  999999 for
				   |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A>.
		  &quot;lnum&quot;     The line number in &quot;sid&quot;, zero if unknown.
		  &quot;nowait&quot;   Do not wait for other, longer mappings.
			     (|<A HREF="map.html#:map-&lt;nowait&gt;">:map-&lt;nowait&gt;</A>|).
		  &quot;abbr&quot;     True if this is an abbreviation |<A HREF="map.html#abbreviations">abbreviations</A>|.
		  &quot;mode_bits&quot; Vim's internal binary representation of &quot;mode&quot;.
			     |<A HREF="#mapset()">mapset()</A>| ignores this; only &quot;mode&quot; is used.
			     See |<A HREF="#maplist()">maplist()</A>| for usage examples. The values
			     are from src/vim.h and may change in the future.

		The dictionary can be used to restore a <A HREF="map.html#mapping">mapping</A> with
		|<A HREF="#mapset()">mapset()</A>|.

		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to map a key even when it's already
		mapped, and have <A HREF="motion.html#it">it</A> <A HREF="diff.html#do">do</A> the original <A HREF="map.html#mapping">mapping</A> too.  Sketch:
<B>			exe 'nnoremap &lt;Tab&gt; ==' .. maparg('&lt;Tab&gt;', 'n')</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetKey()-&gt;maparg('n')</B>


mapcheck({name} [, {mode} [, {abbr}]])			*<A NAME="mapcheck()"></A><B>mapcheck()</B>*
		Check if there is a <A HREF="map.html#mapping">mapping</A> that matches with {name} in mode
		{mode}.  See |<A HREF="#maparg()">maparg()</A>| for {mode} and special names in
		{name}.
		When {abbr} is there and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>| use <A HREF="map.html#abbreviations">abbreviations</A>
		instead of mappings.
		A match happens with a <A HREF="map.html#mapping">mapping</A> that starts with {name} and
		with a <A HREF="map.html#mapping">mapping</A> which is equal to the start of {name}.

<B><FONT COLOR="PURPLE">			matches mapping "a"	"ab"	"abc" </FONT></B>
		   mapcheck(&quot;a&quot;)	yes	yes	 yes
		   mapcheck(&quot;abc&quot;)	yes	yes	 yes
		   mapcheck(&quot;ax&quot;)	yes	no	 no
		   mapcheck(&quot;b&quot;)	no	no	 no

		The difference with <A HREF="#maparg()">maparg()</A> is that <A HREF="#mapcheck()">mapcheck()</A> finds a
		<A HREF="map.html#mapping">mapping</A> that matches with {name}, while <A HREF="#maparg()">maparg()</A> only finds a
		<A HREF="map.html#mapping">mapping</A> for {name} exactly.
		When there is no <A HREF="map.html#mapping">mapping</A> that starts with {name}, an empty
		<A HREF="eval.html#String">String</A> is returned.  If there is one, the RHS of that <A HREF="map.html#mapping">mapping</A>
		is returned.  If there are several mappings that start with
		{name}, the RHS of one of them is returned.  This will be
		&quot;<A HREF="map.html#&lt;Nop&gt;">&lt;Nop&gt;</A>&quot; if the RHS is empty.
		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to check if a <A HREF="map.html#mapping">mapping</A> can be added
		without being ambiguous.  Example:
<B>	:if mapcheck("_vv") == ""</B>
<B>	:   map _vv :set guifont=7x13&lt;CR&gt;</B>
<B>	:endif</B>
 		This avoids adding the &quot;_vv&quot; <A HREF="map.html#mapping">mapping</A> when there already is a
		<A HREF="map.html#mapping">mapping</A> for &quot;_v&quot; or for &quot;_vvv&quot;.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetKey()-&gt;mapcheck('n')</B>



maplist([{abbr}])					*<A NAME="maplist()"></A><B>maplist()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| of all mappings.  Each List item is a |<A HREF="eval.html#Dict">Dict</A>|,
		the same <A HREF="motion.html#as">as</A> what is returned by |<A HREF="#maparg()">maparg()</A>|, see
		|<A HREF="#mapping-dict">mapping-dict</A>|.  When {abbr} is there and <A HREF="motion.html#it">it</A> is |<A HREF="eval.html#TRUE">TRUE</A>| use
		<A HREF="map.html#abbreviations">abbreviations</A> instead of mappings.

		Example to show all mappings with 'MultiMatch' in rhs:
<B>			vim9script</B>
<B>			echo maplist()-&gt;filter(</B>
<B>				(_, m) =&gt; match(m.rhs, 'MultiMatch') &gt;= 0)</B>
 		It can be tricky to find mappings for particular |<A HREF="map.html#:map-modes">:map-modes</A>|.
		|mapping-dict|'s &quot;mode_bits&quot; can simplify this. For example,
		the mode_bits for <A HREF="intro.html#Normal">Normal</A>, <A HREF="insert.html#Insert">Insert</A> or <A HREF="cmdline.html#Command-line">Command-line</A> modes are
		0x19. To find all the mappings available in those modes you
		can <A HREF="diff.html#do">do</A>:
<B>			vim9script</B>
<B>			var saved_maps = []</B>
<B>			for m in maplist()</B>
<B>			    if and(m.mode_bits, 0x19) != 0</B>
<B>				saved_maps-&gt;add(m)</B>
<B>			    endif</B>
<B>			endfor</B>
<B>			echo saved_maps-&gt;mapnew((_, m) =&gt; m.lhs)</B>
 		The values of the mode_bits are defined in Vim's src/vim.h
		file and they can be discovered at runtime using
		|<A HREF="map.html#:map-commands">:map-commands</A>| and &quot;<A HREF="#maplist()">maplist()</A>&quot;. Example:
<B>			vim9script</B>
<B>			omap xyzzy &lt;Nop&gt;</B>
<B>			var op_bit = maplist()-&gt;filter(</B>
<B>			    (_, m) =&gt; m.lhs == 'xyzzy')[0].mode_bits</B>
<B>			ounmap xyzzy</B>
<B>			echo printf("Operator-pending mode bit: 0x%x", op_bit)</B>



mapnew({expr1}, {expr2})					*<A NAME="mapnew()"></A><B>mapnew()</B>*
		Like |<A HREF="#map()">map()</A>| but instead of <A HREF="change.html#replacing">replacing</A> items in {expr1} a new
		<A HREF="eval.html#List">List</A> or <A HREF="eval.html#Dictionary">Dictionary</A> is created and returned.  {expr1} remains
		unchanged.  Items can still be changed by {expr2}, if you
		don't want that use |<A HREF="#deepcopy()">deepcopy()</A>| first.



mapset({mode}, {abbr}, {dict})					*<A NAME="mapset()"></A><B>mapset()</B>*
mapset({dict})
		Restore a <A HREF="map.html#mapping">mapping</A> from a dictionary, possibly returned by
		|<A HREF="#maparg()">maparg()</A>| or |<A HREF="#maplist()">maplist()</A>|.  A buffer <A HREF="map.html#mapping">mapping</A>, when dict.buffer
		is <A HREF="vim9.html#true">true</A>, is set on the current buffer; <A HREF="motion.html#it">it</A> is up to the caller
		to ensure that the intended buffer is the current buffer. This
		feature allows <A HREF="uganda.html#copying">copying</A> mappings from one buffer to another.
		The dict.mode value may restore a single <A HREF="map.html#mapping">mapping</A> that covers
		more than one mode, like with mode values of '<A HREF="change.html#!">!</A>', '' '', 'nox',

		or '<A HREF="visual.html#v">v</A>'. *<A NAME="E1276"></A><B>E1276</B>*

		In the first form, {mode} and {abbr} should be the same <A HREF="motion.html#as">as</A>

		for the call to |<A HREF="#maparg()">maparg()</A>|. *<A NAME="E460"></A><B>E460</B>*
		{mode} is used to define the mode in which the <A HREF="map.html#mapping">mapping</A> is set,
		not the &quot;mode&quot; entry in {dict}.
		Example for saving and restoring a <A HREF="map.html#mapping">mapping</A>:
<B>			let save_map = maparg('K', 'n', 0, 1)</B>
<B>			nnoremap K somethingelse</B>
<B>			...</B>
<B>			call mapset('n', 0, save_map)</B>
 		Note that if you are going to replace a map in several modes,
		e.g. with `:map!`, you need to save/restore the <A HREF="map.html#mapping">mapping</A> for
		all of them, when they might differ.

		In the second form, with {dict} <A HREF="motion.html#as">as</A> the only argument, mode
		and abbr are taken from the <A HREF="eval.html#dict">dict</A>.
		Example:
<B>			vim9script</B>
<B>			var save_maps = maplist()-&gt;filter(</B>
<B>						(_, m) =&gt; m.lhs == 'K')</B>
<B>			nnoremap K somethingelse</B>
<B>			cnoremap K somethingelse2</B>
<B>			# ...</B>
<B>			unmap K</B>
<B>			for d in save_maps</B>
<B>			    mapset(d)</B>
<B>			endfor</B>



match({expr}, {pat} [, {start} [, {count}]])			*<A NAME="match()"></A><B>match()</B>*
		When {expr} is a |<A HREF="eval.html#List">List</A>| then this returns the index of the
		first item where {pat} matches.  Each item is used <A HREF="motion.html#as">as</A> a
		<A HREF="eval.html#String">String</A>, |<A HREF="eval.html#Lists">Lists</A>| and |<A HREF="eval.html#Dictionaries">Dictionaries</A>| are used <A HREF="motion.html#as">as</A> echoed.

		Otherwise, {expr} is used <A HREF="motion.html#as">as</A> a <A HREF="eval.html#String">String</A>.  The result is a
		<A HREF="eval.html#Number">Number</A>, which gives the index (byte offset) in {expr} where
		{pat} matches.

		A match at the first character or |<A HREF="eval.html#List">List</A>| item returns zero.
		If there is no match -1 is returned.

		For getting submatches see |<A HREF="#matchlist()">matchlist()</A>|.
		Example:
<B>			:echo match("testing", "ing")	" results in 4</B>
<B>			:echo match([1, 'x'], '\a')	" results in 1</B>
 		See |<A HREF="#string-match">string-match</A>| for how {pat} is used.

								*<A NAME="strpbrk()"></A><B>strpbrk()</B>*
		Vim doesn't have a <A HREF="#strpbrk()">strpbrk()</A> function.  But you can <A HREF="diff.html#do">do</A>:
<B>			:let sepidx = match(line, '[.,;: \t]')</B>

 								*<A NAME="strcasestr()"></A><B>strcasestr()</B>*
		Vim doesn't have a <A HREF="#strcasestr()">strcasestr()</A> function.  But you can add
		&quot;\c&quot; to the <A HREF="pattern.html#pattern">pattern</A> to ignore <A HREF="change.html#case">case</A>:
<B>			:let idx = match(haystack, '\cneedle')</B>
 
		If {start} is given, the search starts from byte index
		{start} in a <A HREF="eval.html#String">String</A> or item {start} in a |<A HREF="eval.html#List">List</A>|.
		The result, however, is still the index counted from the
		first character/item.  Example:
<B>			:echo match("testing", "ing", 2)</B>
 		result is again &quot;4&quot;.
<B>			:echo match("testing", "ing", 4)</B>
 		result is again &quot;4&quot;.
<B>			:echo match("testing", "t", 2)</B>
 		result is &quot;3&quot;.
		For a <A HREF="eval.html#String">String</A>, if {start} <A HREF="change.html#&gt;">&gt;</A> 0 then <A HREF="motion.html#it">it</A> is like the <A HREF="eval.html#string">string</A> starts
		{start} bytes later, thus &quot;<A HREF="motion.html#^">^</A>&quot; will match at {start}.  Except
		when {count} is given, then it's like matches before the
		{start} byte are ignored (this is a bit complicated to keep <A HREF="motion.html#it">it</A>
		backwards compatible).
		For a <A HREF="eval.html#String">String</A>, if {start} <A HREF="change.html#&lt;">&lt;</A> 0, <A HREF="motion.html#it">it</A> will be set to 0.  For a <A HREF="eval.html#list">list</A>
		the index is counted from the end.
		If {start} is out of range ({start} <A HREF="change.html#&gt;">&gt;</A> strlen({expr}) for a
		<A HREF="eval.html#String">String</A> or {start} <A HREF="change.html#&gt;">&gt;</A> len({expr}) for a |<A HREF="eval.html#List">List</A>|) -1 is returned.

		When {count} is given use the {count}'th match.  When a match
		is found in a <A HREF="eval.html#String">String</A> the search for the next one starts one
		character further.  Thus this example results in 1:
<B>			echo match("testing", "..", 0, 2)</B>
 		In a |<A HREF="eval.html#List">List</A>| the search continues in the next item.
		Note that when {count} is added the way {start} works changes,
		see above.

		See |<A HREF="pattern.html#pattern">pattern</A>| for the patterns that are accepted.
		The <A HREF="options.html#'ignorecase'">'ignorecase'</A> option is used to set the ignore-caseness of
		the <A HREF="pattern.html#pattern">pattern</A>.  <A HREF="options.html#'smartcase'">'smartcase'</A> is NOT used.  The matching is always
		done like <A HREF="options.html#'magic'">'magic'</A> is set and <A HREF="options.html#'cpoptions'">'cpoptions'</A> is empty.
		Note that a match at the start is preferred, thus when the
		<A HREF="pattern.html#pattern">pattern</A> is using &quot;*&quot; (any number of matches) <A HREF="motion.html#it">it</A> tends to find
		zero matches at the start instead of a number of matches
		further down in the text.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;match('word')</B>
<B>			GetList()-&gt;match('word')</B>
 

				*<A NAME="matchadd()"></A><B>matchadd()</B>* *<A NAME="E290"></A><B>E290</B>* *<A NAME="E798"></A><B>E798</B>* *<A NAME="E799"></A><B>E799</B>* *<A NAME="E801"></A><B>E801</B>* *<A NAME="E957"></A><B>E957</B>*
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
		Defines a <A HREF="pattern.html#pattern">pattern</A> to be highlighted in the current <A HREF="windows.html#window">window</A> (a
		&quot;match&quot;).  It will be highlighted with {group}.  Returns an
		identification number (ID), which can be used to delete the
		match using |<A HREF="#matchdelete()">matchdelete()</A>|.  The ID is bound to the <A HREF="windows.html#window">window</A>.
		Matching is <A HREF="change.html#case">case</A> sensitive and magic, unless <A HREF="change.html#case">case</A> sensitivity
		or magicness are explicitly overridden in {pattern}.  The
		<A HREF="options.html#'magic'">'magic'</A>, <A HREF="options.html#'smartcase'">'smartcase'</A> and <A HREF="options.html#'ignorecase'">'ignorecase'</A> <A HREF="options.html#options">options</A> are not used.
		The &quot;Conceal&quot; value is special, <A HREF="motion.html#it">it</A> causes the match to be
		concealed.

		The optional {priority} argument assigns a priority to the
		match.  A match with a high priority will have its
		highlighting overrule that of a match with a lower priority.
		A priority is specified <A HREF="motion.html#as">as</A> an integer (negative numbers are no
		exception).  If the {priority} argument is not specified, the
		default priority is 10.  The priority of <A HREF="options.html#'hlsearch'">'hlsearch'</A> is zero,
		hence all matches with a priority greater than zero will
		overrule <A HREF="motion.html#it">it</A>.  <A HREF="autocmd.html#Syntax">Syntax</A> highlighting (see <A HREF="options.html#'syntax'">'syntax'</A>) is a separate
		mechanism, and regardless of the chosen priority a match will
		always overrule <A HREF="syntax.html#syntax">syntax</A> highlighting.

		The optional {id} argument allows the request for a specific
		match ID.  If a specified ID is already taken, an error
		message will appear and the match will not be added.  An ID
		is specified <A HREF="motion.html#as">as</A> a positive integer (zero excluded).  IDs 1, 2
		and 3 are reserved for |<A HREF="pattern.html#:match">:match</A>|, |<A HREF="pattern.html#:2match">:2match</A>| and |<A HREF="pattern.html#:3match">:3match</A>|,
		respectively.  If the {id} argument is not specified or -1,
		|<A HREF="#matchadd()">matchadd()</A>| automatically chooses a free ID.

		The optional {dict} argument allows for further custom
		values. Currently this is used to specify a match specific
		<A HREF="syntax.html#conceal">conceal</A> character that will be shown for |<A HREF="syntax.html#hl-Conceal">hl-Conceal</A>|
		highlighted matches. The <A HREF="eval.html#dict">dict</A> can have the following members:

			<A HREF="syntax.html#conceal">conceal</A>	    <A HREF="eval.html#Special">Special</A> character to show instead of the
				    match (only for |<A HREF="syntax.html#hl-Conceal">hl-Conceal</A>| highlighted
				    matches, see |<A HREF="syntax.html#:syn-cchar">:syn-cchar</A>|)
			<A HREF="windows.html#window">window</A>	    Instead of the current <A HREF="windows.html#window">window</A> use the
				    <A HREF="windows.html#window">window</A> with this number or <A HREF="windows.html#window">window</A> ID.

		The number of matches is not limited, <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> is the <A HREF="change.html#case">case</A> with
		the |<A HREF="pattern.html#:match">:match</A>| commands.

		Returns -1 on error.

		Example:
<B>			:highlight MyGroup ctermbg=green guibg=green</B>
<B>			:let m = matchadd("MyGroup", "TODO")</B>
 		Deletion of the <A HREF="pattern.html#pattern">pattern</A>:
<B>			:call matchdelete(m)</B>

 		A <A HREF="eval.html#list">list</A> of matches defined by |<A HREF="#matchadd()">matchadd()</A>| and |<A HREF="pattern.html#:match">:match</A>| are
		available from |<A HREF="#getmatches()">getmatches()</A>|.  All matches can be deleted in
		one operation by |<A HREF="#clearmatches()">clearmatches()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetGroup()-&gt;matchadd('TODO')</B>
 

							*<A NAME="matchaddpos()"></A><B>matchaddpos()</B>*
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
		Same <A HREF="motion.html#as">as</A> |<A HREF="#matchadd()">matchadd()</A>|, but requires a <A HREF="eval.html#list">list</A> of positions {pos}
		instead of a <A HREF="pattern.html#pattern">pattern</A>. This command is faster than |<A HREF="#matchadd()">matchadd()</A>|
		because <A HREF="motion.html#it">it</A> does not require to handle regular expressions and
		sets buffer line boundaries to redraw screen. It is supposed
		to be used when fast match additions and deletions are
		required, for example to highlight matching parentheses.

		{pos} is a <A HREF="eval.html#list">list</A> of positions.  Each position can be one of
		these:
		- A number.  This whole line will be highlighted.  The first
		  line has number 1.
		- A <A HREF="eval.html#list">list</A> with one number, e.g., [23]. The whole line with this
		  number will be highlighted.
		- A <A HREF="eval.html#list">list</A> with two numbers, e.g., [23, 11]. The first number is
		  the line number, the second one is the column number (first
		  column is 1, the value must correspond to the byte index <A HREF="motion.html#as">as</A>
		  |<A HREF="#col()">col()</A>| would return).  The character at this position will
		  be highlighted.
		- A <A HREF="eval.html#list">list</A> with three numbers, e.g., [23, 11, 3]. As above, but
		  the third number gives the length of the highlight in bytes.

		The maximum number of positions in {pos} is 8.

		Returns -1 on error.

		Example:
<B>			:highlight MyGroup ctermbg=green guibg=green</B>
<B>			:let m = matchaddpos("MyGroup", [[23, 24], 34])</B>
 		Deletion of the <A HREF="pattern.html#pattern">pattern</A>:
<B>			:call matchdelete(m)</B>

 		Matches added by |<A HREF="#matchaddpos()">matchaddpos()</A>| are returned by
		|<A HREF="#getmatches()">getmatches()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetGroup()-&gt;matchaddpos([23, 11])</B>


matcharg({nr})							*<A NAME="matcharg()"></A><B>matcharg()</B>*
		Selects the {nr} match item, <A HREF="motion.html#as">as</A> set with a |<A HREF="pattern.html#:match">:match</A>|,
		|<A HREF="pattern.html#:2match">:2match</A>| or |<A HREF="pattern.html#:3match">:3match</A>| command.
		Return a |<A HREF="eval.html#List">List</A>| with two elements:
			The name of the highlight group used
			The <A HREF="pattern.html#pattern">pattern</A> used.
		When {nr} is not 1, 2 or 3 returns an empty |<A HREF="eval.html#List">List</A>|.
		When there is no match item set returns ['', ''].
		This is useful to save and restore a |<A HREF="pattern.html#:match">:match</A>|.
		Highlighting matches using the |<A HREF="pattern.html#:match">:match</A>| commands are limited
		to three matches. |<A HREF="#matchadd()">matchadd()</A>| does not have this limitation.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMatch()-&gt;matcharg()</B>


matchdelete({id} [, {win})		       *<A NAME="matchdelete()"></A><B>matchdelete()</B>* *<A NAME="E802"></A><B>E802</B>* *<A NAME="E803"></A><B>E803</B>*
		Deletes a match with ID {id} previously defined by |<A HREF="#matchadd()">matchadd()</A>|
		or one of the |<A HREF="pattern.html#:match">:match</A>| commands.  Returns 0 if successful,
		otherwise -1.  See example for |<A HREF="#matchadd()">matchadd()</A>|.  All matches can
		be deleted in one operation by |<A HREF="#clearmatches()">clearmatches()</A>|.
		If {win} is specified, use the <A HREF="windows.html#window">window</A> with this number or
		<A HREF="windows.html#window">window</A> ID instead of the current <A HREF="windows.html#window">window</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMatch()-&gt;matchdelete()</B>


matchend({expr}, {pat} [, {start} [, {count}]])			*<A NAME="matchend()"></A><B>matchend()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#match()">match()</A>|, but return the index of first character
		after the match.  Example:
<B>			:echo matchend("testing", "ing")</B>
 		results in &quot;7&quot;.

							*<A NAME="strspn()"></A><B>strspn()</B>* *<A NAME="strcspn()"></A><B>strcspn()</B>*
		Vim doesn't have a <A HREF="#strspn()">strspn()</A> or <A HREF="#strcspn()">strcspn()</A> function, but you can
		<A HREF="diff.html#do">do</A> <A HREF="motion.html#it">it</A> with <A HREF="#matchend()">matchend()</A>:
<B>			:let span = matchend(line, '[a-zA-Z]')</B>
<B>			:let span = matchend(line, '[^a-zA-Z]')</B>
 		Except that -1 is returned when there are no matches.

		The {start}, if given, has the same meaning <A HREF="motion.html#as">as</A> for |<A HREF="#match()">match()</A>|.
<B>			:echo matchend("testing", "ing", 2)</B>
 		results in &quot;7&quot;.
<B>			:echo matchend("testing", "ing", 5)</B>
 		result is &quot;-1&quot;.
		When {expr} is a |<A HREF="eval.html#List">List</A>| the result is equal to |<A HREF="#match()">match()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;matchend('word')</B>



matchfuzzy({list}, {str} [, {dict}])			*<A NAME="matchfuzzy()"></A><B>matchfuzzy()</B>*
		If {list} is a <A HREF="eval.html#list">list</A> of strings, then returns a |<A HREF="eval.html#List">List</A>| with all
		the strings in {list} that fuzzy match {str}. The strings in
		the returned <A HREF="eval.html#list">list</A> are sorted based on the matching score.

		The optional {dict} argument always supports the following
		items:
		    matchseq	When this item is present return only matches
				that contain the characters in {str} in the
				given sequence.
		    limit	Maximum number of matches in {list} to be
				returned.  Zero means no limit.

		If {list} is a <A HREF="eval.html#list">list</A> of dictionaries, then the optional {dict}
		argument supports the following additional items:
		    key		Key of the item which is fuzzy matched against
				{str}. The value of this item should be a
				<A HREF="eval.html#string">string</A>.
		    text_cb	|<A HREF="eval.html#Funcref">Funcref</A>| that will be called for every item
				in {list} to get the text for fuzzy matching.
				This should accept a dictionary item <A HREF="motion.html#as">as</A> the
				argument and return the text for that item to
				use for fuzzy matching.

		{str} is treated <A HREF="motion.html#as">as</A> a literal <A HREF="eval.html#string">string</A> and regular <A HREF="eval.html#expression">expression</A>
		matching is NOT supported.  The maximum supported {str} length
		is 256.

		When {str} has multiple words each separated by white space,
		then the <A HREF="eval.html#list">list</A> of strings that have all the words is returned.

		If there are no matching strings or there is an error, then an
		empty <A HREF="eval.html#list">list</A> is returned. If length of {str} is greater than
		256, then returns an empty <A HREF="eval.html#list">list</A>.

		When {limit} is given, <A HREF="#matchfuzzy()">matchfuzzy()</A> will find up to this
		number of matches in {list} and return them in sorted order.

		Refer to |<A HREF="pattern.html#fuzzy-matching">fuzzy-matching</A>| for more information about fuzzy
		matching strings.

		Example:
<B>		   :echo matchfuzzy(["clay", "crow"], "cay")</B>
 		results in [&quot;clay&quot;].
<B>		   :echo getbufinfo()-&gt;map({_, v -&gt; v.name})-&gt;matchfuzzy("ndl")</B>
 		results in a <A HREF="eval.html#list">list</A> of buffer names fuzzy matching &quot;ndl&quot;.
<B>		   :echo getbufinfo()-&gt;matchfuzzy("ndl", {'key' : 'name'})</B>
 		results in a <A HREF="eval.html#list">list</A> of buffer information dicts with buffer
		names fuzzy matching &quot;ndl&quot;.
<B>		   :echo getbufinfo()-&gt;matchfuzzy("spl",</B>
<B>						\ {'text_cb' : {v -&gt; v.name}})</B>
 		results in a <A HREF="eval.html#list">list</A> of buffer information dicts with buffer
		names fuzzy matching &quot;spl&quot;.
<B>		   :echo v:oldfiles-&gt;matchfuzzy("test")</B>
 		results in a <A HREF="eval.html#list">list</A> of file names fuzzy matching &quot;test&quot;.
<B>		   :let l = readfile("buffer.c")-&gt;matchfuzzy("str")</B>
 		results in a <A HREF="eval.html#list">list</A> of lines in &quot;buffer.c&quot; fuzzy matching &quot;str&quot;.
<B>		   :echo ['one two', 'two one']-&gt;matchfuzzy('two one')</B>
 		results in ['two one', 'one two'].
<B>		   :echo ['one two', 'two one']-&gt;matchfuzzy('two one',</B>
<B>						\ {'matchseq': 1})</B>
 		results in ['two one'].


matchfuzzypos({list}, {str} [, {dict}])			*<A NAME="matchfuzzypos()"></A><B>matchfuzzypos()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#matchfuzzy()">matchfuzzy()</A>|, but returns the <A HREF="eval.html#list">list</A> of matched
		strings, the <A HREF="eval.html#list">list</A> of character positions where characters
		in {str} matches and a <A HREF="eval.html#list">list</A> of matching scores.  You can
		use |<A HREF="#byteidx()">byteidx()</A>| to convert a character position to a byte
		position.

		If {str} matches multiple times in a <A HREF="eval.html#string">string</A>, then only the
		positions for the best match is returned.

		If there are no matching strings or there is an error, then a
		<A HREF="eval.html#list">list</A> with three empty <A HREF="eval.html#list">list</A> items is returned.

		Example:
<B>			:echo matchfuzzypos(['testing'], 'tsg')</B>
 		results in [['testing'], [[0, 2, 6]], [99]]
<B>			:echo matchfuzzypos(['clay', 'lacy'], 'la')</B>
 		results in [['lacy', 'clay'], [[0, 1], [1, 2]], [153, 133]]
<B>			:echo [{'text': 'hello', 'id' : 10}]-&gt;matchfuzzypos('ll', {'key' : 'text'})</B>
 		results in [[{'id': 10, 'text': 'hello'}], [[2, 3]], [127]]


matchlist({expr}, {pat} [, {start} [, {count}]])		*<A NAME="matchlist()"></A><B>matchlist()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#match()">match()</A>|, but return a |<A HREF="eval.html#List">List</A>|.  The first item in the
		<A HREF="eval.html#list">list</A> is the matched <A HREF="eval.html#string">string</A>, same <A HREF="motion.html#as">as</A> what <A HREF="#matchstr()">matchstr()</A> would
		return.  Following items are submatches, like &quot;\1&quot;, &quot;\2&quot;, etc.
		in |<A HREF="change.html#:substitute">:substitute</A>|.  When an optional submatch didn't match an
		empty <A HREF="eval.html#string">string</A> is used.  Example:
<B>			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')</B>
 		Results in: ['acd', '<A HREF="insert.html#a">a</A>', <A HREF="motion.html#''">''</A>, '<A HREF="change.html#c">c</A>', '<A HREF="change.html#d">d</A>', <A HREF="motion.html#''">''</A>, <A HREF="motion.html#''">''</A>, <A HREF="motion.html#''">''</A>, <A HREF="motion.html#''">''</A>, '']
		When there is no match an empty <A HREF="eval.html#list">list</A> is returned.

		You can pass in a <A HREF="eval.html#List">List</A>, but that is not very useful.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;matchlist('word')</B>


matchstr({expr}, {pat} [, {start} [, {count}]])			*<A NAME="matchstr()"></A><B>matchstr()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#match()">match()</A>|, but return the matched <A HREF="eval.html#string">string</A>.  Example:
<B>			:echo matchstr("testing", "ing")</B>
 		results in &quot;ing&quot;.
		When there is no match &quot;&quot; is returned.
		The {start}, if given, has the same meaning <A HREF="motion.html#as">as</A> for |<A HREF="#match()">match()</A>|.
<B>			:echo matchstr("testing", "ing", 2)</B>
 		results in &quot;ing&quot;.
<B>			:echo matchstr("testing", "ing", 5)</B>
 		result is &quot;&quot;.
		When {expr} is a |<A HREF="eval.html#List">List</A>| then the matching item is returned.
		The type isn't changed, it's not necessarily a <A HREF="eval.html#String">String</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;matchstr('word')</B>


matchstrpos({expr}, {pat} [, {start} [, {count}]])		*<A NAME="matchstrpos()"></A><B>matchstrpos()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#matchstr()">matchstr()</A>|, but return the matched <A HREF="eval.html#string">string</A>, the start
		position and the end position of the match.  Example:
<B>			:echo matchstrpos("testing", "ing")</B>
 		results in [&quot;ing&quot;, 4, 7].
		When there is no match [&quot;&quot;, -1, -1] is returned.
		The {start}, if given, has the same meaning <A HREF="motion.html#as">as</A> for |<A HREF="#match()">match()</A>|.
<B>			:echo matchstrpos("testing", "ing", 2)</B>
 		results in [&quot;ing&quot;, 4, 7].
<B>			:echo matchstrpos("testing", "ing", 5)</B>
 		result is [&quot;&quot;, -1, -1].
		When {expr} is a |<A HREF="eval.html#List">List</A>| then the matching item, the index
		of first item where {pat} matches, the start position and the
		end position of the match are returned.
<B>			:echo matchstrpos([1, '__x'], '\a')</B>
 		result is [&quot;x&quot;, 1, 2, 3].
		The type isn't changed, it's not necessarily a <A HREF="eval.html#String">String</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;matchstrpos('word')</B>
 


							*<A NAME="max()"></A><B>max()</B>*
max({expr})	Return the maximum value of all items in {expr}. Example:
<B>			echo max([apples, pears, oranges])</B>

 		{expr} can be a |<A HREF="eval.html#List">List</A>| or a |<A HREF="eval.html#Dictionary">Dictionary</A>|.  For a Dictionary,
		<A HREF="motion.html#it">it</A> returns the maximum of all values in the <A HREF="eval.html#Dictionary">Dictionary</A>.
		If {expr} is neither a <A HREF="eval.html#List">List</A> nor a <A HREF="eval.html#Dictionary">Dictionary</A>, or one of the
		items in {expr} cannot be used <A HREF="motion.html#as">as</A> a <A HREF="eval.html#Number">Number</A> this results in
		an error.  An empty |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| results in zero.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;max()</B>



menu_info({name} [, {mode}])				*<A NAME="menu_info()"></A><B>menu_info()</B>*
		Return information about the specified menu {name} in
		mode {mode}. The menu name should be specified without the
		shortcut character ('&amp;'). If {name} is &quot;&quot;, then the top-level
		menu names are returned.

		{mode} can be one of these strings:
			&quot;<A HREF="pattern.html#n">n</A>&quot;	<A HREF="intro.html#Normal">Normal</A>
			&quot;<A HREF="visual.html#v">v</A>&quot;	<A HREF="visual.html#Visual">Visual</A> (including <A HREF="visual.html#Select">Select</A>)
			&quot;<A HREF="insert.html#o">o</A>&quot;	<A HREF="intro.html#Operator-pending">Operator-pending</A>
			&quot;<A HREF="insert.html#i">i</A>&quot;	<A HREF="insert.html#Insert">Insert</A>
			&quot;<A HREF="change.html#c">c</A>&quot;	Cmd-line
			&quot;<A HREF="change.html#s">s</A>&quot;	<A HREF="visual.html#Select">Select</A>
			&quot;<A HREF="change.html#x">x</A>&quot;	<A HREF="visual.html#Visual">Visual</A>
			&quot;<A HREF="motion.html#t">t</A>&quot;	<A HREF="terminal.html#Terminal-Job">Terminal-Job</A>
			&quot;&quot;	<A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
			&quot;<A HREF="change.html#!">!</A>&quot;	<A HREF="insert.html#Insert">Insert</A> and Cmd-line
		When {mode} is omitted, the modes for &quot;&quot; are used.

		Returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| containing the following items:
		  accel		menu item accelerator text |<A HREF="gui.html#menu-text">menu-text</A>|
		  display	display name (name without '<A HREF="change.html#&amp;">&amp;</A>')
		  enabled	<A HREF="eval.html#v:true">v:true</A> if this menu item is enabled
				Refer to |<A HREF="gui.html#:menu-enable">:menu-enable</A>|
		  icon		name of the icon file (for toolbar)
				|<A HREF="gui.html#toolbar-icon">toolbar-icon</A>|
		  iconidx	index of a built-in icon
		  modes		modes for which the menu is defined. In
				addition to the modes mentioned above, these
				characters will be used:
				&quot; &quot;	<A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
		  name		menu item name.
		  noremenu	<A HREF="eval.html#v:true">v:true</A> if the <A HREF="map.html#{rhs}">{rhs}</A> of the menu item is not
				remappable else <A HREF="eval.html#v:false">v:false</A>.
		  priority	menu order priority |<A HREF="gui.html#menu-priority">menu-priority</A>|
		  rhs		right-hand-side of the menu item. The returned
				<A HREF="eval.html#string">string</A> has special characters translated like
				in the output of the &quot;<A HREF="gui.html#:menu">:menu</A>&quot; command listing.
				When the <A HREF="map.html#{rhs}">{rhs}</A> of a menu item is empty, then
				&quot;<A HREF="map.html#&lt;Nop&gt;">&lt;Nop&gt;</A>&quot; is returned.
		  <A HREF="usr_41.html#script">script</A>	<A HREF="eval.html#v:true">v:true</A> if <A HREF="map.html#script-local">script-local</A> remapping of <A HREF="map.html#{rhs}">{rhs}</A> is
				allowed else <A HREF="eval.html#v:false">v:false</A>.  See |<A HREF="gui.html#:menu-script">:menu-script</A>|.
		  shortcut	shortcut key (character after '<A HREF="change.html#&amp;">&amp;</A>' in
				the menu name) |<A HREF="gui.html#menu-shortcut">menu-shortcut</A>|
		  silent	<A HREF="eval.html#v:true">v:true</A> if the menu item is created
				with &lt;silent&gt; argument |<A HREF="gui.html#:menu-silent">:menu-silent</A>|
		  submenus	|<A HREF="eval.html#List">List</A>| containing the names of
				all the submenus.  Present only if the menu
				item has submenus.

		Returns an empty dictionary if the menu item is not found.

		Examples:
<B>			:echo menu_info('Edit.Cut')</B>
<B>			:echo menu_info('File.Save', 'n')</B>

<B>			" Display the entire menu hierarchy in a buffer</B>
<B>			func ShowMenu(name, pfx)</B>
<B>			  let m = menu_info(a:name)</B>
<B>			  call append(line('$'), a:pfx .. m.display)</B>
<B>			  for child in m-&gt;get('submenus', [])</B>
<B>			    call ShowMenu(a:name .. '.' .. escape(child, '.'),</B>
<B>							\ a:pfx .. '    ')</B>
<B>			  endfor</B>
<B>			endfunc</B>
<B>			new</B>
<B>			for topmenu in menu_info('').submenus</B>
<B>			  call ShowMenu(topmenu, '')</B>
<B>			endfor</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMenuName()-&gt;menu_info('v')</B>



 							*<A NAME="min()"></A><B>min()</B>*
min({expr})	Return the minimum value of all items in {expr}. Example: 
<B>			echo min([apples, pears, oranges])</B>

 		{expr} can be a |<A HREF="eval.html#List">List</A>| or a |<A HREF="eval.html#Dictionary">Dictionary</A>|.  For a Dictionary,
		<A HREF="motion.html#it">it</A> returns the minimum of all values in the <A HREF="eval.html#Dictionary">Dictionary</A>.
		If {expr} is neither a <A HREF="eval.html#List">List</A> nor a <A HREF="eval.html#Dictionary">Dictionary</A>, or one of the
		items in {expr} cannot be used <A HREF="motion.html#as">as</A> a <A HREF="eval.html#Number">Number</A> this results in
		an error.  An empty |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| results in zero.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;min()</B>


 							*<A NAME="mkdir()"></A><B>mkdir()</B>* *<A NAME="E739"></A><B>E739</B>*
mkdir({name} [, {path} [, {prot}]])
		Create directory {name}.

		If {path} is &quot;<A HREF="change.html#p">p</A>&quot; then intermediate directories are created <A HREF="motion.html#as">as</A>
		necessary.  Otherwise <A HREF="motion.html#it">it</A> must be &quot;&quot;.

		If {prot} is given <A HREF="motion.html#it">it</A> is used to set the protection bits of
		the new directory.  The default is 0o755 (rwxr-xr-x: r/w for
		the user, readable for others).  Use 0o700 to make <A HREF="motion.html#it">it</A>
		unreadable for others.  This is only used for the last part of
		{name}.  Thus if you create /tmp/foo/bar then /tmp/foo will be
		created with 0o755.
		Example:
<B>			:call mkdir($HOME .. "/tmp/foo/bar", "p", 0o700)</B>

 		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.

		There is no error if the directory already exists and the &quot;<A HREF="change.html#p">p</A>&quot;
		flag is passed (since patch 8.0.1708).  However, without the
		&quot;<A HREF="change.html#p">p</A>&quot; option the call will fail.

		The function result is a <A HREF="eval.html#Number">Number</A>, which is <A HREF="eval.html#TRUE">TRUE</A> if the call was
		successful or <A HREF="eval.html#FALSE">FALSE</A> if the directory creation failed or partly
		failed.

		Not available on all systems.  To check use:
<B>			:if exists("*mkdir")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;mkdir()</B>
 

							*<A NAME="mode()"></A><B>mode()</B>*
mode([expr])	Return a <A HREF="eval.html#string">string</A> that indicates the current mode.
		If [expr] is supplied and <A HREF="motion.html#it">it</A> evaluates to a non-zero <A HREF="eval.html#Number">Number</A> or
		a non-empty <A HREF="eval.html#String">String</A> (|<A HREF="eval.html#non-zero-arg">non-zero-arg</A>|), then the full mode is
		returned, otherwise only the first <A HREF="print.html#letter">letter</A> is returned.
		Also see |<A HREF="#state()">state()</A>|.

		   <A HREF="pattern.html#n">n</A>	    <A HREF="intro.html#Normal">Normal</A>
		   no	    <A HREF="intro.html#Operator-pending">Operator-pending</A>
		   nov	    <A HREF="intro.html#Operator-pending">Operator-pending</A> (forced <A HREF="motion.html#characterwise">characterwise</A> |<A HREF="motion.html#o_v">o_v</A>|)
		   noV	    <A HREF="intro.html#Operator-pending">Operator-pending</A> (forced <A HREF="motion.html#linewise">linewise</A> |<A HREF="motion.html#o_V">o_V</A>|)
		   noCTRL-V <A HREF="intro.html#Operator-pending">Operator-pending</A> (forced blockwise |<A HREF="motion.html#o_CTRL-V">o_CTRL-V</A>|);
				<A HREF="visual.html#CTRL-V">CTRL-V</A> is one character
		   niI	    <A HREF="intro.html#Normal">Normal</A> using |<A HREF="insert.html#i_CTRL-O">i_CTRL-O</A>| in |<A HREF="insert.html#Insert-mode">Insert-mode</A>|
		   niR	    <A HREF="intro.html#Normal">Normal</A> using |<A HREF="insert.html#i_CTRL-O">i_CTRL-O</A>| in |<A HREF="insert.html#Replace-mode">Replace-mode</A>|
		   niV	    <A HREF="intro.html#Normal">Normal</A> using |<A HREF="insert.html#i_CTRL-O">i_CTRL-O</A>| in |<A HREF="insert.html#Virtual-Replace-mode">Virtual-Replace-mode</A>|
		   nt	    <A HREF="terminal.html#Terminal-Normal">Terminal-Normal</A> (insert goes to <A HREF="terminal.html#Terminal-Job">Terminal-Job</A> mode)
		   <A HREF="visual.html#v">v</A>	    <A HREF="visual.html#Visual">Visual</A> by character
		   vs	    <A HREF="visual.html#Visual">Visual</A> by character using |<A HREF="visual.html#v_CTRL-O">v_CTRL-O</A>| in <A HREF="visual.html#Select">Select</A> mode
		   <A HREF="visual.html#V">V</A>	    <A HREF="visual.html#Visual">Visual</A> by line
		   Vs	    <A HREF="visual.html#Visual">Visual</A> by line using |<A HREF="visual.html#v_CTRL-O">v_CTRL-O</A>| in <A HREF="visual.html#Select">Select</A> mode
		   <A HREF="visual.html#CTRL-V">CTRL-V</A>   <A HREF="visual.html#Visual">Visual</A> blockwise
		   CTRL-Vs  <A HREF="visual.html#Visual">Visual</A> blockwise using |<A HREF="visual.html#v_CTRL-O">v_CTRL-O</A>| in <A HREF="visual.html#Select">Select</A> mode
		   <A HREF="change.html#s">s</A>	    <A HREF="visual.html#Select">Select</A> by character
		   <A HREF="change.html#S">S</A>	    <A HREF="visual.html#Select">Select</A> by line
		   CTRL-S   <A HREF="visual.html#Select">Select</A> blockwise
		   <A HREF="insert.html#i">i</A>	    <A HREF="insert.html#Insert">Insert</A>
		   ic	    <A HREF="insert.html#Insert">Insert</A> mode completion |<A HREF="insert.html#compl-generic">compl-generic</A>|
		   ix	    <A HREF="insert.html#Insert">Insert</A> mode |<A HREF="insert.html#i_CTRL-X">i_CTRL-X</A>| completion
		   R	    <A HREF="insert.html#Replace">Replace</A> |<A HREF="change.html#R">R</A>|
		   Rc	    <A HREF="insert.html#Replace">Replace</A> mode completion |<A HREF="insert.html#compl-generic">compl-generic</A>|
		   Rx	    <A HREF="insert.html#Replace">Replace</A> mode |<A HREF="insert.html#i_CTRL-X">i_CTRL-X</A>| completion
		   Rv	    Virtual <A HREF="insert.html#Replace">Replace</A> |<A HREF="change.html#gR">gR</A>|
		   Rvc	    Virtual <A HREF="insert.html#Replace">Replace</A> mode completion |<A HREF="insert.html#compl-generic">compl-generic</A>|
		   Rvx	    Virtual <A HREF="insert.html#Replace">Replace</A> mode |<A HREF="insert.html#i_CTRL-X">i_CTRL-X</A>| completion
		   <A HREF="change.html#c">c</A>	    <A HREF="cmdline.html#Command-line">Command-line</A> editing
		   cv	    Vim <A HREF="intro.html#Ex">Ex</A> mode |<A HREF="intro.html#gQ">gQ</A>|
		   ce	    <A HREF="intro.html#Normal">Normal</A> <A HREF="intro.html#Ex">Ex</A> mode |<A HREF="intro.html#Q">Q</A>|
		   <A HREF="change.html#r">r</A>	    Hit-enter prompt
		   rm	    The <A HREF="starting.html#--">--</A> more <A HREF="starting.html#--">--</A> prompt
		   r?	    A |<A HREF="editing.html#:confirm">:confirm</A>| query of some sort
		   !	    Shell or external command is executing
		   t	    <A HREF="terminal.html#Terminal-Job">Terminal-Job</A> mode: keys go to the <A HREF="channel.html#job">job</A>

		This is useful in the <A HREF="options.html#'statusline'">'statusline'</A> option or when used
		with |<A HREF="#remote_expr()">remote_expr()</A>| In most other places <A HREF="motion.html#it">it</A> always returns
		&quot;<A HREF="change.html#c">c</A>&quot; or &quot;<A HREF="pattern.html#n">n</A>&quot;.
		Note that in the future more modes and more specific modes may
		be added. It's better not to compare the whole <A HREF="eval.html#string">string</A> but only
		the leading character(s).
		Also see |<A HREF="#visualmode()">visualmode()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			DoFull()-&gt;mode()</B>


mzeval({expr})							*<A NAME="mzeval()"></A><B>mzeval()</B>*
		Evaluate <A HREF="if_mzsch.html#MzScheme">MzScheme</A> <A HREF="eval.html#expression">expression</A> {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned <A HREF="motion.html#as">as</A> they are.
		Pairs (including lists and improper lists) and vectors are
		returned <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#Lists">Lists</A>|.
		Hash tables are represented <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#Dictionary">Dictionary</A>| type with keys
		converted to strings.
		All other types are converted to <A HREF="eval.html#string">string</A> with display function.
		Examples:
<B>		    :mz (define l (list 1 2 3))</B>
<B>		    :mz (define h (make-hash)) (hash-set! h "list" l)</B>
<B>		    :echo mzeval("l")</B>
<B>		    :echo mzeval("h")</B>
 
		Note that in a `:def` function local <A HREF="eval.html#variables">variables</A> are not visible
		to {expr}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;mzeval()</B>
 
		{only available when compiled with the |<A HREF="various.html#+mzscheme">+mzscheme</A>| feature}


nextnonblank({lnum})					*<A NAME="nextnonblank()"></A><B>nextnonblank()</B>*
		Return the line number of the first line at or below {lnum}
		that is not blank.  Example:
<B>			if getline(nextnonblank(1)) =~ "Java"</B>
 		When {lnum} is invalid or there is no non-blank line at or
		below <A HREF="motion.html#it">it</A>, zero is returned.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.
		See also |<A HREF="#prevnonblank()">prevnonblank()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;nextnonblank()</B>


nr2char({expr} [, {utf8}])				*<A NAME="nr2char()"></A><B>nr2char()</B>*
		Return a <A HREF="eval.html#string">string</A> with a single character, which has the number
		value {expr}.  Examples:
<B>			nr2char(64)		returns "@"</B>
<B>			nr2char(32)		returns " "</B>
 		When {utf8} is omitted or zero, the current <A HREF="options.html#'encoding'">'encoding'</A> is used.
		Example for &quot;<A HREF="mbyte.html#utf-8">utf-8</A>&quot;:
<B>			nr2char(300)		returns I with bow character</B>
 		When {utf8} is <A HREF="eval.html#TRUE">TRUE</A>, always return <A HREF="mbyte.html#UTF-8">UTF-8</A> characters.
		Note that a NUL character in the file is specified with
		nr2char(10), because NULs are represented with newline
		characters.  nr2char(0) is a real NUL and terminates the
		<A HREF="eval.html#string">string</A>, thus results in an empty <A HREF="eval.html#string">string</A>.
		To turn a <A HREF="eval.html#list">list</A> of character numbers into a <A HREF="eval.html#string">string</A>:
<B>		    let list = [65, 66, 67]</B>
<B>		    let str = join(map(list, {_, val -&gt; nr2char(val)}), '')</B>
 		Result: &quot;ABC&quot;

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetNumber()-&gt;nr2char()</B>


or({expr}, {expr})					*<A NAME="or()"></A><B>or()</B>*
		Bitwise OR on the two arguments.  The arguments are converted
		to a number.  A <A HREF="eval.html#List">List</A>, <A HREF="eval.html#Dict">Dict</A> or <A HREF="eval.html#Float">Float</A> argument causes an error.
		Also see `and()` and `xor()`.
		Example:
<B>			:let bits = or(bits, 0x80)</B>
 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			:let bits = bits-&gt;or(0x80)</B>

 		Rationale: The reason this is a function and not using the &quot;|&quot;
		character like many languages, is that <A HREF="intro.html#Vi">Vi</A> has always used &quot;|&quot;
		to separate commands.  In many places <A HREF="motion.html#it">it</A> would not be clear if
		&quot;|&quot; is an <A HREF="motion.html#operator">operator</A> or a command separator.



pathshorten({path} [, {len}])				*<A NAME="pathshorten()"></A><B>pathshorten()</B>*
		Shorten directory names in the path {path} and return the
		result.  The tail, the file name, is kept as-is.  The other
		components in the path are reduced to {len} letters in length.
		If {len} is omitted or smaller than 1 then 1 is used (single
		letters).  Leading '<A HREF="change.html#~">~</A>' and '<A HREF="repeat.html#.">.</A>' characters are kept.  Examples:
<B>			:echo pathshorten('~/.vim/autoload/myfile.vim')</B>
<B><FONT COLOR="PURPLE"> 			~/.v/a/myfile.vim </FONT></B>

<B>			:echo pathshorten('~/.vim/autoload/myfile.vim', 2)</B>
<B><FONT COLOR="PURPLE"> 			~/.vi/au/myfile.vim </FONT></B>
		It doesn't matter if the path exists or not.
		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetDirectories()-&gt;pathshorten()</B>


perleval({expr})					*<A NAME="perleval()"></A><B>perleval()</B>*
		Evaluate <A HREF="if_perl.html#Perl">Perl</A> <A HREF="eval.html#expression">expression</A> {expr} in scalar context and return
		its result converted to Vim data structures. If value can't be
		converted, <A HREF="motion.html#it">it</A> is returned <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A> <A HREF="if_perl.html#Perl">Perl</A> representation.
		Note: If you want an array or hash, {expr} must return a
		reference to <A HREF="motion.html#it">it</A>.
		Example:
<B>			:echo perleval('[1 .. 4]')</B>
 			[1, 2, 3, 4]

		Note that in a `:def` function local <A HREF="eval.html#variables">variables</A> are not visible
		to {expr}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;perleval()</B>

 		{only available when compiled with the |<A HREF="various.html#+perl">+perl</A>| feature}


popup_ functions are documented here: |<A HREF="popup.html#popup-functions">popup-functions</A>|



pow({x}, {y})						*<A NAME="pow()"></A><B>pow()</B>*
		Return the power of {x} to the exponent {y} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|.
		{x} and {y} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {x} or {y} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo pow(3, 3)</B>
 			27.0
<B>			:echo pow(2, 16)</B>
 			65536.0
<B>			:echo pow(32, 0.20)</B>
 			2.0

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;pow(3)</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


prevnonblank({lnum})					*<A NAME="prevnonblank()"></A><B>prevnonblank()</B>*
		Return the line number of the first line at or above {lnum}
		that is not blank.  Example:
<B>			let ind = indent(prevnonblank(v:lnum - 1))</B>
 		When {lnum} is invalid or there is no non-blank line at or
		above <A HREF="motion.html#it">it</A>, zero is returned.
		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.
		Also see |<A HREF="#nextnonblank()">nextnonblank()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetLnum()-&gt;prevnonblank()</B>


printf({fmt}, {expr1} <A HREF="eval.html#...">...</A>)				*<A NAME="printf()"></A><B>printf()</B>*
		Return a <A HREF="eval.html#String">String</A> with {fmt}, where &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; items are replaced by
		the formatted form of their respective arguments.  Example:
<B>			printf("%4d: E%d %.30s", lnum, errno, msg)</B>
 		May result in:
<B><FONT COLOR="PURPLE">			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" </FONT></B>

		When used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>| the base is passed <A HREF="motion.html#as">as</A> the second
		argument:
<B>			Compute()-&gt;printf("result: %d")</B>
 
		You can use `call()` to pass the items <A HREF="motion.html#as">as</A> a <A HREF="eval.html#list">list</A>.

		Often used items are:
		  &#37;s	<A HREF="eval.html#string">string</A>
		  &#37;6S	<A HREF="eval.html#string">string</A> right-aligned in 6 display cells
		  &#37;6s	<A HREF="eval.html#string">string</A> right-aligned in 6 bytes
		  &#37;.9s	<A HREF="eval.html#string">string</A> truncated to 9 bytes
		  &#37;c	single byte
		  &#37;d	decimal number
		  &#37;5d	decimal number padded with spaces to 5 characters
		  &#37;x	hex number
		  &#37;04x	hex number padded with zeros to at least 4 characters
		  &#37;X	hex number using upper <A HREF="change.html#case">case</A> letters
		  &#37;o	<A HREF="eval.html#octal">octal</A> number
		  &#37;08b	binary number padded with zeros to at least 8 chars
		  &#37;f	floating point number <A HREF="motion.html#as">as</A> 12.23, inf, -inf or nan
		  &#37;F	floating point number <A HREF="motion.html#as">as</A> 12.23, INF, -INF or NAN
		  &#37;e	floating point number <A HREF="motion.html#as">as</A> 1.23e3, inf, -inf or nan
		  &#37;E	floating point number <A HREF="motion.html#as">as</A> 1.23E3, INF, -INF or NAN
		  &#37;g	floating point number, <A HREF="motion.html#as">as</A> &#37;f or &#37;e depending on value
		  &#37;G	floating point number, <A HREF="motion.html#as">as</A> &#37;F or &#37;E depending on value
		  &#37;&#37;	the <A HREF="motion.html#&#37;">&#37;</A> character itself

		Conversion specifications start with '<A HREF="motion.html#&#37;">&#37;</A>' and end with the
		conversion type.  All other characters are copied unchanged to
		the result.

		The &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; starts a conversion specification.  The following
		arguments appear in sequence:

			<A HREF="motion.html#&#37;">&#37;</A>  [flags]  [field-width]  [.precision]  type

		flags
			Zero or more of the following flags:

		    #	      The value should be converted to an &quot;alternate
			      form&quot;.  For <A HREF="change.html#c">c</A>, <A HREF="change.html#d">d</A>, and <A HREF="change.html#s">s</A> conversions, this option
			      has no effect.  For <A HREF="insert.html#o">o</A> conversions, the precision
			      of the number is increased to force the first
			      character of the output <A HREF="eval.html#string">string</A> to a zero (except
			      if a zero value is printed with an explicit
			      precision of zero).
			      For <A HREF="motion.html#b">b</A> and <A HREF="motion.html#B">B</A> conversions, a non-zero result has
			      the <A HREF="eval.html#string">string</A> &quot;0b&quot; (or &quot;0B&quot; for <A HREF="motion.html#B">B</A> conversions)
			      prepended to <A HREF="motion.html#it">it</A>.
			      For <A HREF="change.html#x">x</A> and X conversions, a non-zero result has
			      the <A HREF="eval.html#string">string</A> &quot;<A HREF="eval.html#0x">0x</A>&quot; (or &quot;0X&quot; for X conversions)
			      prepended to <A HREF="motion.html#it">it</A>.

		    0 (zero)  Zero padding.  For all conversions the converted
			      value is padded on the left with zeros rather
			      than blanks.  If a precision is given with a
			      numeric conversion (d, <A HREF="motion.html#b">b</A>, <A HREF="motion.html#B">B</A>, <A HREF="insert.html#o">o</A>, <A HREF="change.html#x">x</A>, and X), the 0
			      flag is ignored.

		    -	      A negative field width flag; the converted value
			      is to be left adjusted on the field boundary.
			      The converted value is padded on the right with
			      blanks, rather than on the left with blanks or
			      zeros.  A - overrides a 0 if both are given.

		    '' '' (space)  A blank should be left before a positive
			      number produced by a signed conversion (d).

		    +	      A sign must always be placed before a number
			      produced by a signed conversion.  A + overrides
			      a space if both are used.

		field-width
			An optional decimal digit <A HREF="eval.html#string">string</A> specifying a minimum
			field width.  If the converted value has fewer bytes
			than the field width, <A HREF="motion.html#it">it</A> will be padded with spaces on
			the left (or right, if the left-adjustment flag has
			been given) to fill out the field width.  For the <A HREF="change.html#S">S</A>
			conversion the <A HREF="intro.html#count">count</A> is in cells.

		.precision
			An optional precision, in the form of a period '<A HREF="repeat.html#.">.</A>'
			followed by an optional digit <A HREF="eval.html#string">string</A>.  If the digit
			<A HREF="eval.html#string">string</A> is omitted, the precision is taken <A HREF="motion.html#as">as</A> zero.
			This gives the minimum number of digits to appear for
			<A HREF="change.html#d">d</A>, <A HREF="insert.html#o">o</A>, <A HREF="change.html#x">x</A>, and X conversions, the maximum number of
			bytes to be printed from a <A HREF="eval.html#string">string</A> for <A HREF="change.html#s">s</A> conversions,
			or the maximum number of cells to be printed from a
			<A HREF="eval.html#string">string</A> for <A HREF="change.html#S">S</A> conversions.
			For floating point <A HREF="motion.html#it">it</A> is the number of digits after
			the decimal point.

		type
			A character that specifies the type of conversion to
			be applied, see below.

		A field width or precision, or both, may be indicated by an
		asterisk '*' instead of a digit <A HREF="eval.html#string">string</A>.  In this <A HREF="change.html#case">case</A>, a
		<A HREF="eval.html#Number">Number</A> argument supplies the field width or precision.  A
		negative field width is treated <A HREF="motion.html#as">as</A> a left adjustment flag
		followed by a positive field width; a negative precision is
		treated <A HREF="motion.html#as">as</A> though <A HREF="motion.html#it">it</A> were missing.  Example:
<B>			:echo printf("%d: %.*s", nr, width, line)</B>
 		This <A HREF="vi_diff.html#limits">limits</A> the length of the text used from &quot;line&quot; to
		&quot;width&quot; bytes.

		The conversion specifiers and their meanings are:


				*<A NAME="printf-d"></A><B>printf-d</B>* *<A NAME="printf-b"></A><B>printf-b</B>* *<A NAME="printf-B"></A><B>printf-B</B>* *<A NAME="printf-o"></A><B>printf-o</B>*

				*<A NAME="printf-x"></A><B>printf-x</B>* *<A NAME="printf-X"></A><B>printf-X</B>*
		dbBoxX	The <A HREF="eval.html#Number">Number</A> argument is converted to signed decimal
			(d), unsigned binary (b and B), unsigned <A HREF="eval.html#octal">octal</A> (o), or
			unsigned hexadecimal (x and X) <A HREF="intro.html#notation">notation</A>.  The letters
			&quot;abcdef&quot; are used for <A HREF="change.html#x">x</A> conversions; the letters
			&quot;ABCDEF&quot; are used for X conversions.
			The precision, if any, gives the minimum number of
			digits that must appear; if the converted value
			requires fewer digits, <A HREF="motion.html#it">it</A> is padded on the left with
			zeros.
			In no <A HREF="change.html#case">case</A> does a non-existent or small field width
			cause truncation of a numeric field; if the result of
			a conversion is wider than the field width, the field
			is expanded to contain the conversion result.
			The '<A HREF="motion.html#h">h</A>' modifier indicates the argument is 16 bits.
			The '<A HREF="motion.html#l">l</A>' modifier indicates the argument is 32 bits.
			The '<A HREF="motion.html#L">L</A>' modifier indicates the argument is 64 bits.
			Generally, these modifiers are not useful. They are
			ignored when type is known from the argument.

		<A HREF="insert.html#i">i</A>	alias for <A HREF="change.html#d">d</A>
		<A HREF="change.html#D">D</A>	alias for ld
		<A HREF="undo.html#U">U</A>	alias for lu
		<A HREF="insert.html#O">O</A>	alias for lo


							*<A NAME="printf-c"></A><B>printf-c</B>*
		<A HREF="change.html#c">c</A>	The <A HREF="eval.html#Number">Number</A> argument is converted to a byte, and the
			resulting character is written.


							*<A NAME="printf-s"></A><B>printf-s</B>*
		<A HREF="change.html#s">s</A>	The text of the <A HREF="eval.html#String">String</A> argument is used.  If a
			precision is specified, no more bytes than the number
			specified are used.
			If the argument is not a <A HREF="eval.html#String">String</A> type, <A HREF="motion.html#it">it</A> is
			automatically converted to text with the same format
			<A HREF="motion.html#as">as</A> &quot;<A HREF="eval.html#:echo">:echo</A>&quot;.

							*<A NAME="printf-S"></A><B>printf-S</B>*
		<A HREF="change.html#S">S</A>	The text of the <A HREF="eval.html#String">String</A> argument is used.  If a
			precision is specified, no more display cells than the
			number specified are used.


							*<A NAME="printf-f"></A><B>printf-f</B>* *<A NAME="E807"></A><B>E807</B>*
		<A HREF="motion.html#f">f</A> <A HREF="motion.html#F">F</A>	The <A HREF="eval.html#Float">Float</A> argument is converted into a <A HREF="eval.html#string">string</A> of the
			form 123.456.  The precision specifies the number of
			digits after the decimal point.  When the precision is
			zero the decimal point is omitted.  When the precision
			is not specified 6 is used.  A really big number
			(out of range or dividing by zero) results in &quot;inf&quot;
			or &quot;-inf&quot; with &#37;f (INF or -INF with &#37;F).
			&quot;0.0 / 0.0&quot; results in &quot;nan&quot; with &#37;f (NAN with &#37;F).
			Example:
<B>				echo printf("%.2f", 12.115)</B>
 				12.12
			Note that roundoff depends on the system libraries.
			Use |<A HREF="#round()">round()</A>| when in doubt.


							*<A NAME="printf-e"></A><B>printf-e</B>* *<A NAME="printf-E"></A><B>printf-E</B>*
		<A HREF="motion.html#e">e</A> <A HREF="motion.html#E">E</A>	The <A HREF="eval.html#Float">Float</A> argument is converted into a <A HREF="eval.html#string">string</A> of the
			form 1.234e+03 or 1.234E+03 when using '<A HREF="motion.html#E">E</A>'.  The
			precision specifies the number of digits after the
			decimal point, like with '<A HREF="motion.html#f">f</A>'.


							*<A NAME="printf-g"></A><B>printf-g</B>* *<A NAME="printf-G"></A><B>printf-G</B>*
		<A HREF="index.html#g">g</A> <A HREF="motion.html#G">G</A>	The <A HREF="eval.html#Float">Float</A> argument is converted like with '<A HREF="motion.html#f">f</A>' if the
			value is between 0.001 (inclusive) and 10000000.0
			(exclusive).  Otherwise '<A HREF="motion.html#e">e</A>' is used for '<A HREF="index.html#g">g</A>' and '<A HREF="motion.html#E">E</A>'
			for '<A HREF="motion.html#G">G</A>'.  When no precision is specified superfluous
			zeroes and '<A HREF="motion.html#+">+</A>' <A HREF="sign.html#signs">signs</A> are removed, except for the zero
			immediately after the decimal point.  Thus 10000000.0
			results in 1.0e7.


							*<A NAME="printf-&#37;"></A><B>printf-&#37;</B>*
		<A HREF="motion.html#&#37;">&#37;</A>	A '<A HREF="motion.html#&#37;">&#37;</A>' is written.  No argument is converted.  The
			complete conversion specification is &quot;&#37;&#37;&quot;.

		When a <A HREF="eval.html#Number">Number</A> argument is expected a <A HREF="eval.html#String">String</A> argument is also
		accepted and automatically converted.
		When a <A HREF="eval.html#Float">Float</A> or <A HREF="eval.html#String">String</A> argument is expected a <A HREF="eval.html#Number">Number</A> argument
		is also accepted and automatically converted.
		Any other argument type results in an error message.


							*<A NAME="E766"></A><B>E766</B>* *<A NAME="E767"></A><B>E767</B>*
		The number of {exprN} arguments must exactly match the number
		of &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; items.  If there are not sufficient or too many
		arguments an error is given.  Up to 18 arguments can be used.



prompt_getprompt({buf})					*<A NAME="prompt_getprompt()"></A><B>prompt_getprompt()</B>*
		Returns the effective prompt text for buffer {buf}.  {buf} can
		be a buffer name or number.  See |<A HREF="channel.html#prompt-buffer">prompt-buffer</A>|.

		If the buffer doesn't exist or isn't a prompt buffer, an empty
		<A HREF="eval.html#string">string</A> is returned.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBuffer()-&gt;prompt_getprompt()</B>

 		{only available when compiled with the |<A HREF="various.html#+channel">+channel</A>| feature}



prompt_setcallback({buf}, {expr})			*<A NAME="prompt_setcallback()"></A><B>prompt_setcallback()</B>*
		Set prompt callback for buffer {buf} to {expr}.  When {expr}
		is an empty <A HREF="eval.html#string">string</A> the callback is removed.  This has only
		effect if {buf} has <A HREF="options.html#'buftype'">'buftype'</A> set to &quot;prompt&quot;.

		The callback is invoked when pressing Enter.  The current
		buffer will always be the prompt buffer.  A new line for a
		prompt is added before invoking the callback, thus the prompt
		for which the callback was invoked will be in the last but one
		line.
		If the callback wants to add text to the buffer, <A HREF="motion.html#it">it</A> must
		insert <A HREF="motion.html#it">it</A> above the last line, since that is where the current
		prompt is.  This can also be done asynchronously.
		The callback is invoked with one argument, which is the text
		that was entered at the prompt.  This can be an empty <A HREF="eval.html#string">string</A>
		if the user only typed Enter.
		Example:
<B>		   call prompt_setcallback(bufnr(), function('s:TextEntered'))</B>
<B>		   func s:TextEntered(text)</B>
<B>		     if a:text == 'exit' || a:text == 'quit'</B>
<B>		       stopinsert</B>
<B>		       close</B>
<B>		     else</B>
<B>		       call append(line('$') - 1, 'Entered: "' .. a:text .. '"')</B>
<B>		       " Reset 'modified' to allow the buffer to be closed.</B>
<B>		       set nomodified</B>
<B>		     endif</B>
<B>		   endfunc</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBuffer()-&gt;prompt_setcallback(callback)</B>

 		{only available when compiled with the |<A HREF="various.html#+channel">+channel</A>| feature}


prompt_setinterrupt({buf}, {expr})			*<A NAME="prompt_setinterrupt()"></A><B>prompt_setinterrupt()</B>*
		Set a callback for buffer {buf} to {expr}.  When {expr} is an
		empty <A HREF="eval.html#string">string</A> the callback is removed.  This has only effect if
		{buf} has <A HREF="options.html#'buftype'">'buftype'</A> set to &quot;prompt&quot;.

		This callback will be invoked when pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A> in <A HREF="insert.html#Insert">Insert</A>
		mode.  Without setting a callback Vim will exit <A HREF="insert.html#Insert">Insert</A> mode,
		<A HREF="motion.html#as">as</A> in any buffer.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBuffer()-&gt;prompt_setinterrupt(callback)</B>

 		{only available when compiled with the |<A HREF="various.html#+channel">+channel</A>| feature}


prompt_setprompt({buf}, {text})				*<A NAME="prompt_setprompt()"></A><B>prompt_setprompt()</B>*
		Set prompt for buffer {buf} to {text}.  You most likely want
		{text} to end in a space.
		The result is only visible if {buf} has <A HREF="options.html#'buftype'">'buftype'</A> set to
		&quot;prompt&quot;.  Example:
<B>			call prompt_setprompt(bufnr(), 'command: ')</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBuffer()-&gt;prompt_setprompt('command: ')</B>

 		{only available when compiled with the |<A HREF="various.html#+channel">+channel</A>| feature}

prop_ functions are documented here: |<A HREF="textprop.html#text-prop-functions">text-prop-functions</A>|


<A HREF="#pum_getpos()">pum_getpos()</A>						*<A NAME="pum_getpos()"></A><B>pum_getpos()</B>*
		If the <A HREF="popup.html#popup">popup</A> menu (see |<A HREF="insert.html#ins-completion-menu">ins-completion-menu</A>|) is not visible,
		returns an empty |<A HREF="eval.html#Dictionary">Dictionary</A>|, otherwise, returns a
		|<A HREF="eval.html#Dictionary">Dictionary</A>| with the following keys:
			height		nr of items visible
			width		screen cells
			row		top screen row (0 first row)
			col		leftmost screen column (0 first col)
			size		total nr of items
			scrollbar	|<A HREF="eval.html#TRUE">TRUE</A>| if scrollbar is visible

		The values are the same <A HREF="motion.html#as">as</A> in |<A HREF="eval.html#v:event">v:event</A>| during
		|<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>|.


<A HREF="#pumvisible()">pumvisible()</A>						*<A NAME="pumvisible()"></A><B>pumvisible()</B>*
		Returns non-zero when the <A HREF="popup.html#popup">popup</A> menu is visible, zero
		otherwise.  See |<A HREF="insert.html#ins-completion-menu">ins-completion-menu</A>|.
		This can be used to avoid some things that would remove the
		<A HREF="popup.html#popup">popup</A> menu.


py3eval({expr})						*<A NAME="py3eval()"></A><B>py3eval()</B>*
		Evaluate <A HREF="if_pyth.html#Python">Python</A> <A HREF="eval.html#expression">expression</A> {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned <A HREF="motion.html#as">as</A> they are (strings are
		copied though, <A HREF="mbyte.html#Unicode">Unicode</A> strings are additionally converted to
		<A HREF="options.html#'encoding'">'encoding'</A>).
		<A HREF="eval.html#Lists">Lists</A> are represented <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#List">List</A>| type.
		<A HREF="eval.html#Dictionaries">Dictionaries</A> are represented <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#Dictionary">Dictionary</A>| type with
		keys converted to strings.
		Note that in a `:def` function local <A HREF="eval.html#variables">variables</A> are not visible
		to {expr}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;py3eval()</B>

 		{only available when compiled with the |<A HREF="various.html#+python3">+python3</A>| feature}


							*<A NAME="E858"></A><B>E858</B>* *<A NAME="E859"></A><B>E859</B>*

pyeval({expr})						*<A NAME="pyeval()"></A><B>pyeval()</B>*
		Evaluate <A HREF="if_pyth.html#Python">Python</A> <A HREF="eval.html#expression">expression</A> {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned <A HREF="motion.html#as">as</A> they are (strings are
		copied though).
		<A HREF="eval.html#Lists">Lists</A> are represented <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#List">List</A>| type.
		<A HREF="eval.html#Dictionaries">Dictionaries</A> are represented <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#Dictionary">Dictionary</A>| type,
		non-string keys result in error.
		Note that in a `:def` function local <A HREF="eval.html#variables">variables</A> are not visible
		to {expr}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;pyeval()</B>

 		{only available when compiled with the |<A HREF="various.html#+python">+python</A>| feature}


pyxeval({expr})						*<A NAME="pyxeval()"></A><B>pyxeval()</B>*
		Evaluate <A HREF="if_pyth.html#Python">Python</A> <A HREF="eval.html#expression">expression</A> {expr} and return its result
		converted to Vim data structures.
		Uses <A HREF="if_pyth.html#Python">Python</A> 2 or 3, see |<A HREF="if_pyth.html#python_x">python_x</A>| and <A HREF="options.html#'pyxversion'">'pyxversion'</A>.
		See also: |<A HREF="#pyeval()">pyeval()</A>|, |<A HREF="#py3eval()">py3eval()</A>|

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;pyxeval()</B>

 		{only available when compiled with the |<A HREF="various.html#+python">+python</A>| or the
		|<A HREF="various.html#+python3">+python3</A>| feature}


rand([{expr}])						*<A NAME="rand()"></A><B>rand()</B>* *<A NAME="random"></A><B>random</B>*
		Return a pseudo-random <A HREF="eval.html#Number">Number</A> generated with an xoshiro128**
		algorithm using seed {expr}.  The returned number is 32 bits,
		also on 64 bits systems, for consistency.
		{expr} can be initialized by |<A HREF="#srand()">srand()</A>| and will be updated by
		<A HREF="#rand()">rand()</A>.  If {expr} is omitted, an internal seed value is used
		and updated.
		Returns -1 if {expr} is invalid.

		Examples:
<B>			:echo rand()</B>
<B>			:let seed = srand()</B>
<B>			:echo rand(seed)</B>
<B>			:echo rand(seed) % 16  " random number 0 - 15</B>
 


							*<A NAME="E726"></A><B>E726</B>* *<A NAME="E727"></A><B>E727</B>*

range({expr} [, {max} [, {stride}]])				*<A NAME="range()"></A><B>range()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| with Numbers:
		- If only {expr} is specified: [0, 1, <A HREF="eval.html#...">...</A>, {expr} - 1]
		- If {max} is specified: [{expr}, {expr} + 1, <A HREF="eval.html#...">...</A>, {max}]
		- If {stride} is specified: [{expr}, {expr} + {stride}, <A HREF="eval.html#...">...</A>,
		  {max}] (increasing {expr} with {stride} each time, not
		  producing a value past {max}).
		When the maximum is one before the start the result is an
		empty <A HREF="eval.html#list">list</A>.  When the maximum is more than one before the
		start this is an error.
		Examples:
<B>			range(4)		" [0, 1, 2, 3]</B>
<B>			range(2, 4)		" [2, 3, 4]</B>
<B>			range(2, 9, 3)		" [2, 5, 8]</B>
<B>			range(2, -2, -1)	" [2, 1, 0, -1, -2]</B>
<B>			range(0)		" []</B>
<B>			range(2, 0)		" error!</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetExpr()-&gt;range()</B>
 


readblob({fname})					*<A NAME="readblob()"></A><B>readblob()</B>*
		Read file {fname} in binary mode and return a |<A HREF="eval.html#Blob">Blob</A>|.
		When the file can't be opened an error message is given and
		the result is an empty |<A HREF="eval.html#Blob">Blob</A>|.
		Also see |<A HREF="#readfile()">readfile()</A>| and |<A HREF="#writefile()">writefile()</A>|.



readdir({directory} [, {expr} [, {dict}]])			*<A NAME="readdir()"></A><B>readdir()</B>*
		Return a <A HREF="eval.html#list">list</A> with file and directory names in {directory}.
		You can also use |<A HREF="#glob()">glob()</A>| if you don't need to <A HREF="diff.html#do">do</A> complicated
		things, such <A HREF="motion.html#as">as</A> limiting the number of matches.
		The <A HREF="eval.html#list">list</A> will be sorted (case sensitive), see the {dict}
		argument below for <A HREF="change.html#changing">changing</A> the sort order.

		When {expr} is omitted all entries are included.
		When {expr} is given, <A HREF="motion.html#it">it</A> is evaluated to check what to <A HREF="diff.html#do">do</A>:
			If {expr} results in -1 then no further entries will
			be handled.
			If {expr} results in 0 then this entry will not be
			added to the <A HREF="eval.html#list">list</A>.
			If {expr} results in 1 then this entry will be added
			to the <A HREF="eval.html#list">list</A>.
		The entries &quot;<A HREF="repeat.html#.">.</A>&quot; and &quot;..&quot; are always excluded.
		Each time {expr} is evaluated |<A HREF="eval.html#v:val">v:val</A>| is set to the entry name.
		When {expr} is a function the name is passed <A HREF="motion.html#as">as</A> the argument.
		For example, to get a <A HREF="eval.html#list">list</A> of files ending in &quot;.txt&quot;:
<B>		  readdir(dirname, {n -&gt; n =~ '.txt$'})</B>
 		To skip hidden and <A HREF="editing.html#backup">backup</A> files:
<B>		  readdir(dirname, {n -&gt; n !~ '^\.\|\~$'})</B>

 								*<A NAME="E857"></A><B>E857</B>*
		The optional {dict} argument allows for further custom
		values. Currently this is used to specify if and how <A HREF="change.html#sorting">sorting</A>
		should be performed. The <A HREF="eval.html#dict">dict</A> can have the following members:

		    sort    How to sort the result returned from the system.
			    Valid values are:
				&quot;none&quot;	    <A HREF="diff.html#do">do</A> not sort (fastest <A HREF="eval.html#method">method</A>)
				&quot;<A HREF="change.html#case">case</A>&quot;	    sort <A HREF="change.html#case">case</A> sensitive (byte value of
					    each character, technically, using
					    strcmp()) (default)
				&quot;icase&quot;	    sort <A HREF="change.html#case">case</A> insensitive (technically
					    using strcasecmp())
				&quot;collate&quot;   sort using the collation order
					    of the &quot;POSIX&quot; or &quot;<A HREF="change.html#C">C</A>&quot; |<A HREF="mbyte.html#locale">locale</A>|
					    (technically using strcoll())
			    Other values are silently ignored.

		For example, to get a <A HREF="eval.html#list">list</A> of all files in the current
		directory without <A HREF="change.html#sorting">sorting</A> the individual entries:
<B>		  readdir('.', '1', #{sort: 'none'})</B>
 		If you want to get a directory tree:
<B>		  function! s:tree(dir)</B>
<B>		      return {a:dir : map(readdir(a:dir),</B>
<B>		      \ {_, x -&gt; isdirectory(x) ?</B>
<B>		      \		 {x : s:tree(a:dir .. '/' .. x)} : x})}</B>
<B>		  endfunction</B>
<B>		  echo s:tree(".")</B>
 
		Returns an empty <A HREF="eval.html#List">List</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetDirName()-&gt;readdir()</B>
 

readdirex({directory} [, {expr} [, {dict}]])			*<A NAME="readdirex()"></A><B>readdirex()</B>*
		Extended version of |<A HREF="#readdir()">readdir()</A>|.
		Return a <A HREF="eval.html#list">list</A> of <A HREF="eval.html#Dictionaries">Dictionaries</A> with file and directory
		information in {directory}.
		This is useful if you want to get the attributes of file and
		directory at the same time <A HREF="motion.html#as">as</A> getting a <A HREF="eval.html#list">list</A> of a directory.
		This is much faster than calling |<A HREF="#readdir()">readdir()</A>| then calling
		|<A HREF="#getfperm()">getfperm()</A>|, |<A HREF="#getfsize()">getfsize()</A>|, |<A HREF="#getftime()">getftime()</A>| and |<A HREF="#getftype()">getftype()</A>| for
		each file and directory especially on <A HREF="os_win32.html#MS-Windows">MS-Windows</A>.
		The <A HREF="eval.html#list">list</A> will by default be sorted by name (case sensitive),
		the <A HREF="change.html#sorting">sorting</A> can be changed by using the optional {dict}
		argument, see |<A HREF="#readdir()">readdir()</A>|.

		The <A HREF="eval.html#Dictionary">Dictionary</A> for file and directory information has the
		following items:
			group	Group name of the entry. (Only on <A HREF="os_unix.html#Unix">Unix</A>)
			name	Name of the entry.
			perm	Permissions of the entry. See |<A HREF="#getfperm()">getfperm()</A>|.
			size	Size of the entry. See |<A HREF="#getfsize()">getfsize()</A>|.
			time	Timestamp of the entry. See |<A HREF="#getftime()">getftime()</A>|.
			type	Type of the entry.
				On <A HREF="os_unix.html#Unix">Unix</A>, almost same <A HREF="motion.html#as">as</A> |<A HREF="#getftype()">getftype()</A>| except:
				    Symlink to a dir	&quot;linkd&quot;
				    Other symlink	&quot;link&quot;
				On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>:
				    <A HREF="intro.html#Normal">Normal</A> file		&quot;file&quot;
				    Directory		&quot;dir&quot;
				    Junction		&quot;junction&quot;
				    Symlink to a dir	&quot;linkd&quot;
				    Other symlink	&quot;link&quot;
				    Other reparse point	&quot;reparse&quot;
			user	<A HREF="autocmd.html#User">User</A> name of the entry's owner. (Only on <A HREF="os_unix.html#Unix">Unix</A>)
		On <A HREF="os_unix.html#Unix">Unix</A>, if the entry is a symlink, the <A HREF="eval.html#Dictionary">Dictionary</A> includes
		the information of the target (except the &quot;type&quot; item).
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, <A HREF="motion.html#it">it</A> includes the information of the symlink
		itself because of performance reasons.

		When {expr} is omitted all entries are included.
		When {expr} is given, <A HREF="motion.html#it">it</A> is evaluated to check what to <A HREF="diff.html#do">do</A>:
			If {expr} results in -1 then no further entries will
			be handled.
			If {expr} results in 0 then this entry will not be
			added to the <A HREF="eval.html#list">list</A>.
			If {expr} results in 1 then this entry will be added
			to the <A HREF="eval.html#list">list</A>.
		The entries &quot;<A HREF="repeat.html#.">.</A>&quot; and &quot;..&quot; are always excluded.
		Each time {expr} is evaluated |<A HREF="eval.html#v:val">v:val</A>| is set to a |<A HREF="eval.html#Dictionary">Dictionary</A>|
		of the entry.
		When {expr} is a function the entry is passed <A HREF="motion.html#as">as</A> the argument.
		For example, to get a <A HREF="eval.html#list">list</A> of files ending in &quot;.txt&quot;:
<B>		  readdirex(dirname, {e -&gt; e.name =~ '.txt$'})</B>
 
		For example, to get a <A HREF="eval.html#list">list</A> of all files in the current
		directory without <A HREF="change.html#sorting">sorting</A> the individual entries:
<B>		  readdirex(dirname, '1', #{sort: 'none'})</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetDirName()-&gt;readdirex()</B>
 


							*<A NAME="readfile()"></A><B>readfile()</B>*
readfile({fname} [, {type} [, {max}]])
		Read file {fname} and return a |<A HREF="eval.html#List">List</A>|, each line of the file
		<A HREF="motion.html#as">as</A> an item.  Lines are broken at NL characters.  <A HREF="os_mac.html#Macintosh">Macintosh</A>
		files separated with CR will result in a single long line
		(unless a NL appears somewhere).
		All NUL characters are replaced with a NL character.
		When {type} contains &quot;<A HREF="motion.html#b">b</A>&quot; binary mode is used:
		- When the last line ends in a NL an extra empty <A HREF="eval.html#list">list</A> item is
		  added.
		- No CR characters are removed.
		Otherwise:
		- CR characters that appear before a NL are removed.
		- Whether the last line ends in a NL or not does not matter.
		- When <A HREF="options.html#'encoding'">'encoding'</A> is <A HREF="mbyte.html#Unicode">Unicode</A> any <A HREF="mbyte.html#UTF-8">UTF-8</A> byte order <A HREF="motion.html#mark">mark</A> is
		  removed from the text.
		When {max} is given this specifies the maximum number of lines
		to be read.  Useful if you only want to check the first ten
		lines of a file:
<B>			:for line in readfile(fname, '', 10)</B>
<B>			:  if line =~ 'Date' | echo line | endif</B>
<B>			:endfor</B>
 		When {max} is negative -{max} lines from the end of the file
		are returned, or <A HREF="motion.html#as">as</A> many <A HREF="motion.html#as">as</A> there are.
		When {max} is zero the result is an empty <A HREF="eval.html#list">list</A>.
		Note that without {max} the whole file is read into memory.
		Also note that there is no recognition of encoding.  Read a
		file into a buffer if you need to.
		Deprecated (use |<A HREF="#readblob()">readblob()</A>| instead): When {type} contains
		&quot;B&quot; a |<A HREF="eval.html#Blob">Blob</A>| is returned with the binary data of the file
		unmodified.
		When the file can't be opened an error message is given and
		the result is an empty <A HREF="eval.html#list">list</A>.
		Also see |<A HREF="#writefile()">writefile()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFileName()-&gt;readfile()</B>


reduce({object}, {func} [, {initial}])			*<A NAME="reduce()"></A><B>reduce()</B>* *<A NAME="E998"></A><B>E998</B>*
		{func} is called for every item in {object}, which can be a
		|<A HREF="eval.html#String">String</A>|, |<A HREF="eval.html#List">List</A>| or a |<A HREF="eval.html#Blob">Blob</A>|.  {func} is called with two
		arguments: the result so far and current item.  After

		processing all items the result is returned. *<A NAME="E1132"></A><B>E1132</B>*

		{initial} is the initial result.  When omitted, the first item
		in {object} is used and {func} is first called for the second
		item.  If {initial} is not given and {object} is empty no
		result can be computed, an <A HREF="#E998">E998</A> error is given.

		Examples:
<B>			echo reduce([1, 3, 5], { acc, val -&gt; acc + val })</B>
<B>			echo reduce(['x', 'y'], { acc, val -&gt; acc .. val }, 'a')</B>
<B>			echo reduce(0z1122, { acc, val -&gt; 2 * acc + val })</B>
<B>			echo reduce('xyz', { acc, val -&gt; acc .. ',' .. val })</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			echo mylist-&gt;reduce({ acc, val -&gt; acc + val }, 0)</B>



<A HREF="#reg_executing()">reg_executing()</A>						*<A NAME="reg_executing()"></A><B>reg_executing()</B>*
		Returns the single <A HREF="print.html#letter">letter</A> name of the <A HREF="sponsor.html#register">register</A> being executed.
		Returns an empty <A HREF="eval.html#string">string</A> when no <A HREF="sponsor.html#register">register</A> is being executed.
		See |<A HREF="repeat.html#@">@</A>|.


<A HREF="#reg_recording()">reg_recording()</A>						*<A NAME="reg_recording()"></A><B>reg_recording()</B>*
		Returns the single <A HREF="print.html#letter">letter</A> name of the <A HREF="sponsor.html#register">register</A> being recorded.
		Returns an empty <A HREF="eval.html#string">string</A> when not <A HREF="repeat.html#recording">recording</A>.  See |<A HREF="repeat.html#q">q</A>|.


reltime([{start} [, {end}]])				*<A NAME="reltime()"></A><B>reltime()</B>*
		Return an item that represents a time value.  The item is a
		<A HREF="eval.html#list">list</A> with items that depend on the system.  In Vim 9 <A HREF="usr_41.html#script">script</A>
		list&lt;any&gt; can be used.
		The item can be passed to |<A HREF="#reltimestr()">reltimestr()</A>| to convert <A HREF="motion.html#it">it</A> to a
		<A HREF="eval.html#string">string</A> or |<A HREF="#reltimefloat()">reltimefloat()</A>| to convert to a <A HREF="eval.html#Float">Float</A>.

		Without an argument <A HREF="#reltime()">reltime()</A> returns the current time (the
		representation is system-dependent, <A HREF="motion.html#it">it</A> can not be used <A HREF="motion.html#as">as</A> the
		wall-clock time, see |<A HREF="#localtime()">localtime()</A>| for that).
		With one argument is returns the time passed since the time
		specified in the argument.
		With two arguments <A HREF="motion.html#it">it</A> returns the time passed between {start}
		and {end}.

		The {start} and {end} arguments must be values returned by
		<A HREF="#reltime()">reltime()</A>.  If there is an error an empty <A HREF="eval.html#List">List</A> is returned in
		legacy <A HREF="usr_41.html#script">script</A>, in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> an error is given.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetStart()-&gt;reltime()</B>
 
		{only available when compiled with the |<A HREF="various.html#+reltime">+reltime</A>| feature}


reltimefloat({time})				*<A NAME="reltimefloat()"></A><B>reltimefloat()</B>*
		Return a <A HREF="eval.html#Float">Float</A> that represents the time value of {time}.
		Example:
<B>			let start = reltime()</B>
<B>			call MyFunction()</B>
<B>			let seconds = reltimefloat(reltime(start))</B>
 		See the note of <A HREF="#reltimestr()">reltimestr()</A> about overhead.
		Also see |<A HREF="repeat.html#profiling">profiling</A>|.
		If there is an error 0.0 is returned in legacy <A HREF="usr_41.html#script">script</A>, in <A HREF="vim9.html#Vim9">Vim9</A>
		<A HREF="usr_41.html#script">script</A> an error is given.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			reltime(start)-&gt;reltimefloat()</B>

 		{only available when compiled with the |<A HREF="various.html#+reltime">+reltime</A>| feature}


reltimestr({time})				*<A NAME="reltimestr()"></A><B>reltimestr()</B>*
		Return a <A HREF="eval.html#String">String</A> that represents the time value of {time}.
		This is the number of seconds, a dot and the number of
		microseconds.  Example:
<B>			let start = reltime()</B>
<B>			call MyFunction()</B>
<B>			echo reltimestr(reltime(start))</B>
 		Note that overhead for the commands will be added to the time.
		The accuracy depends on the system.
		Leading spaces are used to make the <A HREF="eval.html#string">string</A> align nicely.  You
		can use <A HREF="#split()">split()</A> to remove <A HREF="motion.html#it">it</A>.
<B>			echo split(reltimestr(reltime(start)))[0]</B>
 		Also see |<A HREF="repeat.html#profiling">profiling</A>|.
		If there is an error an empty <A HREF="eval.html#string">string</A> is returned in legacy
		<A HREF="usr_41.html#script">script</A>, in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> an error is given.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			reltime(start)-&gt;reltimestr()</B>

 		{only available when compiled with the |<A HREF="various.html#+reltime">+reltime</A>| feature}


							*<A NAME="remote_expr()"></A><B>remote_expr()</B>* *<A NAME="E449"></A><B>E449</B>*
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
		Send the {string} to <A HREF="remote.html#{server}">{server}</A>.  The <A HREF="remote.html#{server}">{server}</A> argument is a
		<A HREF="eval.html#string">string</A>, also see |<A HREF="remote.html#{server}">{server}</A>|.

		The <A HREF="eval.html#string">string</A> is sent <A HREF="motion.html#as">as</A> an <A HREF="eval.html#expression">expression</A> and the result is returned
		after evaluation.  The result must be a <A HREF="eval.html#String">String</A> or a |<A HREF="eval.html#List">List</A>|.  A
		|<A HREF="eval.html#List">List</A>| is turned into a <A HREF="eval.html#String">String</A> by joining the items with a
		line break in between (not at the end), like with join(expr,
		&quot;\n&quot;).

		If {idvar} is present and not empty, <A HREF="motion.html#it">it</A> is taken <A HREF="motion.html#as">as</A> the name
		of a variable and a {serverid} for later use with
		|<A HREF="#remote_read()">remote_read()</A>| is stored there.

		If {timeout} is given the read times out after this many
		seconds.  Otherwise a timeout of 600 seconds is used.

		See also |<A HREF="remote.html#clientserver">clientserver</A>| |<A HREF="autocmd.html#RemoteReply">RemoteReply</A>|.
		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.
		{only available when compiled with the |<A HREF="various.html#+clientserver">+clientserver</A>| feature}
		Note: Any <A HREF="message.html#errors">errors</A> will cause a local error message to be issued
		and the result will be the empty <A HREF="eval.html#string">string</A>.

		Variables will be evaluated in the global namespace,
		independent of a function currently being active.  Except
		when in debug mode, then local function <A HREF="eval.html#variables">variables</A> and
		arguments can be evaluated.

		Examples:
<B>			:echo remote_expr("gvim", "2+2")</B>
<B>			:echo remote_expr("gvim1", "b:current_syntax")</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ServerName()-&gt;remote_expr(expr)</B>


remote_foreground({server})				*<A NAME="remote_foreground()"></A><B>remote_foreground()</B>*
		Move the Vim server with the name <A HREF="remote.html#{server}">{server}</A> to the foreground.
		The {server} argument is a <A HREF="eval.html#string">string</A>, also see |<A HREF="remote.html#{server}">{server}</A>|.
		This works like:
<B>			remote_expr({server}, "foreground()")</B>
 		Except that on <A HREF="os_win32.html#Win32">Win32</A> systems the client does the work, to work
		around the problem that the OS doesn't always allow the server
		to bring itself to the foreground.
		Note: This does not restore the <A HREF="windows.html#window">window</A> if <A HREF="motion.html#it">it</A> was minimized,
		like <A HREF="#foreground()">foreground()</A> does.
		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ServerName()-&gt;remote_foreground()</B>

 		{only in the <A HREF="os_win32.html#Win32">Win32</A>, <A HREF="gui_x11.html#Motif">Motif</A> and <A HREF="gui_x11.html#GTK">GTK</A> <A HREF="gui.html#GUI">GUI</A> versions and the
		<A HREF="os_win32.html#Win32">Win32</A> console version}



remote_peek({serverid} [, {retvar}])		*<A NAME="remote_peek()"></A><B>remote_peek()</B>*
		Returns a positive number if there are available strings
		from {serverid}.  Copies any reply <A HREF="eval.html#string">string</A> into the variable
		{retvar} if specified.  {retvar} must be a <A HREF="eval.html#string">string</A> with the
		name of a variable.
		Returns zero if none are available.
		Returns -1 if something is wrong.
		See also |<A HREF="remote.html#clientserver">clientserver</A>|.
		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.
		{only available when compiled with the |<A HREF="various.html#+clientserver">+clientserver</A>| feature}
		Examples:
<B>			:let repl = ""</B>
<B>			:echo "PEEK: " .. remote_peek(id, "repl") .. ": " .. repl</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ServerId()-&gt;remote_peek()</B>


remote_read({serverid}, [{timeout}])			*<A NAME="remote_read()"></A><B>remote_read()</B>*
		Return the oldest available reply from {serverid} and consume
		<A HREF="motion.html#it">it</A>.  Unless a {timeout} in seconds is given, <A HREF="motion.html#it">it</A> blocks until a
		reply is available.  Returns an empty <A HREF="eval.html#string">string</A>, if a reply is
		not available or on error.
		See also |<A HREF="remote.html#clientserver">clientserver</A>|.
		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.
		{only available when compiled with the |<A HREF="various.html#+clientserver">+clientserver</A>| feature}
		Example:
<B>			:echo remote_read(id)</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ServerId()-&gt;remote_read()</B>
 

							*<A NAME="remote_send()"></A><B>remote_send()</B>* *<A NAME="E241"></A><B>E241</B>*
remote_send({server}, {string} [, {idvar}])
		Send the {string} to <A HREF="remote.html#{server}">{server}</A>.  The <A HREF="remote.html#{server}">{server}</A> argument is a
		<A HREF="eval.html#string">string</A>, also see |<A HREF="remote.html#{server}">{server}</A>|.

		The <A HREF="eval.html#string">string</A> is sent <A HREF="motion.html#as">as</A> input keys and the function returns
		immediately.  At the Vim server the keys are not mapped
		|<A HREF="map.html#:map">:map</A>|.

		If {idvar} is present, <A HREF="motion.html#it">it</A> is taken <A HREF="motion.html#as">as</A> the name of a variable
		and a {serverid} for later use with <A HREF="#remote_read()">remote_read()</A> is stored
		there.

		See also |<A HREF="remote.html#clientserver">clientserver</A>| |<A HREF="autocmd.html#RemoteReply">RemoteReply</A>|.
		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.
		{only available when compiled with the |<A HREF="various.html#+clientserver">+clientserver</A>| feature}

		Note: Any <A HREF="message.html#errors">errors</A> will be reported in the server and may mess
		up the display.
		Examples:
<B>		:echo remote_send("gvim", ":DropAndReply " .. file, "serverid") ..</B>
<B>		 \ remote_read(serverid)</B>

<B>		:autocmd NONE RemoteReply *</B>
<B>		 \ echo remote_read(expand("&lt;amatch&gt;"))</B>
<B>		:echo remote_send("gvim", ":sleep 10 | echo " ..</B>
<B>		 \ 'server2client(expand("&lt;client&gt;"), "HELLO")&lt;CR&gt;')</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ServerName()-&gt;remote_send(keys)</B>
 

					*<A NAME="remote_startserver()"></A><B>remote_startserver()</B>* *<A NAME="E941"></A><B>E941</B>* *<A NAME="E942"></A><B>E942</B>*
remote_startserver({name})
		Become the server {name}.  This fails if already running <A HREF="motion.html#as">as</A> a
		server, when |<A HREF="eval.html#v:servername">v:servername</A>| is not empty.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			ServerName()-&gt;remote_startserver()</B>

 		{only available when compiled with the |<A HREF="various.html#+clientserver">+clientserver</A>| feature}


remove({list}, {idx} [, {end}])				*<A NAME="remove()"></A><B>remove()</B>*
		Without {end}: Remove the item at {idx} from |<A HREF="eval.html#List">List</A>| {list} and
		return the item.
		With {end}: Remove items from {idx} to {end} (inclusive) and
		return a |<A HREF="eval.html#List">List</A>| with these items.  When {idx} points to the same
		item <A HREF="motion.html#as">as</A> {end} a <A HREF="eval.html#list">list</A> with one item is returned.  When {end}
		points to an item before {idx} this is an error.
		See |<A HREF="eval.html#list-index">list-index</A>| for possible values of {idx} and {end}.
		Returns zero on error.
		Example:
<B>			:echo "last item: " .. remove(mylist, -1)</B>
<B>			:call remove(mylist, 0, 9)</B>
 
		Use |<A HREF="#delete()">delete()</A>| to remove a file.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;remove(idx)</B>

remove({blob}, {idx} [, {end}])
		Without {end}: Remove the byte at {idx} from |<A HREF="eval.html#Blob">Blob</A>| {blob} and
		return the byte.
		With {end}: Remove bytes from {idx} to {end} (inclusive) and
		return a |<A HREF="eval.html#Blob">Blob</A>| with these bytes.  When {idx} points to the same
		byte <A HREF="motion.html#as">as</A> {end} a |<A HREF="eval.html#Blob">Blob</A>| with one byte is returned.  When {end}
		points to a byte before {idx} this is an error.
		Returns zero on error.
		Example:
<B>			:echo "last byte: " .. remove(myblob, -1)</B>
<B>			:call remove(mylist, 0, 9)</B>

remove({dict}, {key})
		Remove the entry from {dict} with key {key} and return <A HREF="motion.html#it">it</A>.
		Example:
<B>			:echo "removed " .. remove(dict, "one")</B>
 		If there is no {key} in {dict} this is an error.
		Returns zero on error.


rename({from}, {to})					*<A NAME="rename()"></A><B>rename()</B>*
		Rename the file by the name {from} to the name {to}.  This
		should also work to move files across file systems.  The
		result is a <A HREF="eval.html#Number">Number</A>, which is 0 if the file was renamed
		successfully, and non-zero when the renaming failed.
		NOTE: If {to} exists <A HREF="motion.html#it">it</A> is overwritten without warning.
		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetOldName()-&gt;rename(newname)</B>


repeat({expr}, {count})					*<A NAME="repeat()"></A><B>repeat()</B>*
		Repeat {expr} {count} times and return the concatenated
		result.  Example:
<B>			:let separator = repeat('-', 80)</B>
 		When {count} is zero or negative the result is empty.
		When {expr} is a |<A HREF="eval.html#List">List</A>| the result is {expr} concatenated
		{count} times.  Example:
<B>			:let longlist = repeat(['a', 'b'], 3)</B>
 		Results in ['a', '<A HREF="motion.html#b">b</A>', '<A HREF="insert.html#a">a</A>', '<A HREF="motion.html#b">b</A>', '<A HREF="insert.html#a">a</A>', 'b'].

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;repeat(count)</B>


resolve({filename})					*<A NAME="resolve()"></A><B>resolve()</B>* *<A NAME="E655"></A><B>E655</B>*
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, when {filename} is a shortcut (a .lnk file),
		returns the path the shortcut points to in a simplified form.
		When {filename} is a symbolic link or junction point, return
		the full path to the target. If the target of junction is
		removed, return {filename}.
		On <A HREF="os_unix.html#Unix">Unix</A>, repeat resolving symbolic links in all path
		components of {filename} and return the simplified result.
		To cope with link cycles, resolving of symbolic links is
		stopped after 100 iterations.
		On other systems, return the simplified {filename}.
		The simplification step is done <A HREF="motion.html#as">as</A> by |<A HREF="#simplify()">simplify()</A>|.
		<A HREF="#resolve()">resolve()</A> keeps a leading path component specifying the
		current directory (provided the result is still a relative
		path name) and also keeps a trailing path separator.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;resolve()</B>


reverse({object})					*<A NAME="reverse()"></A><B>reverse()</B>*
		Reverse the order of items in {object} in-place.
		{object} can be a |<A HREF="eval.html#List">List</A>| or a |<A HREF="eval.html#Blob">Blob</A>|.
		Returns {object}.
		Returns zero if {object} is not a <A HREF="eval.html#List">List</A> or a <A HREF="eval.html#Blob">Blob</A>.
		If you want an object to remain unmodified make a copy first:
<B>			:let revlist = reverse(copy(mylist))</B>
 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;reverse()</B>


round({expr})							*<A NAME="round()"></A><B>round()</B>*
		Round off {expr} to the nearest integral value and return <A HREF="motion.html#it">it</A>
		<A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|.  If {expr} lies halfway between two integral
		values, then use the larger one (away from zero).
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			echo round(0.456)</B>
 			0.0 
<B>			echo round(4.5)</B>
 			5.0
<B>			echo round(-4.5)</B>
 			-5.0

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;round()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


rubyeval({expr})					*<A NAME="rubyeval()"></A><B>rubyeval()</B>*
		Evaluate <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="eval.html#expression">expression</A> {expr} and return its result
		converted to Vim data structures.
		Numbers, floats and strings are returned <A HREF="motion.html#as">as</A> they are (strings
		are copied though).
		Arrays are represented <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#List">List</A>| type.
		Hashes are represented <A HREF="motion.html#as">as</A> Vim |<A HREF="eval.html#Dictionary">Dictionary</A>| type.
		Other <A HREF="index.html#objects">objects</A> are represented <A HREF="motion.html#as">as</A> strings resulted from their
		&quot;Object#to_s&quot; <A HREF="eval.html#method">method</A>.
		Note that in a `:def` function local <A HREF="eval.html#variables">variables</A> are not visible
		to {expr}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRubyExpr()-&gt;rubyeval()</B>

 		{only available when compiled with the |<A HREF="various.html#+ruby">+ruby</A>| feature}


screenattr({row}, {col})					*<A NAME="screenattr()"></A><B>screenattr()</B>*
		Like |<A HREF="#screenchar()">screenchar()</A>|, but return the attribute.  This is a rather
		arbitrary number that can only be used to compare to the
		attribute at other positions.
		Returns -1 when row or col is out of range.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRow()-&gt;screenattr(col)</B>


screenchar({row}, {col})					*<A NAME="screenchar()"></A><B>screenchar()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the character at position
		[row, col] on the screen.  This works for every possible
		screen position, also status lines, <A HREF="windows.html#window">window</A> separators and the
		command line.  The top left position is row one, column one
		The character excludes composing characters.  For double-byte
		encodings <A HREF="motion.html#it">it</A> may only be the first byte.
		This is mainly to be used for <A HREF="testing.html#testing">testing</A>.
		Returns -1 when row or col is out of range.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRow()-&gt;screenchar(col)</B>


screenchars({row}, {col})					*<A NAME="screenchars()"></A><B>screenchars()</B>*
		The result is a |<A HREF="eval.html#List">List</A>| of Numbers.  The first number is the same
		<A HREF="motion.html#as">as</A> what |<A HREF="#screenchar()">screenchar()</A>| returns.  Further numbers are
		composing characters on top of the base character.
		This is mainly to be used for <A HREF="testing.html#testing">testing</A>.
		Returns an empty <A HREF="eval.html#List">List</A> when row or col is out of range.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRow()-&gt;screenchars(col)</B>


<A HREF="#screencol()">screencol()</A>							*<A NAME="screencol()"></A><B>screencol()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the current screen column of
		the cursor. The leftmost column has number 1.
		This function is mainly used for <A HREF="testing.html#testing">testing</A>.

		Note: Always returns the current screen column, thus if used
		in a command (e.g. &quot;<A HREF="eval.html#:echo">:echo</A> screencol()&quot;) <A HREF="motion.html#it">it</A> will return the
		column inside the command line, which is 1 when the command is
		executed. To get the cursor position in the file use one of
		the following mappings:
<B>			nnoremap &lt;expr&gt; GG ":echom " .. screencol() .. "\n"</B>
<B>			nnoremap &lt;silent&gt; GG :echom screencol()&lt;CR&gt;</B>
<B>			nnoremap GG &lt;Cmd&gt;echom screencol()&lt;CR&gt;</B>
 

screenpos({winid}, {lnum}, {col})				*<A NAME="screenpos()"></A><B>screenpos()</B>*
		The result is a <A HREF="eval.html#Dict">Dict</A> with the screen position of the text
		character in <A HREF="windows.html#window">window</A> {winid} at buffer line {lnum} and column
		{col}.  {col} is a one-based byte index.
		The <A HREF="eval.html#Dict">Dict</A> has these members:
			row	screen row
			col	first screen column
			endcol	last screen column
			curscol	cursor screen column
		If the specified position is not visible, all values are zero.
		The &quot;endcol&quot; value differs from &quot;col&quot; when the character
		occupies more than one screen cell.  E.g. for a <A HREF="intro.html#Tab">Tab</A> &quot;col&quot; can
		be 1 and &quot;endcol&quot; can be 8.
		The &quot;curscol&quot; value is where the cursor would be placed.  For
		a <A HREF="intro.html#Tab">Tab</A> <A HREF="motion.html#it">it</A> would be the same <A HREF="motion.html#as">as</A> &quot;endcol&quot;, while for a double
		width character <A HREF="motion.html#it">it</A> would be the same <A HREF="motion.html#as">as</A> &quot;col&quot;.
		The |<A HREF="syntax.html#conceal">conceal</A>| feature is ignored here, the column numbers are
		<A HREF="motion.html#as">as</A> if <A HREF="options.html#'conceallevel'">'conceallevel'</A> is zero.  You can set the cursor to the
		right position and use |<A HREF="#screencol()">screencol()</A>| to get the value with
		|<A HREF="syntax.html#conceal">conceal</A>| taken into account.
		If the position is in a closed fold the screen position of the
		first character is returned, {col} is not used.
		Returns an empty <A HREF="eval.html#Dict">Dict</A> if {winid} is invalid.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;screenpos(lnum, col)</B>


<A HREF="#screenrow()">screenrow()</A>							*<A NAME="screenrow()"></A><B>screenrow()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the current screen row of the
		cursor.  The top line has number one.
		This function is mainly used for <A HREF="testing.html#testing">testing</A>.
		Alternatively you can use |<A HREF="#winline()">winline()</A>|.

		Note: Same restrictions <A HREF="motion.html#as">as</A> with |<A HREF="#screencol()">screencol()</A>|.


screenstring({row}, {col})					*<A NAME="screenstring()"></A><B>screenstring()</B>*
		The result is a <A HREF="eval.html#String">String</A> that contains the base character and
		any composing characters at position [row, col] on the screen.
		This is like |<A HREF="#screenchars()">screenchars()</A>| but returning a <A HREF="eval.html#String">String</A> with the
		characters.
		This is mainly to be used for <A HREF="testing.html#testing">testing</A>.
		Returns an empty <A HREF="eval.html#String">String</A> when row or col is out of range.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetRow()-&gt;screenstring(col)</B>
 

								*<A NAME="search()"></A><B>search()</B>*
search({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		Search for <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A> {pattern}.  The search starts at the
		cursor position (you can use |<A HREF="#cursor()">cursor()</A>| to set <A HREF="motion.html#it">it</A>).

		When a match has been found its line number is returned.
		If there is no match a 0 is returned and the cursor doesn't
		move.  No error message is given.

		{flags} is a <A HREF="eval.html#String">String</A>, which can contain these character flags:
		'<A HREF="motion.html#b">b</A>'	search Backward instead of forward
		'<A HREF="change.html#c">c</A>'	accept a match at the Cursor position
		'<A HREF="motion.html#e">e</A>'	move to the End of the match
		'<A HREF="pattern.html#n">n</A>'	<A HREF="diff.html#do">do</A> Not move the cursor
		'<A HREF="change.html#p">p</A>'	return number of matching sub-Pattern (see below)
		'<A HREF="change.html#s">s</A>'	Set the '' <A HREF="motion.html#mark">mark</A> at the previous location of the cursor
		'<A HREF="motion.html#w">w</A>'	Wrap around the end of the file
		'<A HREF="motion.html#W">W</A>'	don't Wrap around the end of the file
		'<A HREF="index.html#z">z</A>'	start searching at the cursor column instead of zero
		If neither '<A HREF="motion.html#w">w</A>' or '<A HREF="motion.html#W">W</A>' is given, the <A HREF="options.html#'wrapscan'">'wrapscan'</A> option applies.

		If the '<A HREF="change.html#s">s</A>' flag is supplied, the '' <A HREF="motion.html#mark">mark</A> is set, only if the
		cursor is moved. The '<A HREF="change.html#s">s</A>' flag cannot be combined with the '<A HREF="pattern.html#n">n</A>'
		flag.

		<A HREF="options.html#'ignorecase'">'ignorecase'</A>, <A HREF="options.html#'smartcase'">'smartcase'</A> and <A HREF="options.html#'magic'">'magic'</A> are used.

		When the '<A HREF="index.html#z">z</A>' flag is not given, forward searching always
		starts in column zero and then matches before the cursor are
		skipped.  When the '<A HREF="change.html#c">c</A>' flag is present in <A HREF="options.html#'cpo'">'cpo'</A> the next
		search starts after the match.  Without the '<A HREF="change.html#c">c</A>' flag the next
		search starts one column further.  This matters for
		overlapping matches.
		When searching backwards and the '<A HREF="index.html#z">z</A>' flag is given then the
		search starts in column zero, thus no match in the current
		line will be found (unless wrapping around the end of the
		file).

		When the {stopline} argument is given then the search stops
		after searching this line.  This is useful to restrict the
		search to a range of lines.  Examples:
<B>			let match = search('(', 'b', line("w0"))</B>
<B>			let end = search('END', '', line("w$"))</B>
 		When {stopline} is used and <A HREF="motion.html#it">it</A> is not zero this also implies
		that the search does not wrap around the end of the file.
		A zero value is equal to not giving the argument.

		When the {timeout} argument is given the search stops when
		more than this many milliseconds have passed.  Thus when
		{timeout} is 500 the search stops after half a second.
		The value must not be negative.  A zero value is like not
		giving the argument.
		{only available when compiled with the |<A HREF="various.html#+reltime">+reltime</A>| feature}

		If the {skip} <A HREF="eval.html#expression">expression</A> is given <A HREF="motion.html#it">it</A> is evaluated with the
		cursor positioned on the start of a match.  If <A HREF="motion.html#it">it</A> evaluates to
		non-zero this match is skipped.  This can be used, for
		example, to skip a match in a comment or a <A HREF="eval.html#string">string</A>.
		{skip} can be a <A HREF="eval.html#string">string</A>, which is evaluated <A HREF="motion.html#as">as</A> an <A HREF="eval.html#expression">expression</A>, a
		function reference or a <A HREF="eval.html#lambda">lambda</A>.
		When {skip} is omitted or empty, every match is accepted.
		When evaluating {skip} causes an error the search is aborted
		and -1 returned.

							*<A NAME="search()-sub-match"></A><B>search()-sub-match</B>*
		With the '<A HREF="change.html#p">p</A>' flag the returned value is one more than the
		first sub-match in \(\).  One if none of them matched but the
		whole <A HREF="pattern.html#pattern">pattern</A> did match.
		To get the column number too use |<A HREF="#searchpos()">searchpos()</A>|.

		The cursor will be positioned at the match, unless the '<A HREF="pattern.html#n">n</A>'
		flag is used.

		Example (goes over all files in the argument list):
<B>		    :let n = 1</B>
<B>		    :while n &lt;= argc()	    " loop over all files in arglist</B>
<B>		    :  exe "argument " .. n</B>
<B>		    :  " start at the last char in the file and wrap for the</B>
<B>		    :  " first search to find match at start of file</B>
<B>		    :  normal G$</B>
<B>		    :  let flags = "w"</B>
<B>		    :  while search("foo", flags) &gt; 0</B>
<B>		    :	 s/foo/bar/g</B>
<B>		    :	 let flags = "W"</B>
<B>		    :  endwhile</B>
<B>		    :  update		    " write the file if modified</B>
<B>		    :  let n = n + 1</B>
<B>		    :endwhile</B>
 
		Example for using some flags:
<B>		    :echo search('\&lt;if\|\(else\)\|\(endif\)', 'ncpe')</B>
 		This will search for the keywords &quot;if&quot;, &quot;else&quot;, and &quot;endif&quot;
		under or after the cursor.  Because of the '<A HREF="change.html#p">p</A>' flag, <A HREF="motion.html#it">it</A>
		returns 1, 2, or 3 depending on which keyword is found, or 0
		if the search fails.  With the cursor on the first <A HREF="motion.html#word">word</A> of the
		line:
<B><FONT COLOR="PURPLE">		    if (foo == 0) | let foo = foo + 1 | endif </FONT></B>
		the function returns 1.  Without the '<A HREF="change.html#c">c</A>' flag, the function
		finds the &quot;endif&quot; and returns 3.  The same thing happens
		without the '<A HREF="motion.html#e">e</A>' flag if the cursor is on the &quot;<A HREF="motion.html#f">f</A>&quot; of &quot;if&quot;.
		The '<A HREF="pattern.html#n">n</A>' flag tells the function not to move the cursor.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPattern()-&gt;search()</B>


searchcount([{options}])					*<A NAME="searchcount()"></A><B>searchcount()</B>*
		Get or update the last search <A HREF="intro.html#count">count</A>, like what is displayed
		without the &quot;<A HREF="change.html#S">S</A>&quot; flag in <A HREF="options.html#'shortmess'">'shortmess'</A>.  This works even if
		<A HREF="options.html#'shortmess'">'shortmess'</A> does contain the &quot;<A HREF="change.html#S">S</A>&quot; flag.

		This returns a |<A HREF="eval.html#Dictionary">Dictionary</A>|. The dictionary is empty if the
		previous <A HREF="pattern.html#pattern">pattern</A> was not set and &quot;<A HREF="pattern.html#pattern">pattern</A>&quot; was not specified.

<B><FONT COLOR="PURPLE">		  key		type		meaning </FONT></B>
		  current	|<A HREF="eval.html#Number">Number</A>|	current position of match;
						0 if the cursor position is
						before the first match
		  exact_match	|<A HREF="eval.html#Boolean">Boolean</A>|	1 if &quot;current&quot; is matched on
						&quot;pos&quot;, otherwise 0
		  total		|<A HREF="eval.html#Number">Number</A>|	total <A HREF="intro.html#count">count</A> of matches found
		  incomplete	|<A HREF="eval.html#Number">Number</A>|	0: search was fully completed
						1: recomputing was timed out
						2: max <A HREF="intro.html#count">count</A> exceeded

		For {options} see further down.

		To get the last search <A HREF="intro.html#count">count</A> when |<A HREF="pattern.html#n">n</A>| or |<A HREF="pattern.html#N">N</A>| was pressed, call
		this function with `recompute: 0` . This sometimes returns
		wrong information because |<A HREF="pattern.html#n">n</A>| and |<A HREF="pattern.html#N">N</A>|'s maximum <A HREF="intro.html#count">count</A> is 99.
		If <A HREF="motion.html#it">it</A> exceeded 99 the result must be max <A HREF="intro.html#count">count</A> + 1 (100). If
		you want to get correct information, specify `recompute: 1`:

<B>			" result == maxcount + 1 (100) when many matches</B>
<B>			let result = searchcount(#{recompute: 0})</B>

<B>			" Below returns correct result (recompute defaults</B>
<B>			" to 1)</B>
<B>			let result = searchcount()</B>
 
		The function is useful to add the <A HREF="intro.html#count">count</A> to YXXYstatusline|:
<B>			function! LastSearchCount() abort</B>
<B>			  let result = searchcount(#{recompute: 0})</B>
<B>			  if empty(result)</B>
<B>			    return ''</B>
<B>			  endif</B>
<B>			  if result.incomplete ==# 1     " timed out</B>
<B>			    return printf(' /%s [?/??]', @/)</B>
<B>			  elseif result.incomplete ==# 2 " max count exceeded</B>
<B>			    if result.total &gt; result.maxcount &amp;&amp;</B>
<B>			    \  result.current &gt; result.maxcount</B>
<B>			      return printf(' /%s [&gt;%d/&gt;%d]', @/,</B>
<B>			      \		    result.current, result.total)</B>
<B>			    elseif result.total &gt; result.maxcount</B>
<B>			      return printf(' /%s [%d/&gt;%d]', @/,</B>
<B>			      \		    result.current, result.total)</B>
<B>			    endif</B>
<B>			  endif</B>
<B>			  return printf(' /%s [%d/%d]', @/,</B>
<B>			  \		result.current, result.total)</B>
<B>			endfunction</B>
<B>			let &amp;statusline ..= '%{LastSearchCount()}'</B>

<B>			" Or if you want to show the count only when</B>
<B>			" 'hlsearch' was on</B>
<B>			" let &amp;statusline ..=</B>
<B>			" \   '%{v:hlsearch ? LastSearchCount() : ""}'</B>
 
		You can also update the search <A HREF="intro.html#count">count</A>, which can be useful in a
		|<A HREF="autocmd.html#CursorMoved">CursorMoved</A>| or |<A HREF="autocmd.html#CursorMovedI">CursorMovedI</A>| <A HREF="autocmd.html#autocommand">autocommand</A>:

<B>			autocmd CursorMoved,CursorMovedI *</B>
<B>			  \ let s:searchcount_timer = timer_start(</B>
<B>			  \   200, function('s:update_searchcount'))</B>
<B>			function! s:update_searchcount(timer) abort</B>
<B>			  if a:timer ==# s:searchcount_timer</B>
<B>			    call searchcount(#{</B>
<B>			    \ recompute: 1, maxcount: 0, timeout: 100})</B>
<B>			    redrawstatus</B>
<B>			  endif</B>
<B>			endfunction</B>
 
		This can also be used to <A HREF="intro.html#count">count</A> matched texts with specified
		<A HREF="pattern.html#pattern">pattern</A> in the current buffer using &quot;<A HREF="pattern.html#pattern">pattern</A>&quot;: 

<B>			" Count '\&lt;foo\&gt;' in this buffer</B>
<B>			" (Note that it also updates search count)</B>
<B>			let result = searchcount(#{pattern: '\&lt;foo\&gt;'})</B>

<B>			" To restore old search count by old pattern,</B>
<B>			" search again</B>
<B>			call searchcount()</B>
 
		{options} must be a |<A HREF="eval.html#Dictionary">Dictionary</A>|. It can contain:
<B><FONT COLOR="PURPLE">		  key		type		meaning </FONT></B>
		  recompute	|<A HREF="eval.html#Boolean">Boolean</A>|	if |<A HREF="eval.html#TRUE">TRUE</A>|, recompute the <A HREF="intro.html#count">count</A>
						like |<A HREF="pattern.html#n">n</A>| or |<A HREF="pattern.html#N">N</A>| was executed.
						otherwise returns the last
						computed result (when |<A HREF="pattern.html#n">n</A>| or
						|<A HREF="pattern.html#N">N</A>| was used when &quot;<A HREF="change.html#S">S</A>&quot; is not
						in <A HREF="options.html#'shortmess'">'shortmess'</A>, or this
						function was called).
						(default: |<A HREF="eval.html#TRUE">TRUE</A>|)
		  <A HREF="pattern.html#pattern">pattern</A>	|<A HREF="eval.html#String">String</A>|	recompute if this was given
						and different with |<A HREF="change.html#@/">@/</A>|.
						this works <A HREF="motion.html#as">as</A> same <A HREF="motion.html#as">as</A> the
						below command is executed
						before calling this function
<B>						  let @/ = pattern</B>
 						(default: |<A HREF="change.html#@/">@/</A>|)
		  timeout	|<A HREF="eval.html#Number">Number</A>|	0 or negative number is no
						timeout. timeout milliseconds
						for recomputing the result
						(default: 0)
		  maxcount	|<A HREF="eval.html#Number">Number</A>|	0 or negative number is no
						limit. max <A HREF="intro.html#count">count</A> of matched
						text while recomputing the
						result.  if search exceeded
						total <A HREF="intro.html#count">count</A>, &quot;total&quot; value
						becomes `maxcount + 1`
						(default: 99)
		  pos		|<A HREF="eval.html#List">List</A>|		`[lnum, col, off]` value
						when recomputing the result.
						this changes &quot;current&quot; result
						value. see |<A HREF="#cursor()">cursor()</A>|,
						|<A HREF="#getpos()">getpos()</A>|
						(default: cursor's position)

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetSearchOpts()-&gt;searchcount()</B>
 

searchdecl({name} [, {global} [, {thisblock}]])			*<A NAME="searchdecl()"></A><B>searchdecl()</B>*
		Search for the declaration of {name}.

		With a non-zero {global} argument <A HREF="motion.html#it">it</A> works like |<A HREF="pattern.html#gD">gD</A>|, find
		first match in the file.  Otherwise <A HREF="motion.html#it">it</A> works like |<A HREF="pattern.html#gd">gd</A>|, find
		first match in the function.

		With a non-zero {thisblock} argument matches in a <A HREF="intro.html#{}">{}</A> block
		that ends before the cursor position are ignored.  Avoids
		finding variable declarations only valid in another scope.

		Moves the cursor to the found match.
		Returns zero for success, non-zero for failure.
		Example:
<B>			if searchdecl('myvar') == 0</B>
<B>			   echo getline('.')</B>
<B>			endif</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;searchdecl()</B>
 

							*<A NAME="searchpair()"></A><B>searchpair()</B>*
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		Search for the match of a nested start-end pair.  This can be
		used to find the &quot;endif&quot; that matches an &quot;if&quot;, while other
		if/endif pairs in between are ignored.
		The search starts at the cursor.  The default is to search
		forward, include '<A HREF="motion.html#b">b</A>' in {flags} to search backward.
		If a match is found, the cursor is positioned at <A HREF="motion.html#it">it</A> and the
		line number is returned.  If no match is found 0 or -1 is
		returned and the cursor doesn't move.  No error message is
		given.

		{start}, {middle} and {end} are patterns, see |<A HREF="pattern.html#pattern">pattern</A>|.  They
		must not contain \( \) pairs.  Use of \&#37;( \) is allowed.  When
		{middle} is not empty, <A HREF="motion.html#it">it</A> is found when searching from either
		direction, but only when not in a nested start-end pair.  A
		typical use is:
<B>			searchpair('\&lt;if\&gt;', '\&lt;else\&gt;', '\&lt;endif\&gt;')</B>
 		By leaving {middle} empty the &quot;else&quot; is skipped.

		{flags} '<A HREF="motion.html#b">b</A>', '<A HREF="change.html#c">c</A>', '<A HREF="pattern.html#n">n</A>', '<A HREF="change.html#s">s</A>', '<A HREF="motion.html#w">w</A>' and '<A HREF="motion.html#W">W</A>' are used like with
		|<A HREF="#search()">search()</A>|.  Additionally:
		'<A HREF="change.html#r">r</A>'	Repeat until no more matches found; will find the
			outer pair.  Implies the '<A HREF="motion.html#W">W</A>' flag.
		'<A HREF="motion.html#m">m</A>'	Return number of matches instead of line number with
			the match; will be <A HREF="change.html#&gt;">&gt;</A> 1 when '<A HREF="change.html#r">r</A>' is used.
		Note: it's nearly always a good idea to use the '<A HREF="motion.html#W">W</A>' flag, to
		avoid wrapping around the end of the file.

		When a match for {start}, {middle} or {end} is found, the
		{skip} <A HREF="eval.html#expression">expression</A> is evaluated with the cursor positioned on
		the start of the match.  It should return non-zero if this
		match is to be skipped.  E.g., because <A HREF="motion.html#it">it</A> is inside a comment
		or a <A HREF="eval.html#string">string</A>.
		When {skip} is omitted or empty, every match is accepted.
		When evaluating {skip} causes an error the search is aborted
		and -1 returned.
		{skip} can be a <A HREF="eval.html#string">string</A>, a <A HREF="eval.html#lambda">lambda</A>, a funcref or a <A HREF="#partial">partial</A>.
		Anything else makes the function fail.
		In a `:def` function when the {skip} argument is a <A HREF="eval.html#string">string</A>
		constant <A HREF="motion.html#it">it</A> is compiled into instructions.

		For {stopline} and {timeout} see |<A HREF="#search()">search()</A>|.

		The value of <A HREF="options.html#'ignorecase'">'ignorecase'</A> is used.  <A HREF="options.html#'magic'">'magic'</A> is ignored, the
		patterns are used like it's on.

		The search starts exactly at the cursor.  A match with
		{start}, {middle} or {end} at the next character, in the
		direction of searching, is the first one found.  Example:
<B>			if 1</B>
<B>			  if 2</B>
<B>			  endif 2</B>
<B>			endif 1</B>
 		When starting at the &quot;if 2&quot;, with the cursor on the &quot;<A HREF="insert.html#i">i</A>&quot;, and
		searching forwards, the &quot;endif 2&quot; is found.  When starting on
		the character just before the &quot;if 2&quot;, the &quot;endif 1&quot; will be
		found.  That's because the &quot;if 2&quot; will be found first, and
		then this is considered to be a nested if/endif from &quot;if 2&quot; to
		&quot;endif 2&quot;.
		When searching backwards and {end} is more than one character,
		<A HREF="motion.html#it">it</A> may be useful to put &quot;\zs&quot; at the end of the <A HREF="pattern.html#pattern">pattern</A>, so
		that when the cursor is inside a match with the end <A HREF="motion.html#it">it</A> finds
		the matching start.

		Example, to find the &quot;endif&quot; command in a Vim <A HREF="usr_41.html#script">script</A>:

<B>	:echo searchpair('\&lt;if\&gt;', '\&lt;el\%[seif]\&gt;', '\&lt;en\%[dif]\&gt;', 'W',</B>
<B>			\ 'getline(".") =~ "^\\s*\""')</B>

 		The cursor must be at or after the &quot;if&quot; for which a match is
		to be found.  Note that single-quote strings are used to avoid
		having to double the backslashes.  The skip <A HREF="eval.html#expression">expression</A> only
		catches comments at the start of a line, not after a command.
		Also, a <A HREF="motion.html#word">word</A> &quot;en&quot; or &quot;if&quot; halfway a line is considered a
		match.
		Another example, to search for the matching &quot;<A HREF="motion.html#{">{</A>&quot; of a &quot;<A HREF="motion.html#}">}</A>&quot;:

<B>	:echo searchpair('{', '', '}', 'bW')</B>

 		This works when the cursor is at or before the &quot;<A HREF="motion.html#}">}</A>&quot; for which a
		match is to be found.  To reject matches that <A HREF="syntax.html#syntax">syntax</A>
		highlighting recognized <A HREF="motion.html#as">as</A> strings:

<B>	:echo searchpair('{', '', '}', 'bW',</B>
<B>	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')</B>
 

							*<A NAME="searchpairpos()"></A><B>searchpairpos()</B>*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		Same <A HREF="motion.html#as">as</A> |<A HREF="#searchpair()">searchpair()</A>|, but returns a |<A HREF="eval.html#List">List</A>| with the line and
		column position of the match. The first element of the |<A HREF="eval.html#List">List</A>|
		is the line number and the second element is the byte index of
		the column position of the match.  If no match is found,
		returns [0, 0].

<B>			:let [lnum,col] = searchpairpos('{', '', '}', 'n')</B>
 
		See |<A HREF="tips.html#match-parens">match-parens</A>| for a bigger and more useful example.


							*<A NAME="searchpos()"></A><B>searchpos()</B>*
searchpos({pattern} [, {flags} [, {stopline} [, {timeout} [, {skip}]]]])
		Same <A HREF="motion.html#as">as</A> |<A HREF="#search()">search()</A>|, but returns a |<A HREF="eval.html#List">List</A>| with the line and
		column position of the match. The first element of the |<A HREF="eval.html#List">List</A>|
		is the line number and the second element is the byte index of
		the column position of the match. If no match is found,
		returns [0, 0].
		Example:
<B>	:let [lnum, col] = searchpos('mypattern', 'n')</B>

 		When the '<A HREF="change.html#p">p</A>' flag is given then there is an extra item with
		the sub-pattern match number |<A HREF="#search()-sub-match">search()-sub-match</A>|.  Example:
<B>	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')</B>
 		In this example &quot;submatch&quot; is 2 when a <A HREF="change.html#lowercase">lowercase</A> <A HREF="print.html#letter">letter</A> is
		found |<A HREF="pattern.html#/\l">/\l</A>|, 3 when an <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A> is found |<A HREF="pattern.html#/\u">/\u</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPattern()-&gt;searchpos()</B>


server2client({clientid}, {string})			*<A NAME="server2client()"></A><B>server2client()</B>*
		Send a reply <A HREF="eval.html#string">string</A> to {clientid}.  The most recent {clientid}
		that sent a <A HREF="eval.html#string">string</A> can be retrieved with expand(&quot;&lt;client&gt;&quot;).
		{only available when compiled with the |<A HREF="various.html#+clientserver">+clientserver</A>| feature}
		Returns zero for success, -1 for failure.
		Note:
		This id has to be stored before the next command can be
		received.  I.e. before returning from the received command and
		before calling any commands that waits for input.
		See also |<A HREF="remote.html#clientserver">clientserver</A>|.
		Example:
<B>			:echo server2client(expand("&lt;client&gt;"), "HELLO")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetClientId()-&gt;server2client(string)</B>
 

<A HREF="#serverlist()">serverlist()</A>					*<A NAME="serverlist()"></A><B>serverlist()</B>*
		Return a <A HREF="eval.html#list">list</A> of available server names, one per line.
		When there are no servers or the information is not available
		an empty <A HREF="eval.html#string">string</A> is returned.  See also |<A HREF="remote.html#clientserver">clientserver</A>|.
		{only available when compiled with the |<A HREF="various.html#+clientserver">+clientserver</A>| feature}
		Example:
<B>			:echo serverlist()</B>
 

setbufline({buf}, {lnum}, {text})			*<A NAME="setbufline()"></A><B>setbufline()</B>*
		Set line {lnum} to {text} in buffer {buf}.  This works like
		|<A HREF="#setline()">setline()</A>| for the specified buffer.

		This function works only for loaded <A HREF="windows.html#buffers">buffers</A>. First call
		|<A HREF="#bufload()">bufload()</A>| if needed.

		To insert lines use |<A HREF="#appendbufline()">appendbufline()</A>|.
		Any text properties in {lnum} are cleared.

		{text} can be a <A HREF="eval.html#string">string</A> to set one line, or a <A HREF="eval.html#list">list</A> of strings
		to set multiple lines.  If the <A HREF="eval.html#list">list</A> extends below the last
		line then those lines are added.

		For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>| above.

		{lnum} is used like with |<A HREF="#setline()">setline()</A>|.
		Use &quot;<A HREF="motion.html#$">$</A>&quot; to refer to the last line in buffer {buf}.
		When {lnum} is just below the last line the {text} will be
		added below the last line.

		When {buf} is not a valid buffer, the buffer is not loaded or
		{lnum} is not valid then 1 is returned.  In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an
		error is given.
		On success 0 is returned.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		third argument:
<B>			GetText()-&gt;setbufline(buf, lnum)</B>


setbufvar({buf}, {varname}, {val})			*<A NAME="setbufvar()"></A><B>setbufvar()</B>*
		Set option or local variable {varname} in buffer {buf} to
		{val}.
		This also works for a global or local <A HREF="windows.html#window">window</A> option, but <A HREF="motion.html#it">it</A>
		doesn't work for a global or local <A HREF="windows.html#window">window</A> variable.
		For a local <A HREF="windows.html#window">window</A> option the global value is unchanged.
		For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>| above.
		The {varname} argument is a <A HREF="eval.html#string">string</A>.
		Note that the variable name without &quot;<A HREF="eval.html#b:">b:</A>&quot; must be used.
		Examples:
<B>			:call setbufvar(1, "&amp;mod", 1)</B>
<B>			:call setbufvar("todo", "myvar", "foobar")</B>
 		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		third argument:
<B>			GetValue()-&gt;setbufvar(buf, varname)</B>



setcellwidths({list})					*<A NAME="setcellwidths()"></A><B>setcellwidths()</B>*
		Specify overrides for cell widths of character ranges.  This
		tells Vim how wide characters are, counted in screen cells.
		This overrides <A HREF="options.html#'ambiwidth'">'ambiwidth'</A>.  Example:
<B>		   setcellwidths([[0xad, 0xad, 1],</B>
<B>				\ [0x2194, 0x2199, 2]])</B>


 				*<A NAME="E1109"></A><B>E1109</B>* *<A NAME="E1110"></A><B>E1110</B>* *<A NAME="E1111"></A><B>E1111</B>* *<A NAME="E1112"></A><B>E1112</B>* *<A NAME="E1113"></A><B>E1113</B>* *<A NAME="E1114"></A><B>E1114</B>*
		The {list} argument is a <A HREF="eval.html#list">list</A> of lists with each three
		numbers. These three numbers are [low, high, width].  &quot;low&quot;
		and &quot;high&quot; can be the same, in which <A HREF="change.html#case">case</A> this refers to one
		character. Otherwise <A HREF="motion.html#it">it</A> is the range of characters from &quot;low&quot;
		to &quot;high&quot; (inclusive).  &quot;width&quot; is either 1 or 2, indicating
		the character width in screen cells.
		An error is given if the argument is invalid, also when a
		range overlaps with another.
		Only characters with value 0x100 and higher can be used.

		If the new value causes <A HREF="options.html#'fillchars'">'fillchars'</A> or <A HREF="options.html#'listchars'">'listchars'</A> to become
		invalid <A HREF="motion.html#it">it</A> is rejected and an error is given.

		To clear the overrides pass an empty <A HREF="eval.html#list">list</A>:
<B>		   setcellwidths([]);</B>
 		You can use the <A HREF="usr_41.html#script">script</A> $VIMRUNTIME/tools/emoji_list.vim to see
		the effect for known emoji characters.


setcharpos({expr}, {list})				*<A NAME="setcharpos()"></A><B>setcharpos()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#setpos()">setpos()</A>| but uses the specified column number <A HREF="motion.html#as">as</A> the
		character index instead of the byte index in the line.

		Example:
		With the text &quot;&quot; in line 8:
<B>			call setcharpos('.', [0, 8, 4, 0])</B>
 		positions the cursor on the fourth character ''.
<B>			call setpos('.', [0, 8, 4, 0])</B>
 		positions the cursor on the second character ''.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPosition()-&gt;setcharpos('.')</B>


setcharsearch({dict})					*<A NAME="setcharsearch()"></A><B>setcharsearch()</B>*
		Set the current character search information to {dict},
		which contains one or more of the following entries:

		    char	character which will be used for a subsequent
				|<A HREF="motion.html#,">,</A>| or |<A HREF="motion.html#;">;</A>| command; an empty <A HREF="eval.html#string">string</A> clears the
				character search
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |<A HREF="motion.html#t">t</A>| or |<A HREF="motion.html#T">T</A>|
				character search, 0 for an |<A HREF="motion.html#f">f</A>| or |<A HREF="motion.html#F">F</A>|
				character search

		This can be useful to save/restore a user's character search
		from a <A HREF="usr_41.html#script">script</A>:
<B>			:let prevsearch = getcharsearch()</B>
<B>			:" Perform a command which clobbers user's search</B>
<B>			:call setcharsearch(prevsearch)</B>
 		Also see |<A HREF="#getcharsearch()">getcharsearch()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			SavedSearch()-&gt;setcharsearch()</B>


setcmdpos({pos})					*<A NAME="setcmdpos()"></A><B>setcmdpos()</B>*
		Set the cursor position in the command line to byte position
		{pos}.  The first position is 1.
		Use |<A HREF="#getcmdpos()">getcmdpos()</A>| to obtain the current position.
		Only works while editing the command line, thus you must use
		|<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>|, |<A HREF="cmdline.html#c_CTRL-R_=">c_CTRL-R_=</A>| or |<A HREF="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</A>| with '='.  For
		|<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>| and |<A HREF="cmdline.html#c_CTRL-R_CTRL-R">c_CTRL-R_CTRL-R</A>| with '<A HREF="change.html#=">=</A>' the position is
		set after the command line is set to the <A HREF="eval.html#expression">expression</A>.  For
		|<A HREF="cmdline.html#c_CTRL-R_=">c_CTRL-R_=</A>| <A HREF="motion.html#it">it</A> is set after evaluating the <A HREF="eval.html#expression">expression</A> but
		before <A HREF="insert.html#inserting">inserting</A> the resulting text.
		When the number is too big the cursor is put at the end of the
		line.  A number smaller than one has undefined results.
		Returns <A HREF="eval.html#FALSE">FALSE</A> when successful, <A HREF="eval.html#TRUE">TRUE</A> when not editing the
		command line.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPos()-&gt;setcmdpos()</B>


setcursorcharpos({lnum}, {col} [, {off}])		*<A NAME="setcursorcharpos()"></A><B>setcursorcharpos()</B>*
setcursorcharpos({list})
		Same <A HREF="motion.html#as">as</A> |<A HREF="#cursor()">cursor()</A>| but uses the specified column number <A HREF="motion.html#as">as</A> the
		character index instead of the byte index in the line.

		Example:
		With the text &quot;&quot; in line 4:
<B>			call setcursorcharpos(4, 3)</B>
 		positions the cursor on the third character ''.
<B>			call cursor(4, 3)</B>
 		positions the cursor on the first character ''.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetCursorPos()-&gt;setcursorcharpos()</B>



setenv({name}, {val})						*<A NAME="setenv()"></A><B>setenv()</B>*
		Set environment variable {name} to {val}.  Example:
<B>			call setenv('HOME', '/home/myhome')</B>

 		When {val} is |<A HREF="eval.html#v:null">v:null</A>| the environment variable is deleted.
		See also |<A HREF="eval.html#expr-env">expr-env</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetPath()-&gt;setenv('PATH')</B>


setfperm({fname}, {mode})				*<A NAME="setfperm()"></A><B>setfperm()</B>* *<A NAME="chmod"></A><B>chmod</B>*
		Set the file permissions for {fname} to {mode}.
		{mode} must be a <A HREF="eval.html#string">string</A> with 9 characters.  It is of the form
		&quot;rwxrwxrwx&quot;, where each group of &quot;rwx&quot; flags represent, in
		turn, the permissions of the owner of the file, the group the
		file belongs to, and other users.  A '<A HREF="motion.html#-">-</A>' character means the
		permission is off, any other character means on.  Multi-byte
		characters are not supported.

		For example &quot;rw-r-----&quot; means read-write for the user,
		readable by the group, not accessible by others.  &quot;xx-x-----&quot;
		would <A HREF="diff.html#do">do</A> the same thing.

		Returns non-zero for success, zero for failure.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFilename()-&gt;setfperm(mode)</B>
 
		To read permissions see |<A HREF="#getfperm()">getfperm()</A>|.



setline({lnum}, {text})					*<A NAME="setline()"></A><B>setline()</B>*
		Set line {lnum} of the current buffer to {text}.  To insert
		lines use |<A HREF="#append()">append()</A>|. To set lines in another buffer use
		|<A HREF="#setbufline()">setbufline()</A>|.  Any text properties in {lnum} are cleared.

		{lnum} is used like with |<A HREF="#getline()">getline()</A>|.
		When {lnum} is just below the last line the {text} will be
		added below the last line.
		{text} can be any type or a <A HREF="eval.html#List">List</A> of any type, each item is
		converted to a <A HREF="eval.html#String">String</A>.

		If this succeeds, <A HREF="eval.html#FALSE">FALSE</A> is returned.  If this fails (most likely
		because {lnum} is invalid) <A HREF="eval.html#TRUE">TRUE</A> is returned.
		In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an error is given if {lnum} is invalid.

		Example:
<B>			:call setline(5, strftime("%c"))</B>

 		When {text} is a |<A HREF="eval.html#List">List</A>| then line {lnum} and following lines
		will be set to the items in the <A HREF="eval.html#list">list</A>.  Example:
<B>			:call setline(5, ['aaa', 'bbb', 'ccc'])</B>
 		This is equivalent to:
<B>			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]</B>
<B>			:  call setline(n, l)</B>
<B>			:endfor</B>

 		Note: The <A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A> marks are not set.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetText()-&gt;setline(lnum)</B>


setloclist({nr}, {list} [, {action} [, {what}]])		*<A NAME="setloclist()"></A><B>setloclist()</B>*
		Create or replace or add to the location <A HREF="eval.html#list">list</A> for <A HREF="windows.html#window">window</A> {nr}.
		{nr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {nr} is zero the current <A HREF="windows.html#window">window</A> is used.

		For a location <A HREF="eval.html#list">list</A> <A HREF="windows.html#window">window</A>, the displayed location <A HREF="eval.html#list">list</A> is
		modified.  For an invalid <A HREF="windows.html#window">window</A> number {nr}, -1 is returned.
		Otherwise, same <A HREF="motion.html#as">as</A> |<A HREF="#setqflist()">setqflist()</A>|.
		Also see |<A HREF="quickfix.html#location-list">location-list</A>|.

		For {action} see |<A HREF="#setqflist-action">setqflist-action</A>|.

		If the optional {what} dictionary argument is supplied, then
		only the items listed in {what} are set. Refer to |<A HREF="#setqflist()">setqflist()</A>|
		for the <A HREF="eval.html#list">list</A> of supported keys in {what}.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetLoclist()-&gt;setloclist(winnr)</B>


setmatches({list} [, {win}])				*<A NAME="setmatches()"></A><B>setmatches()</B>*
		Restores a <A HREF="eval.html#list">list</A> of matches saved by |<A HREF="#getmatches()">getmatches()</A>| for the
		current <A HREF="windows.html#window">window</A>.  Returns 0 if successful, otherwise -1.  All
		current matches are cleared before the <A HREF="eval.html#list">list</A> is restored.  See
		example for |<A HREF="#getmatches()">getmatches()</A>|.
		If {win} is specified, use the <A HREF="windows.html#window">window</A> with this number or
		<A HREF="windows.html#window">window</A> ID instead of the current <A HREF="windows.html#window">window</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMatches()-&gt;setmatches()</B>
 

							*<A NAME="setpos()"></A><B>setpos()</B>*
setpos({expr}, {list})
		Set the position for <A HREF="eval.html#String">String</A> {expr}.  Possible values:
			.	the cursor
			'x	<A HREF="motion.html#mark">mark</A> <A HREF="change.html#x">x</A>

		{list} must be a |<A HREF="eval.html#List">List</A>| with four or five numbers:
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]

		&quot;bufnum&quot; is the buffer number.  Zero can be used for the
		current buffer.  When setting an <A HREF="change.html#uppercase">uppercase</A> <A HREF="motion.html#mark">mark</A> &quot;bufnum&quot; is
		used for the <A HREF="motion.html#mark">mark</A> position.  For other marks <A HREF="motion.html#it">it</A> specifies the
		buffer to set the <A HREF="motion.html#mark">mark</A> in.  You can use the |<A HREF="#bufnr()">bufnr()</A>| function
		to turn a file name into a buffer number.
		For setting the cursor and the '' <A HREF="motion.html#mark">mark</A> &quot;bufnum&quot; is ignored,
		since these are associated with a <A HREF="windows.html#window">window</A>, not a buffer.
		Does not change the <A HREF="motion.html#jumplist">jumplist</A>.

		&quot;lnum&quot; and &quot;col&quot; are the position in the buffer.  The first
		column is 1.  Use a zero &quot;lnum&quot; to delete a <A HREF="motion.html#mark">mark</A>.  If &quot;col&quot; is
		smaller than 1 then 1 is used. To use the character <A HREF="intro.html#count">count</A>
		instead of the byte <A HREF="intro.html#count">count</A>, use |<A HREF="#setcharpos()">setcharpos()</A>|.

		The &quot;off&quot; number is only used when <A HREF="options.html#'virtualedit'">'virtualedit'</A> is set. Then
		<A HREF="motion.html#it">it</A> is the offset in screen columns from the start of the
		character.  E.g., a position within a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> or after the last
		character.

		The &quot;curswant&quot; number is only used when setting the cursor
		position.  It sets the preferred column for when moving the
		cursor vertically.  When the &quot;curswant&quot; number is missing the
		preferred column is not set.  When <A HREF="motion.html#it">it</A> is present and setting a
		<A HREF="motion.html#mark">mark</A> position <A HREF="motion.html#it">it</A> is not used.

		Note that for <A HREF="motion.html#'&lt;">'&lt;</A> and <A HREF="motion.html#'&gt;">'&gt;</A> <A HREF="change.html#changing">changing</A> the line number may result in
		the marks to be effectively be swapped, so that <A HREF="motion.html#'&lt;">'&lt;</A> is always
		before <A HREF="motion.html#'&gt;">'&gt;</A>.

		Returns 0 when the position could be set, -1 otherwise.
		An error message is given if {expr} is invalid.

		Also see |<A HREF="#setcharpos()">setcharpos()</A>|, |<A HREF="#getpos()">getpos()</A>| and |<A HREF="#getcurpos()">getcurpos()</A>|.

		This does not restore the preferred column for moving
		vertically; if you set the cursor position with this, |<A HREF="motion.html#j">j</A>| and
		|<A HREF="motion.html#k">k</A>| motions will jump to previous columns!  Use |<A HREF="#cursor()">cursor()</A>| to
		also set the preferred column.  Also see the &quot;curswant&quot; key in
		|<A HREF="#winrestview()">winrestview()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPosition()-&gt;setpos('.')</B>


setqflist({list} [, {action} [, {what}]])		*<A NAME="setqflist()"></A><B>setqflist()</B>*
		Create or replace or add to the <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>.

		If the optional {what} dictionary argument is supplied, then
		only the items listed in {what} are set. The first {list}
		argument is ignored.  See below for the supported items in
		{what}.

							*<A NAME="setqflist-what"></A><B>setqflist-what</B>*
		When {what} is not present, the items in {list} are used.  Each
		item must be a dictionary.  Non-dictionary items in {list} are
		ignored.  Each dictionary item can contain the following
		entries:

		    bufnr	buffer number; must be the number of a valid
				buffer
		    filename	name of a file; only used when &quot;bufnr&quot; is not
				present or <A HREF="motion.html#it">it</A> is invalid.
		    module	name of a module; if given <A HREF="motion.html#it">it</A> will be used in
				<A HREF="quickfix.html#quickfix">quickfix</A> error <A HREF="windows.html#window">window</A> instead of the filename.
		    lnum	line number in the file
		    end_lnum	end of lines, if the item spans multiple lines
		    <A HREF="pattern.html#pattern">pattern</A>	search <A HREF="pattern.html#pattern">pattern</A> used to locate the error
		    col		column number
		    vcol	when non-zero: &quot;col&quot; is visual column
				when zero: &quot;col&quot; is byte index
		    end_col	end column, if the item spans multiple columns
		    nr		error number
		    text	description of the error
		    type	single-character error type, '<A HREF="motion.html#E">E</A>', '<A HREF="motion.html#W">W</A>', etc.
		    valid	recognized error message

		The &quot;col&quot;, &quot;vcol&quot;, &quot;nr&quot;, &quot;type&quot; and &quot;text&quot; entries are
		optional.  Either &quot;lnum&quot; or &quot;<A HREF="pattern.html#pattern">pattern</A>&quot; entry can be used to
		locate a matching error line.
		If the &quot;filename&quot; and &quot;bufnr&quot; entries are not present or
		neither the &quot;lnum&quot; or &quot;<A HREF="pattern.html#pattern">pattern</A>&quot; entries are present, then the
		item will not be handled <A HREF="motion.html#as">as</A> an error line.
		If both &quot;<A HREF="pattern.html#pattern">pattern</A>&quot; and &quot;lnum&quot; are present then &quot;<A HREF="pattern.html#pattern">pattern</A>&quot; will
		be used.
		If the &quot;valid&quot; entry is not supplied, then the valid flag is
		set when &quot;bufnr&quot; is a valid buffer or &quot;filename&quot; exists.
		If you supply an empty {list}, the <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> will be
		cleared.
		Note that the <A HREF="eval.html#list">list</A> is not exactly the same <A HREF="motion.html#as">as</A> what
		|<A HREF="#getqflist()">getqflist()</A>| returns.


		{action} values:		*<A NAME="setqflist-action"></A><B>setqflist-action</B>* *<A NAME="E927"></A><B>E927</B>*
		'<A HREF="insert.html#a">a</A>'	The items from {list} are added to the existing
			<A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>. If there is no existing <A HREF="eval.html#list">list</A>, then a
			new <A HREF="eval.html#list">list</A> is created.

		'<A HREF="change.html#r">r</A>'	The items from the current <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> are replaced
			with the items from {list}.  This can also be used to
			clear the <A HREF="eval.html#list">list</A>:
<B>				:call setqflist([], 'r')</B>
 
		'<A HREF="motion.html#f">f</A>'	All the <A HREF="quickfix.html#quickfix">quickfix</A> lists in the <A HREF="quickfix.html#quickfix">quickfix</A> stack are
			freed.

		If {action} is not present or is set to '' '', then a new <A HREF="eval.html#list">list</A>
		is created. The new <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> is added after the current
		<A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> in the stack and all the following lists are
		freed. To add a new <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> at the end of the stack,
		set &quot;nr&quot; in {what} to &quot;<A HREF="motion.html#$">$</A>&quot;.

		The following items can be specified in dictionary {what}:
		    context	quickfix <A HREF="eval.html#list">list</A> context. See |<A HREF="quickfix.html#quickfix-context">quickfix-context</A>|
		    efm		<A HREF="quickfix.html#errorformat">errorformat</A> to use when parsing text from
				&quot;lines&quot;. If this is not present, then the
				<A HREF="options.html#'errorformat'">'errorformat'</A> option value is used.
				See |<A HREF="quickfix.html#quickfix-parse">quickfix-parse</A>|
		    id		quickfix <A HREF="eval.html#list">list</A> identifier |<A HREF="quickfix.html#quickfix-ID">quickfix-ID</A>|
		    idx		index of the current entry in the <A HREF="quickfix.html#quickfix">quickfix</A>
				<A HREF="eval.html#list">list</A> specified by 'id' or 'nr'. If set to '<A HREF="motion.html#$">$</A>',
				then the last entry in the <A HREF="eval.html#list">list</A> is set <A HREF="motion.html#as">as</A> the
				current entry.  See |<A HREF="quickfix.html#quickfix-index">quickfix-index</A>|
		    items	<A HREF="eval.html#list">list</A> of <A HREF="quickfix.html#quickfix">quickfix</A> entries. Same <A HREF="motion.html#as">as</A> the {list}
				argument.
		    lines	use <A HREF="options.html#'errorformat'">'errorformat'</A> to parse a <A HREF="eval.html#list">list</A> of lines and
				add the resulting entries to the <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>
				{nr} or {id}.  Only a |<A HREF="eval.html#List">List</A>| value is supported.
				See |<A HREF="quickfix.html#quickfix-parse">quickfix-parse</A>|
		    nr		<A HREF="eval.html#list">list</A> number in the <A HREF="quickfix.html#quickfix">quickfix</A> stack; zero
				means the current <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A> and &quot;<A HREF="motion.html#$">$</A>&quot; means
				the last <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>.
		    quickfixtextfunc
				function to get the text to display in the
				<A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="windows.html#window">window</A>.  The value can be the name of
				a function or a funcref or a <A HREF="eval.html#lambda">lambda</A>.  Refer to
				|<A HREF="quickfix.html#quickfix-window-function">quickfix-window-function</A>| for an explanation
				of how to write the function and an example.
		    title	quickfix <A HREF="eval.html#list">list</A> title text. See |<A HREF="quickfix.html#quickfix-title">quickfix-title</A>|
		Unsupported keys in {what} are ignored.
		If the &quot;nr&quot; item is not present, then the current <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>
		is modified. When creating a new <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>, &quot;nr&quot; can be
		set to a value one greater than the <A HREF="quickfix.html#quickfix">quickfix</A> stack size.
		When modifying a <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>, to guarantee that the correct
		<A HREF="eval.html#list">list</A> is modified, &quot;id&quot; should be used instead of &quot;nr&quot; to
		specify the <A HREF="eval.html#list">list</A>.

		Examples (See also |<A HREF="quickfix.html#setqflist-examples">setqflist-examples</A>|):
<B>		   :call setqflist([], 'r', {'title': 'My search'})</B>
<B>		   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})</B>
<B>		   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})</B>
 
		Returns zero for success, -1 for failure.

		This function can be used to create a <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>
		independent of the <A HREF="options.html#'errorformat'">'errorformat'</A> setting.  Use a command like
		`:cc 1` to jump to the first position.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetErrorlist()-&gt;setqflist()</B>
 

							*<A NAME="setreg()"></A><B>setreg()</B>*
setreg({regname}, {value} [, {options}])
		Set the <A HREF="sponsor.html#register">register</A> {regname} to {value}.
		If {regname} is &quot;&quot; or &quot;<A HREF="repeat.html#@">@</A>&quot;, the unnamed <A HREF="sponsor.html#register">register</A> &#39;&#34;'' is used.
		The {regname} argument is a <A HREF="eval.html#string">string</A>.  In |<A HREF="vim9.html#Vim9-script">Vim9-script</A>|
		{regname} must be one character.

		{value} may be any value returned by |<A HREF="#getreg()">getreg()</A>| or
		|<A HREF="#getreginfo()">getreginfo()</A>|, including a |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dict">Dict</A>|.
		If {options} contains &quot;<A HREF="insert.html#a">a</A>&quot; or {regname} is upper <A HREF="change.html#case">case</A>,
		then the value is appended.

		{options} can also contain a <A HREF="sponsor.html#register">register</A> type specification:
		    &quot;c&quot; or &quot;<A HREF="visual.html#v">v</A>&quot;	      |<A HREF="motion.html#characterwise">characterwise</A>| mode
		    &quot;l&quot; or &quot;<A HREF="visual.html#V">V</A>&quot;	      |<A HREF="motion.html#linewise">linewise</A>| mode
		    &quot;b&quot; or &quot;&lt;CTRL-V&gt;&quot; |<A HREF="visual.html#blockwise-visual">blockwise-visual</A>| mode
		If a number immediately follows &quot;<A HREF="motion.html#b">b</A>&quot; or &quot;&lt;CTRL-V&gt;&quot; then this is
		used <A HREF="motion.html#as">as</A> the width of the selection - if <A HREF="motion.html#it">it</A> is not specified
		then the width of the block is set to the number of characters
		in the longest line (counting a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> <A HREF="motion.html#as">as</A> 1 character).

		If {options} contains no <A HREF="sponsor.html#register">register</A> settings, then the default
		is to use character mode unless {value} ends in a <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A> for
		<A HREF="eval.html#string">string</A> {value} and <A HREF="motion.html#linewise">linewise</A> mode for <A HREF="eval.html#list">list</A> {value}. Blockwise
		mode is never selected automatically.
		Returns zero for success, non-zero for failure.


							*<A NAME="E883"></A><B>E883</B>*
		Note: you may not use |<A HREF="eval.html#List">List</A>| containing more than one item to
		      set search and <A HREF="eval.html#expression">expression</A> <A HREF="change.html#registers">registers</A>. <A HREF="eval.html#Lists">Lists</A> containing no
		      items act like empty strings.

		Examples:
<B>			:call setreg(v:register, @*)</B>
<B>			:call setreg('*', @%, 'ac')</B>
<B>			:call setreg('a', "1\n2\n3", 'b5')</B>
<B>			:call setreg('"', { 'points_to': 'a'})</B>

 		This example shows using the <A HREF="eval.html#functions">functions</A> to save and restore a
		<A HREF="sponsor.html#register">register</A>:
<B>			:let var_a = getreginfo()</B>
<B>			:call setreg('a', var_a)</B>
 		or:
<B>			:let var_a = getreg('a', 1, 1)</B>
<B>			:let var_amode = getregtype('a')</B>
<B>			    ....</B>
<B>			:call setreg('a', var_a, var_amode)</B>
 		Note: you may not reliably restore <A HREF="sponsor.html#register">register</A> value
		without using the third argument to |<A HREF="#getreg()">getreg()</A>| <A HREF="motion.html#as">as</A> without <A HREF="motion.html#it">it</A>
		newlines are represented <A HREF="motion.html#as">as</A> newlines AND Nul bytes are
		represented <A HREF="motion.html#as">as</A> newlines <A HREF="motion.html#as">as</A> well, see |<A HREF="pattern.html#NL-used-for-Nul">NL-used-for-Nul</A>|.

		You can also change the type of a <A HREF="sponsor.html#register">register</A> by appending
		nothing:
<B>			:call setreg('a', '', 'al')</B>

 		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetText()-&gt;setreg('a')</B>


settabvar({tabnr}, {varname}, {val})			*<A NAME="settabvar()"></A><B>settabvar()</B>*
		Set tab-local variable {varname} to {val} in <A HREF="intro.html#tab">tab</A> page {tabnr}.
		|<A HREF="eval.html#t:var">t:var</A>|
		The {varname} argument is a <A HREF="eval.html#string">string</A>.
		Note that <A HREF="autocmd.html#autocommands">autocommands</A> are blocked, side effects may not be
		triggered, e.g. when setting <A HREF="options.html#'filetype'">'filetype'</A>.
		Note that the variable name without &quot;<A HREF="eval.html#t:">t:</A>&quot; must be used.
		Tabs are numbered starting with one.
		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		third argument:
<B>			GetValue()-&gt;settabvar(tab, name)</B>


settabwinvar({tabnr}, {winnr}, {varname}, {val})	*<A NAME="settabwinvar()"></A><B>settabwinvar()</B>*
		Set option or local variable {varname} in <A HREF="windows.html#window">window</A> {winnr} to
		{val}.
		Tabs are numbered starting with one.  For the current <A HREF="tabpage.html#tabpage">tabpage</A>
		use |<A HREF="#setwinvar()">setwinvar()</A>|.
		{winnr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {winnr} is zero the current <A HREF="windows.html#window">window</A> is used.
		Note that <A HREF="autocmd.html#autocommands">autocommands</A> are blocked, side effects may not be
		triggered, e.g. when setting <A HREF="options.html#'filetype'">'filetype'</A> or <A HREF="options.html#'syntax'">'syntax'</A>.
		This also works for a global or local buffer option, but <A HREF="motion.html#it">it</A>
		doesn't work for a global or local buffer variable.
		For a local buffer option the global value is unchanged.
		Note that the variable name without &quot;<A HREF="eval.html#w:">w:</A>&quot; must be used.
		Examples:
<B>			:call settabwinvar(1, 1, "&amp;list", 0)</B>
<B>			:call settabwinvar(3, 2, "myvar", "foobar")</B>
 		This function is not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		fourth argument:
<B>			GetValue()-&gt;settabwinvar(tab, winnr, name)</B>


settagstack({nr}, {dict} [, {action}])			*<A NAME="settagstack()"></A><B>settagstack()</B>*
		Modify the <A HREF="tagsrch.html#tag">tag</A> stack of the <A HREF="windows.html#window">window</A> {nr} using {dict}.
		{nr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.

		For a <A HREF="eval.html#list">list</A> of supported items in {dict}, refer to
		|<A HREF="#gettagstack()">gettagstack()</A>|. &quot;curidx&quot; takes effect before <A HREF="change.html#changing">changing</A> the tag
		stack.

							*<A NAME="E962"></A><B>E962</B>*
		How the <A HREF="tagsrch.html#tag">tag</A> stack is modified depends on the {action}
		argument:
		- If {action} is not present or is set to '<A HREF="change.html#r">r</A>', then the <A HREF="tagsrch.html#tag">tag</A>
		  stack is replaced.
		- If {action} is set to '<A HREF="insert.html#a">a</A>', then new entries from {dict} are
		  pushed (added) onto the <A HREF="tagsrch.html#tag">tag</A> stack.
		- If {action} is set to '<A HREF="motion.html#t">t</A>', then all the entries from the
		  current entry in the <A HREF="tagsrch.html#tag">tag</A> stack or &quot;curidx&quot; in {dict} are
		  removed and then new entries are pushed to the stack.

		The current index is set to one after the length of the <A HREF="tagsrch.html#tag">tag</A>
		stack after the modification.

		Returns zero for success, -1 for failure.

		Examples (for more examples see |<A HREF="tagsrch.html#tagstack-examples">tagstack-examples</A>|):
		    Empty the <A HREF="tagsrch.html#tag">tag</A> stack of <A HREF="windows.html#window">window</A> 3:
<B>			call settagstack(3, {'items' : []})</B>

 		    Save and restore the <A HREF="tagsrch.html#tag">tag</A> stack:
<B>			let stack = gettagstack(1003)</B>
<B>			" do something else</B>
<B>			call settagstack(1003, stack)</B>
<B>			unlet stack</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetStack()-&gt;settagstack(winnr)</B>


setwinvar({winnr}, {varname}, {val})			*<A NAME="setwinvar()"></A><B>setwinvar()</B>*
		Like |<A HREF="#settabwinvar()">settabwinvar()</A>| for the current tab page.
		Examples:
<B>			:call setwinvar(1, "&amp;list", 0)</B>
<B>			:call setwinvar(2, "myvar", "foobar")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		third argument:
<B>			GetValue()-&gt;setwinvar(winnr, name)</B>


sha256({string})						*<A NAME="sha256()"></A><B>sha256()</B>*
		Returns a <A HREF="eval.html#String">String</A> with 64 hex characters, which is the SHA256
		checksum of {string}.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;sha256()</B>

 		{only available when compiled with the |<A HREF="various.html#+cryptv">+cryptv</A>| feature}


shellescape({string} [, {special}])			*<A NAME="shellescape()"></A><B>shellescape()</B>*
		Escape {string} for use <A HREF="motion.html#as">as</A> a shell command argument.
		When the <A HREF="options.html#'shell'">'shell'</A> contains powershell (MS-Windows) or pwsh
		(MS-Windows, Linux, and macOS) then <A HREF="motion.html#it">it</A> will enclose {string}
		in single <A HREF="quotes.html#quotes">quotes</A> and will double up all internal single
		<A HREF="quotes.html#quotes">quotes</A>.
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, when <A HREF="options.html#'shellslash'">'shellslash'</A> is not set, <A HREF="motion.html#it">it</A> will enclose
		{string} in double <A HREF="quotes.html#quotes">quotes</A> and double all double <A HREF="quotes.html#quotes">quotes</A> within
		{string}.
		Otherwise <A HREF="motion.html#it">it</A> will enclose {string} in single <A HREF="quotes.html#quotes">quotes</A> and
		replace all &quot;&#39;&#34;' with &quot;'\'&#39;&#34;'.

		When the {special} argument is present and it's a non-zero
		<A HREF="eval.html#Number">Number</A> or a non-empty <A HREF="eval.html#String">String</A> (|<A HREF="eval.html#non-zero-arg">non-zero-arg</A>|), then special
		items such <A HREF="motion.html#as">as</A> &quot;<A HREF="change.html#!">!</A>&quot;, &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot;, &quot;<A HREF="pattern.html##">#</A>&quot; and &quot;<A HREF="cmdline.html#&lt;cword&gt;">&lt;cword&gt;</A>&quot; will be preceded by
		a <A HREF="intro.html#backslash">backslash</A>.  This <A HREF="intro.html#backslash">backslash</A> will be removed again by the |<A HREF="various.html#:!">:!</A>|
		command.

		The &quot;<A HREF="change.html#!">!</A>&quot; character will be escaped (again with a |<A HREF="eval.html#non-zero-arg">non-zero-arg</A>|
		{special}) when <A HREF="options.html#'shell'">'shell'</A> contains &quot;csh&quot; in the tail.  That is
		because for csh and tcsh &quot;<A HREF="change.html#!">!</A>&quot; is used for <A HREF="cmdline.html#history">history</A> replacement
		even when inside single <A HREF="quotes.html#quotes">quotes</A>.

		With a |<A HREF="eval.html#non-zero-arg">non-zero-arg</A>| {special} the <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A> character is also
		escaped.  When <A HREF="options.html#'shell'">'shell'</A> containing &quot;csh&quot; in the tail it's
		escaped a second time.

		The &quot;\&quot; character will be escaped when <A HREF="options.html#'shell'">'shell'</A> contains &quot;fish&quot;
		in the tail. That is because for fish &quot;\&quot; is used <A HREF="motion.html#as">as</A> an <A HREF="intro.html#escape">escape</A>
		character inside single <A HREF="quotes.html#quotes">quotes</A>.

		Example of use with a |<A HREF="various.html#:!">:!</A>| command:
<B>		    :exe '!dir ' .. shellescape(expand('&lt;cfile&gt;'), 1)</B>
 		This results in a directory listing for the file under the
		cursor.  Example of use with YXXYsystem()|:
<B>		    :call system("chmod +w -- " .. shellescape(expand("%")))</B>
 		See also |<A HREF="cmdline.html#::S">::S</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetCommand()-&gt;shellescape()</B>


shiftwidth([{col}])						*<A NAME="shiftwidth()"></A><B>shiftwidth()</B>*
		Returns the effective value of <A HREF="options.html#'shiftwidth'">'shiftwidth'</A>. This is the
		<A HREF="options.html#'shiftwidth'">'shiftwidth'</A> value unless <A HREF="motion.html#it">it</A> is zero, in which <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> is the
		<A HREF="options.html#'tabstop'">'tabstop'</A> value.  This function was introduced with patch
		7.3.694 in 2012, everybody should have <A HREF="motion.html#it">it</A> by now (however <A HREF="motion.html#it">it</A>
		did not allow for the optional {col} argument until 8.1.542).

		When there is one argument {col} this is used <A HREF="motion.html#as">as</A> column number
		for which to return the <A HREF="options.html#'shiftwidth'">'shiftwidth'</A> value. This matters for the
		<A HREF="options.html#'vartabstop'">'vartabstop'</A> feature. If the <A HREF="options.html#'vartabstop'">'vartabstop'</A> setting is enabled and
		no {col} argument is given, column 1 will be assumed.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetColumn()-&gt;shiftwidth()</B>

sign_ functions are documented here: |<A HREF="sign.html#sign-functions-details">sign-functions-details</A>|



simplify({filename})					*<A NAME="simplify()"></A><B>simplify()</B>*
		Simplify the file name <A HREF="motion.html#as">as</A> much <A HREF="motion.html#as">as</A> possible without <A HREF="change.html#changing">changing</A>
		the meaning.  Shortcuts (on <A HREF="os_win32.html#MS-Windows">MS-Windows</A>) or symbolic links (on
		<A HREF="os_unix.html#Unix">Unix</A>) are not resolved.  If the first path component in
		{filename} designates the current directory, this will be
		valid for the result <A HREF="motion.html#as">as</A> well.  A trailing path separator is
		not removed either. On <A HREF="os_unix.html#Unix">Unix</A> &quot;//path&quot; is unchanged, but
		&quot;///path&quot; is simplified to &quot;/path&quot; (this follows the <A HREF="intro.html#Posix">Posix</A>
		standard).
		Example:
<B>			simplify("./dir/.././/file/") == "./file/"</B>
 		Note: The combination &quot;dir/..&quot; is only removed if &quot;dir&quot; is
		a searchable directory or does not exist.  On <A HREF="os_unix.html#Unix">Unix</A>, <A HREF="motion.html#it">it</A> is also
		removed when &quot;dir&quot; is a symbolic link within the same
		directory.  In order to resolve all the involved symbolic
		links before simplifying the path name, use |<A HREF="#resolve()">resolve()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetName()-&gt;simplify()</B>


sin({expr})						*<A NAME="sin()"></A><B>sin()</B>*
		Return the sine of {expr}, measured in radians, <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|.
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo sin(100)</B>
 			-0.506366
<B>			:echo sin(-4.01)</B>
 			0.763301

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;sin()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



sinh({expr})						*<A NAME="sinh()"></A><B>sinh()</B>*
		Return the hyperbolic sine of {expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| in the range
		[-inf, inf].
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo sinh(0.5)</B>
 			0.521095
<B>			:echo sinh(-0.9)</B>
 			-1.026517

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;sinh()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



slice({expr}, {start} [, {end}])			*<A NAME="slice()"></A><B>slice()</B>*
		Similar to using a |<A HREF="eval.html#slice">slice</A>| &quot;expr[start : end]&quot;, but &quot;end&quot; is
		used <A HREF="motion.html#exclusive">exclusive</A>.  And for a <A HREF="eval.html#string">string</A> the indexes are used <A HREF="motion.html#as">as</A>
		character indexes instead of byte indexes, like in
		|<A HREF="vim9.html#vim9script">vim9script</A>|.  Also, composing characters are not counted.
		When {end} is omitted the <A HREF="eval.html#slice">slice</A> continues to the last item.
		When {end} is -1 the last item is omitted.
		Returns an empty value if {start} or {end} are invalid.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetList()-&gt;slice(offset)</B>



sort({list} [, {how} [, {dict}]])			*<A NAME="sort()"></A><B>sort()</B>* *<A NAME="E702"></A><B>E702</B>*
		Sort the items in {list} in-place.  Returns {list}.

		If you want a <A HREF="eval.html#list">list</A> to remain unmodified make a copy first:
<B>			:let sortedlist = sort(copy(mylist))</B>

 		When {how} is omitted or is a <A HREF="eval.html#string">string</A>, then <A HREF="#sort()">sort()</A> uses the
		<A HREF="eval.html#string">string</A> representation of each item to sort on.  Numbers sort
		after Strings, |<A HREF="eval.html#Lists">Lists</A>| after Numbers.  For <A HREF="change.html#sorting">sorting</A> text in the
		current buffer use |<A HREF="change.html#:sort">:sort</A>|.

		When {how} is given and <A HREF="motion.html#it">it</A> is '<A HREF="insert.html#i">i</A>' then <A HREF="change.html#case">case</A> is ignored.
		In legacy <A HREF="usr_41.html#script">script</A>, for backwards compatibility, the value one
		can be used to ignore <A HREF="change.html#case">case</A>.  Zero means to not ignore <A HREF="change.html#case">case</A>.

		When {how} is given and <A HREF="motion.html#it">it</A> is '<A HREF="motion.html#l">l</A>' then the current collation
		<A HREF="mbyte.html#locale">locale</A> is used for ordering. Implementation details: strcoll()
		is used to compare strings. See |<A HREF="mlang.html#:language">:language</A>| check or set the
		collation <A HREF="mbyte.html#locale">locale</A>. |<A HREF="eval.html#v:collate">v:collate</A>| can also be used to check the
		current <A HREF="mbyte.html#locale">locale</A>. Sorting using the <A HREF="mbyte.html#locale">locale</A> typically ignores
		<A HREF="change.html#case">case</A>. Example:
<B>			"  is sorted similarly to o with English locale.</B>
<B>			:language collate en_US.UTF8</B>
<B>			:echo sort(['n', 'o', 'O', '', 'p', 'z'], 'l')</B>
<B><FONT COLOR="PURPLE"> 			['n', 'o', 'O', '', 'p', 'z'] </FONT></B>

<B>			"  is sorted after z with Swedish locale.</B>
<B>			:language collate sv_SE.UTF8</B>
<B>			:echo sort(['n', 'o', 'O', '', 'p', 'z'], 'l')</B>
<B><FONT COLOR="PURPLE"> 			['n', 'o', 'O', 'p', 'z', ''] </FONT></B>
		This does not work properly on <A HREF="os_mac.html#Mac">Mac</A>.

		When {how} is given and <A HREF="motion.html#it">it</A> is '<A HREF="pattern.html#n">n</A>' then all items will be
		sorted numerical (Implementation detail: this uses the
		strtod() function to parse numbers, Strings, <A HREF="eval.html#Lists">Lists</A>, Dicts and
		Funcrefs will be considered <A HREF="motion.html#as">as</A> being 0).

		When {how} is given and <A HREF="motion.html#it">it</A> is '<A HREF="pattern.html#N">N</A>' then all items will be
		sorted numerical. This is like '<A HREF="pattern.html#n">n</A>' but a <A HREF="eval.html#string">string</A> containing
		digits will be used <A HREF="motion.html#as">as</A> the number they represent.

		When {how} is given and <A HREF="motion.html#it">it</A> is '<A HREF="motion.html#f">f</A>' then all items will be
		sorted numerical. All values must be a <A HREF="eval.html#Number">Number</A> or a <A HREF="eval.html#Float">Float</A>.

		When {how} is a |<A HREF="eval.html#Funcref">Funcref</A>| or a function name, this function
		is called to compare items.  The function is invoked with two
		items <A HREF="motion.html#as">as</A> argument and must return zero if they are equal, 1 or
		bigger if the first one sorts after the second one, -1 or
		smaller if the first one sorts before the second one.

		{dict} is for <A HREF="eval.html#functions">functions</A> with the &quot;<A HREF="eval.html#dict">dict</A>&quot; attribute.  It will be
		used to set the local variable &quot;<A HREF="eval.html#self">self</A>&quot;. |<A HREF="eval.html#Dictionary-function">Dictionary-function</A>|

		The sort is stable, items which compare equal (as number or <A HREF="motion.html#as">as</A>
		<A HREF="eval.html#string">string</A>) will keep their relative position. E.g., when <A HREF="change.html#sorting">sorting</A>
		on numbers, text strings will sort next to each other, in the
		same order <A HREF="motion.html#as">as</A> they were originally.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;sort()</B>

 		Also see |<A HREF="#uniq()">uniq()</A>|.

		Example:
<B>			func MyCompare(i1, i2)</B>
<B>			   return a:i1 == a:i2 ? 0 : a:i1 &gt; a:i2 ? 1 : -1</B>
<B>			endfunc</B>
<B>			eval mylist-&gt;sort("MyCompare")</B>
 		A shorter compare version for this specific simple <A HREF="change.html#case">case</A>, which
		ignores overflow:
<B>			func MyCompare(i1, i2)</B>
<B>			   return a:i1 - a:i2</B>
<B>			endfunc</B>
 		For a simple <A HREF="eval.html#expression">expression</A> you can use a <A HREF="eval.html#lambda">lambda</A>:
<B>			eval mylist-&gt;sort({i1, i2 -&gt; i1 - i2})</B>
 

<A HREF="#sound_clear()">sound_clear()</A>						*<A NAME="sound_clear()"></A><B>sound_clear()</B>*
		Stop playing all sounds.

		On some Linux systems you may need the libcanberra-pulse
		package, otherwise sound may not stop.

		{only available when compiled with the |<A HREF="various.html#+sound">+sound</A>| feature}


							*<A NAME="sound_playevent()"></A><B>sound_playevent()</B>*
sound_playevent({name} [, {callback}])
		Play a sound identified by {name}.  Which event names are
		supported depends on the system.  Often the XDG sound names
		are used.  On Ubuntu they may be found in
		/usr/share/sounds/freedesktop/stereo.  Example:
<B>			call sound_playevent('bell')</B>
 		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, {name} can be SystemAsterisk, SystemDefault,
		SystemExclamation, SystemExit, SystemHand, SystemQuestion,
		SystemStart, SystemWelcome, etc.

		When {callback} is specified <A HREF="motion.html#it">it</A> is invoked when the sound is
		finished.  The first argument is the sound ID, the second
		argument is the status:
			0	sound was played to the end
			1	sound was interrupted
			2	error occurred after sound started
		Example:
<B>		   func Callback(id, status)</B>
<B>		     echomsg "sound " .. a:id .. " finished with " .. a:status</B>
<B>		   endfunc</B>
<B>		   call sound_playevent('bell', 'Callback')</B>

 		<A HREF="os_win32.html#MS-Windows">MS-Windows</A>: {callback} doesn't work for this function.

		Returns the sound ID, which can be passed to `sound_stop()`.
		Returns zero if the sound could not be played.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetSoundName()-&gt;sound_playevent()</B>

 		{only available when compiled with the |<A HREF="various.html#+sound">+sound</A>| feature}


							*<A NAME="sound_playfile()"></A><B>sound_playfile()</B>*
sound_playfile({path} [, {callback}])
		Like `sound_playevent()` but play sound file {path}.  {path}
		must be a full path.  On Ubuntu you may find files to play
		with this command:
<B>		    :!find /usr/share/sounds -type f | grep -v index.theme</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetSoundPath()-&gt;sound_playfile()</B>

 		{only available when compiled with the |<A HREF="various.html#+sound">+sound</A>| feature}



sound_stop({id})					*<A NAME="sound_stop()"></A><B>sound_stop()</B>*
		Stop playing sound {id}.  {id} must be previously returned by
		`sound_playevent()` or `sound_playfile()`.

		On some Linux systems you may need the libcanberra-pulse
		package, otherwise sound may not stop.

		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, this does not work for event sound started by
		`sound_playevent()`. To stop event sounds, use `sound_clear()`.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			soundid-&gt;sound_stop()</B>

 		{only available when compiled with the |<A HREF="various.html#+sound">+sound</A>| feature}


							*<A NAME="soundfold()"></A><B>soundfold()</B>*
soundfold({word})
		Return the sound-folded equivalent of {word}.  Uses the first
		language in <A HREF="options.html#'spelllang'">'spelllang'</A> for the current <A HREF="windows.html#window">window</A> that supports
		soundfolding.  <A HREF="options.html#'spell'">'spell'</A> must be set.  When no sound <A HREF="fold.html#folding">folding</A> is
		possible the {word} is returned unmodified.
		This can be used for making spelling suggestions.  Note that
		the <A HREF="eval.html#method">method</A> can be quite slow.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWord()-&gt;soundfold()</B>
 

							*<A NAME="spellbadword()"></A><B>spellbadword()</B>*
spellbadword([{sentence}])
		Without argument: The result is the badly spelled <A HREF="motion.html#word">word</A> under
		or after the cursor.  The cursor is moved to the start of the
		bad <A HREF="motion.html#word">word</A>.  When no bad <A HREF="motion.html#word">word</A> is found in the cursor line the
		result is an empty <A HREF="eval.html#string">string</A> and the cursor doesn't move.

		With argument: The result is the first <A HREF="motion.html#word">word</A> in {sentence} that
		is badly spelled.  If there are no spelling mistakes the
		result is an empty <A HREF="eval.html#string">string</A>.

		The return value is a <A HREF="eval.html#list">list</A> with two items:
		- The badly spelled <A HREF="motion.html#word">word</A> or an empty <A HREF="eval.html#string">string</A>.
		- The type of the spelling error:
			&quot;bad&quot;		spelling mistake
			&quot;rare&quot;		rare <A HREF="motion.html#word">word</A>
			&quot;local&quot;		<A HREF="motion.html#word">word</A> only valid in another region
			&quot;caps&quot;		<A HREF="motion.html#word">word</A> should start with Capital
		Example:
<B>			echo spellbadword("the quik brown fox")</B>
<B><FONT COLOR="PURPLE"> 			['quik', 'bad'] </FONT></B>

		The spelling information for the current <A HREF="windows.html#window">window</A> and the value
		of <A HREF="options.html#'spelllang'">'spelllang'</A> are used.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;spellbadword()</B>
 

							*<A NAME="spellsuggest()"></A><B>spellsuggest()</B>*
spellsuggest({word} [, {max} [, {capital}]])
		Return a |<A HREF="eval.html#List">List</A>| with spelling suggestions to replace {word}.
		When {max} is given up to this number of suggestions are
		returned.  Otherwise up to 25 suggestions are returned.

		When the {capital} argument is given and it's non-zero only
		suggestions with a leading capital will be given.  Use this
		after a match with <A HREF="options.html#'spellcapcheck'">'spellcapcheck'</A>.

		{word} can be a badly spelled <A HREF="motion.html#word">word</A> followed by other text.
		This allows for joining two words that were split.  The
		suggestions also include the following text, thus you can
		replace a line.

		{word} may also be a good <A HREF="motion.html#word">word</A>.  Similar words will then be
		returned.  {word} itself is not included in the suggestions,
		although <A HREF="motion.html#it">it</A> may appear capitalized.

		The spelling information for the current <A HREF="windows.html#window">window</A> is used.  The
		values of <A HREF="options.html#'spelllang'">'spelllang'</A> and <A HREF="options.html#'spellsuggest'">'spellsuggest'</A> are used.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWord()-&gt;spellsuggest()</B>


split({string} [, {pattern} [, {keepempty}]])			*<A NAME="split()"></A><B>split()</B>*
		Make a |<A HREF="eval.html#List">List</A>| out of {string}.  When {pattern} is omitted or
		empty each white-separated sequence of characters becomes an
		item.
		Otherwise the <A HREF="eval.html#string">string</A> is split where {pattern} matches,
		removing the matched characters. <A HREF="options.html#'ignorecase'">'ignorecase'</A> is not used
		here, add \c to ignore <A HREF="change.html#case">case</A>. |<A HREF="pattern.html#/\c">/\c</A>|
		When the first or last item is empty <A HREF="motion.html#it">it</A> is omitted, unless the
		{keepempty} argument is given and it's non-zero.
		Other empty items are kept when {pattern} matches at least one
		character or when {keepempty} is non-zero.
		Example:
<B>			:let words = split(getline('.'), '\W\+')</B>
 		To split a <A HREF="eval.html#string">string</A> in individual characters:
<B>			:for c in split(mystring, '\zs')</B>
 		If you want to keep the separator you can also use '\zs' at
		the end of the <A HREF="pattern.html#pattern">pattern</A>:
<B>			:echo split('abc:def:ghi', ':\zs')</B>
<B><FONT COLOR="PURPLE"> 			['abc:', 'def:', 'ghi'] </FONT></B>
		Splitting a table where the first element can be empty:
<B>			:let items = split(line, ':', 1)</B>
 		The opposite function is |<A HREF="#join()">join()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetString()-&gt;split()</B>


sqrt({expr})						*<A NAME="sqrt()"></A><B>sqrt()</B>*
		Return the non-negative square root of <A HREF="eval.html#Float">Float</A> {expr} <A HREF="motion.html#as">as</A> a
		|<A HREF="eval.html#Float">Float</A>|.
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.  When {expr}
		is negative the result is NaN (Not a <A HREF="eval.html#Number">Number</A>).  Returns 0.0 if
		{expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo sqrt(100)</B>
 			10.0
<B>			:echo sqrt(-4.01)</B>
 			nan
		&quot;nan&quot; may be different, <A HREF="motion.html#it">it</A> depends on system libraries.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;sqrt()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



srand([{expr}])						*<A NAME="srand()"></A><B>srand()</B>*
		Initialize seed used by YXXYrand()|:
		- If {expr} is not given, seed values are initialized by
		  reading from /dev/urandom, if possible, or using time(NULL)
		  a.k.a. epoch time otherwise; this only has second accuracy.
		- If {expr} is given <A HREF="motion.html#it">it</A> must be a <A HREF="eval.html#Number">Number</A>.  It is used to
		  initialize the seed values.  This is useful for <A HREF="testing.html#testing">testing</A> or
		  when a predictable sequence is intended.

		Examples:
<B>			:let seed = srand()</B>
<B>			:let seed = srand(userinput)</B>
<B>			:echo rand(seed)</B>


state([{what}])						*<A NAME="state()"></A><B>state()</B>*
		Return a <A HREF="eval.html#string">string</A> which contains characters indicating the
		current state.  Mostly useful in callbacks that want to <A HREF="diff.html#do">do</A>
		work that may not always be safe.  Roughly this works like:
		- callback uses <A HREF="#state()">state()</A> to check if work is safe to <A HREF="diff.html#do">do</A>.
		  Yes: then <A HREF="diff.html#do">do</A> <A HREF="motion.html#it">it</A> right away.
		  No:  add to work queue and add a |<A HREF="autocmd.html#SafeState">SafeState</A>| and/or
		       |<A HREF="autocmd.html#SafeStateAgain">SafeStateAgain</A>| <A HREF="autocmd.html#autocommand">autocommand</A> (|<A HREF="autocmd.html#SafeState">SafeState</A>| triggers at
		       toplevel, |<A HREF="autocmd.html#SafeStateAgain">SafeStateAgain</A>| triggers after handling
		       <A HREF="message.html#messages">messages</A> and callbacks).
		- When <A HREF="autocmd.html#SafeState">SafeState</A> or <A HREF="autocmd.html#SafeStateAgain">SafeStateAgain</A> is triggered and executes
		  your <A HREF="autocmd.html#autocommand">autocommand</A>, check with `state()` if the work can be
		  done now, and if yes remove <A HREF="motion.html#it">it</A> from the queue and execute.
		  Remove the <A HREF="autocmd.html#autocommand">autocommand</A> if the queue is now empty.
		Also see |<A HREF="#mode()">mode()</A>|.

		When {what} is given only characters in this <A HREF="eval.html#string">string</A> will be
		added.  E.g, this checks if the screen has scrolled:
<B>			if state('s') == ''</B>
<B>			   " screen has not scrolled</B>
 
		These characters indicate the state, generally indicating that
		something is busy:
		    <A HREF="motion.html#m">m</A>	halfway a <A HREF="map.html#mapping">mapping</A>, <A HREF="various.html#:normal">:normal</A> command, <A HREF="#feedkeys()">feedkeys()</A> or
			stuffed command
		    <A HREF="insert.html#o">o</A>	<A HREF="motion.html#operator">operator</A> pending, e.g. after |<A HREF="change.html#d">d</A>|
		    a	<A HREF="insert.html#Insert">Insert</A> mode autocomplete active
		    <A HREF="change.html#x">x</A>	executing an <A HREF="autocmd.html#autocommand">autocommand</A>
		    <A HREF="motion.html#w">w</A>	blocked on waiting, e.g. <A HREF="channel.html#ch_evalexpr()">ch_evalexpr()</A>, <A HREF="channel.html#ch_read()">ch_read()</A> and
			<A HREF="channel.html#ch_readraw()">ch_readraw()</A> when reading json
		    <A HREF="change.html#S">S</A>	not triggering <A HREF="autocmd.html#SafeState">SafeState</A> or <A HREF="autocmd.html#SafeStateAgain">SafeStateAgain</A>, e.g. after
			|<A HREF="motion.html#f">f</A>| or a <A HREF="intro.html#count">count</A>
		    <A HREF="change.html#c">c</A>	callback invoked, including <A HREF="#timer">timer</A> (repeats for
			recursiveness up to &quot;ccc&quot;)
		    <A HREF="change.html#s">s</A>	screen has scrolled for <A HREF="message.html#messages">messages</A>


str2float({string} [, {quoted}])				*<A NAME="str2float()"></A><B>str2float()</B>*
		Convert <A HREF="eval.html#String">String</A> {string} to a <A HREF="eval.html#Float">Float</A>.  This mostly works the
		same <A HREF="motion.html#as">as</A> when using a floating point number in an <A HREF="eval.html#expression">expression</A>,
		see |<A HREF="eval.html#floating-point-format">floating-point-format</A>|.  But it's a bit more permissive.
		E.g., &quot;1e40&quot; is accepted, while in an <A HREF="eval.html#expression">expression</A> you need to
		write &quot;1.0e40&quot;.  The hexadecimal form &quot;0x123&quot; is also
		accepted, but not others, like binary or <A HREF="eval.html#octal">octal</A>.
		When {quoted} is present and non-zero then embedded single
		<A HREF="quotes.html#quotes">quotes</A> before the dot are ignored, thus &quot;1'000.0&quot; is a
		thousand.
		Text after the number is silently ignored.
		The decimal point is always '<A HREF="repeat.html#.">.</A>', no matter what the <A HREF="mbyte.html#locale">locale</A> is
		set to.  A comma ends the number: &quot;12,345.67&quot; is converted to
		12.0.  You can strip out thousands separators with
		YXXYsubstitute()|:
<B>			let f = str2float(substitute(text, ',', '', 'g'))</B>
 
		Returns 0.0 if the conversion fails.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			let f = text-&gt;substitute(',', '', 'g')-&gt;str2float()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


str2list({string} [, {utf8}])					*<A NAME="str2list()"></A><B>str2list()</B>*
		Return a <A HREF="eval.html#list">list</A> containing the number values which represent
		each character in <A HREF="eval.html#String">String</A> {string}.  Examples:
<B>			str2list(" ")		returns [32]</B>
<B>			str2list("ABC")		returns [65, 66, 67]</B>
 		|<A HREF="#list2str()">list2str()</A>| does the opposite.

		When {utf8} is omitted or zero, the current <A HREF="options.html#'encoding'">'encoding'</A> is used.
		When {utf8} is <A HREF="eval.html#TRUE">TRUE</A>, always treat the <A HREF="eval.html#String">String</A> <A HREF="motion.html#as">as</A> <A HREF="mbyte.html#UTF-8">UTF-8</A>
		characters.  With <A HREF="mbyte.html#UTF-8">UTF-8</A> composing characters are handled
		properly:
<B>			str2list("a")		returns [97, 769]</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetString()-&gt;str2list()</B>



str2nr({string} [, {base} [, {quoted}]])			*<A NAME="str2nr()"></A><B>str2nr()</B>*
		Convert <A HREF="eval.html#string">string</A> {string} to a number.
		{base} is the conversion base, <A HREF="motion.html#it">it</A> can be 2, 8, 10 or 16.
		When {quoted} is present and non-zero then embedded single
		<A HREF="quotes.html#quotes">quotes</A> are ignored, thus &quot;1'000'000&quot; is a million.

		When {base} is omitted base 10 is used.  This also means that
		a leading zero doesn't cause <A HREF="eval.html#octal">octal</A> conversion to be used, <A HREF="motion.html#as">as</A>
		with the default <A HREF="eval.html#String">String</A> to <A HREF="eval.html#Number">Number</A> conversion.  Example:
<B>			let nr = str2nr('0123')</B>
 
		When {base} is 16 a leading &quot;<A HREF="eval.html#0x">0x</A>&quot; or &quot;0X&quot; is ignored.  With a
		different base the result will be zero.  Similarly, when
		{base} is 8 a leading &quot;<A HREF="motion.html#0">0</A>&quot;, &quot;<A HREF="eval.html#0o">0o</A>&quot; or &quot;0O&quot; is ignored, and when
		{base} is 2 a leading &quot;0b&quot; or &quot;0B&quot; is ignored.
		Text after the number is silently ignored.

		Returns 0 if {string} is empty or on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;str2nr()</B>



strcharlen({string})					*<A NAME="strcharlen()"></A><B>strcharlen()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the number of characters
		in <A HREF="eval.html#String">String</A> {string}.  Composing characters are ignored.
		|<A HREF="#strchars()">strchars()</A>| can <A HREF="intro.html#count">count</A> the number of characters, counting
		composing characters separately.

		Returns 0 if {string} is empty or on error.

		Also see |<A HREF="#strlen()">strlen()</A>|, |<A HREF="#strdisplaywidth()">strdisplaywidth()</A>| and |<A HREF="#strwidth()">strwidth()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;strcharlen()</B>



strcharpart({src}, {start} [, {len} [, {skipcc}]])		*<A NAME="strcharpart()"></A><B>strcharpart()</B>*
		Like |<A HREF="#strpart()">strpart()</A>| but using character index and length instead
		of byte index and length.
		When {skipcc} is omitted or zero, composing characters are
		counted separately.
		When {skipcc} set to 1, Composing characters are ignored,
		similar to  |<A HREF="#slice()">slice()</A>|.
		When a character index is used where a character does not
		exist <A HREF="motion.html#it">it</A> is omitted and counted <A HREF="motion.html#as">as</A> one character.  For
		example:
<B>			strcharpart('abc', -1, 2)</B>
 		results in '<A HREF="insert.html#a">a</A>'.

		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;strcharpart(5)</B>



strchars({string} [, {skipcc}])					*<A NAME="strchars()"></A><B>strchars()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the number of characters
		in <A HREF="eval.html#String">String</A> {string}.
		When {skipcc} is omitted or zero, composing characters are
		counted separately.
		When {skipcc} set to 1, Composing characters are ignored.
		|<A HREF="#strcharlen()">strcharlen()</A>| always does this.

		Returns zero on error.

		Also see |<A HREF="#strlen()">strlen()</A>|, |<A HREF="#strdisplaywidth()">strdisplaywidth()</A>| and |<A HREF="#strwidth()">strwidth()</A>|.

		{skipcc} is only available after 7.4.755.  For backward
		compatibility, you can define a wrapper function:
<B>		    if has("patch-7.4.755")</B>
<B>		      function s:strchars(str, skipcc)</B>
<B>			return strchars(a:str, a:skipcc)</B>
<B>		      endfunction</B>
<B>		    else</B>
<B>		      function s:strchars(str, skipcc)</B>
<B>			if a:skipcc</B>
<B>			  return strlen(substitute(a:str, ".", "x", "g"))</B>
<B>			else</B>
<B>			  return strchars(a:str)</B>
<B>			endif</B>
<B>		      endfunction</B>
<B>		    endif</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;strchars()</B>


strdisplaywidth({string} [, {col}])			*<A NAME="strdisplaywidth()"></A><B>strdisplaywidth()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the number of display cells
		<A HREF="eval.html#String">String</A> {string} occupies on the screen when <A HREF="motion.html#it">it</A> starts at {col}
		(first column is zero).  When {col} is omitted zero is used.
		Otherwise <A HREF="motion.html#it">it</A> is the screen column where to start.  This
		matters for <A HREF="intro.html#Tab">Tab</A> characters.
		The option settings of the current <A HREF="windows.html#window">window</A> are used.  This
		matters for anything that's displayed differently, such <A HREF="motion.html#as">as</A>
		<A HREF="options.html#'tabstop'">'tabstop'</A> and <A HREF="options.html#'display'">'display'</A>.
		When {string} contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on <A HREF="options.html#'ambiwidth'">'ambiwidth'</A>.
		Returns zero on error.
		Also see |<A HREF="#strlen()">strlen()</A>|, |<A HREF="#strwidth()">strwidth()</A>| and |<A HREF="#strchars()">strchars()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;strdisplaywidth()</B>


strftime({format} [, {time}])				*<A NAME="strftime()"></A><B>strftime()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is a formatted date and time, <A HREF="motion.html#as">as</A>
		specified by the {format} <A HREF="eval.html#string">string</A>.  The given {time} is used,
		or the current time if no time is given.  The accepted
		{format} depends on your system, thus this is not portable!
		See the manual page of the C function <A HREF="#strftime()">strftime()</A> for the
		format.  The maximum length of the result is 80 characters.
		See also |<A HREF="#localtime()">localtime()</A>|, |<A HREF="#getftime()">getftime()</A>| and |<A HREF="#strptime()">strptime()</A>|.
		The language can be changed with the |<A HREF="mlang.html#:language">:language</A>| command.
		Examples:
<B>		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997</B>
<B>		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25</B>
<B>		  :echo strftime("%y%m%d %T")	   970427 11:53:55</B>
<B>		  :echo strftime("%H:%M")	   11:55</B>
<B>		  :echo strftime("%c", getftime("file.c"))</B>
<B>						   Show mod time of file.c.</B>
 		Not available on all systems.  To check use:
<B>			:if exists("*strftime")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFormat()-&gt;strftime()</B>


strgetchar({str}, {index})				*<A NAME="strgetchar()"></A><B>strgetchar()</B>*
		Get a <A HREF="eval.html#Number">Number</A> corresponding to the character at {index} in
		{str}.  This uses a zero-based character index, not a byte
		index.  Composing characters are considered separate
		characters here.  Use |<A HREF="#nr2char()">nr2char()</A>| to convert the <A HREF="eval.html#Number">Number</A> to a
		<A HREF="eval.html#String">String</A>.
		Returns -1 if {index} is invalid.
		Also see |<A HREF="#strcharpart()">strcharpart()</A>| and |<A HREF="#strchars()">strchars()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;strgetchar(5)</B>


stridx({haystack}, {needle} [, {start}])		*<A NAME="stridx()"></A><B>stridx()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which gives the byte index in
		{haystack} of the first occurrence of the <A HREF="eval.html#String">String</A> {needle}.
		If {start} is specified, the search starts at index {start}.
		This can be used to find a second match:
<B>			:let colon1 = stridx(line, ":")</B>
<B>			:let colon2 = stridx(line, ":", colon1 + 1)</B>
 		The search is done case-sensitive.
		For <A HREF="pattern.html#pattern">pattern</A> searches use |<A HREF="#match()">match()</A>|.
		-1 is returned if the {needle} does not occur in {haystack}.
		See also |<A HREF="#strridx()">strridx()</A>|.
		Examples:
<B>		  :echo stridx("An Example", "Example")	     3</B>
<B>		  :echo stridx("Starting point", "Start")    0</B>
<B>		  :echo stridx("Starting point", "start")   -1</B>

 						*<A NAME="strstr()"></A><B>strstr()</B>* *<A NAME="strchr()"></A><B>strchr()</B>*
		<A HREF="#stridx()">stridx()</A> works similar to the C function <A HREF="#strstr()">strstr()</A>.  When used
		with a single character <A HREF="motion.html#it">it</A> works similar to <A HREF="#strchr()">strchr()</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetHaystack()-&gt;stridx(needle)</B>
 

							*<A NAME="string()"></A><B>string()</B>*
string({expr})	Return {expr} converted to a <A HREF="eval.html#String">String</A>.  If {expr} is a <A HREF="eval.html#Number">Number</A>,
		<A HREF="eval.html#Float">Float</A>, <A HREF="eval.html#String">String</A>, <A HREF="eval.html#Blob">Blob</A> or a composition of them, then the result
		can be parsed back with |<A HREF="#eval()">eval()</A>|.
<B><FONT COLOR="PURPLE">			{expr} type	result </FONT></B>
			<A HREF="eval.html#String">String</A>		'<A HREF="eval.html#string">string</A>' (single <A HREF="quotes.html#quotes">quotes</A> are doubled)
			<A HREF="eval.html#Number">Number</A>		123
			<A HREF="eval.html#Float">Float</A>		123.123456 or 1.123456e8
			<A HREF="eval.html#Funcref">Funcref</A>		function('name')
			<A HREF="eval.html#Blob">Blob</A>		0z00112233.44556677.8899
			<A HREF="eval.html#List">List</A>		[item, item]
			<A HREF="eval.html#Dictionary">Dictionary</A>	{key: value, key: value}

		When a |<A HREF="eval.html#List">List</A>| or |<A HREF="eval.html#Dictionary">Dictionary</A>| has a recursive reference <A HREF="motion.html#it">it</A> is
		replaced by &quot;[...]&quot; or &quot;{...}&quot;.  Using <A HREF="#eval()">eval()</A> on the result
		will then fail.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;string()</B>

 		Also see |<A HREF="#strtrans()">strtrans()</A>|.



strlen({string})						*<A NAME="strlen()"></A><B>strlen()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the length of the <A HREF="eval.html#String">String</A>
		{string} in bytes.
		If the argument is a <A HREF="eval.html#Number">Number</A> <A HREF="motion.html#it">it</A> is first converted to a <A HREF="eval.html#String">String</A>.
		For other types an error is given and zero is returned.
		If you want to <A HREF="intro.html#count">count</A> the number of <A HREF="mbyte.html#multibyte">multibyte</A> characters use
		|<A HREF="#strchars()">strchars()</A>|.
		Also see |<A HREF="#len()">len()</A>|, |<A HREF="#strdisplaywidth()">strdisplaywidth()</A>| and |<A HREF="#strwidth()">strwidth()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetString()-&gt;strlen()</B>


strpart({src}, {start} [, {len} [, {chars}]])			*<A NAME="strpart()"></A><B>strpart()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is part of {src}, starting from
		byte {start}, with the byte length {len}.
		When {chars} is present and <A HREF="eval.html#TRUE">TRUE</A> then {len} is the number of
		characters positions (composing characters are not counted
		separately, thus &quot;1&quot; means one base character and any
		following composing characters).
		To <A HREF="intro.html#count">count</A> {start} <A HREF="motion.html#as">as</A> characters instead of bytes use
		|<A HREF="#strcharpart()">strcharpart()</A>|.

		When bytes are selected which <A HREF="diff.html#do">do</A> not exist, this doesn't
		result in an error, the bytes are simply omitted.
		If {len} is missing, the copy continues from {start} till the
		end of the {src}.
<B>			strpart("abcdefg", 3, 2)    == "de"</B>
<B>			strpart("abcdefg", -2, 4)   == "ab"</B>
<B>			strpart("abcdefg", 5, 4)    == "fg"</B>
<B>			strpart("abcdefg", 3)	    == "defg"</B>

 		Note: To get the first character, {start} must be 0.  For
		example, to get the character under the cursor:
<B>			strpart(getline("."), col(".") - 1, 1, v:true)</B>
 
		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;strpart(5)</B>


strptime({format}, {timestring})				*<A NAME="strptime()"></A><B>strptime()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is a <A HREF="os_unix.html#unix">unix</A> <A HREF="editing.html#timestamp">timestamp</A> representing
		the date and time in {timestring}, which is expected to match
		the format specified in {format}.

		The accepted {format} depends on your system, thus this is not
		portable!  See the manual page of the C function <A HREF="#strptime()">strptime()</A>
		for the format.  Especially avoid &quot;&#37;c&quot;.  The value of $TZ also
		matters.

		If the {timestring} cannot be parsed with {format} zero is
		returned.  If you <A HREF="diff.html#do">do</A> not know the format of {timestring} you
		can try different {format} values until you get a non-zero
		result.

		See also |<A HREF="#strftime()">strftime()</A>|.
		Examples:
<B>		  :echo strptime("%Y %b %d %X", "1997 Apr 27 11:49:23")</B>
 		  862156163
<B>		  :echo strftime("%c", strptime("%y%m%d %T", "970427 11:53:55"))</B>
 		  Sun Apr 27 11:53:55 1997
<B>		  :echo strftime("%c", strptime("%Y%m%d%H%M%S", "19970427115355") + 3600)</B>
 		  Sun Apr 27 12:53:55 1997

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFormat()-&gt;strptime(timestring)</B>
 
		Not available on all systems.  To check use:
<B>			:if exists("*strptime")</B>


strridx({haystack}, {needle} [, {start}])			*<A NAME="strridx()"></A><B>strridx()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which gives the byte index in
		{haystack} of the last occurrence of the <A HREF="eval.html#String">String</A> {needle}.
		When {start} is specified, matches beyond this index are
		ignored.  This can be used to find a match before a previous
		match:
<B>			:let lastcomma = strridx(line, ",")</B>
<B>			:let comma2 = strridx(line, ",", lastcomma - 1)</B>
 		The search is done case-sensitive.
		For <A HREF="pattern.html#pattern">pattern</A> searches use |<A HREF="#match()">match()</A>|.
		-1 is returned if the {needle} does not occur in {haystack}.
		If the {needle} is empty the length of {haystack} is returned.
		See also |<A HREF="#stridx()">stridx()</A>|.  Examples:
<B>		  :echo strridx("an angry armadillo", "an")	     3</B>

 							*<A NAME="strrchr()"></A><B>strrchr()</B>*
		When used with a single character <A HREF="motion.html#it">it</A> works similar to the C
		function <A HREF="#strrchr()">strrchr()</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetHaystack()-&gt;strridx(needle)</B>


strtrans({string})					*<A NAME="strtrans()"></A><B>strtrans()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is {string} with all unprintable
		characters translated into printable characters |<A HREF="options.html#'isprint'">'isprint'</A>|.
		Like they are shown in a <A HREF="windows.html#window">window</A>.  Example:
<B>			echo strtrans(@a)</B>
 		This displays a newline in <A HREF="sponsor.html#register">register</A> a <A HREF="motion.html#as">as</A> &quot;^@&quot; instead of
		starting a new line.

		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetString()-&gt;strtrans()</B>


strwidth({string})					*<A NAME="strwidth()"></A><B>strwidth()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the number of display cells
		<A HREF="eval.html#String">String</A> {string} occupies.  A <A HREF="intro.html#Tab">Tab</A> character is counted <A HREF="motion.html#as">as</A> one
		cell, alternatively use |<A HREF="#strdisplaywidth()">strdisplaywidth()</A>|.
		When {string} contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on <A HREF="options.html#'ambiwidth'">'ambiwidth'</A>.
		Returns zero on error.
		Also see |<A HREF="#strlen()">strlen()</A>|, |<A HREF="#strdisplaywidth()">strdisplaywidth()</A>| and |<A HREF="#strchars()">strchars()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetString()-&gt;strwidth()</B>


submatch({nr} [, {list}])			*<A NAME="submatch()"></A><B>submatch()</B>* *<A NAME="E935"></A><B>E935</B>*
		Only for an <A HREF="eval.html#expression">expression</A> in a |<A HREF="change.html#:substitute">:substitute</A>| command or
		<A HREF="#substitute()">substitute()</A> function.
		Returns the {nr}'th submatch of the matched text.  When {nr}
		is 0 the whole matched text is returned.
		Note that a NL in the <A HREF="eval.html#string">string</A> can stand for a line break of a
		multi-line match or a NUL character in the text.
		Also see |<A HREF="change.html#sub-replace-expression">sub-replace-expression</A>|.

		If {list} is present and non-zero then <A HREF="#submatch()">submatch()</A> returns
		a <A HREF="eval.html#list">list</A> of strings, similar to |<A HREF="#getline()">getline()</A>| with two arguments.
		NL characters in the text represent NUL characters in the
		text.
		Only returns more than one item for |<A HREF="change.html#:substitute">:substitute</A>|, inside
		|<A HREF="#substitute()">substitute()</A>| this <A HREF="eval.html#list">list</A> will always contain one or zero
		items, since there are no real line breaks.

		When <A HREF="#substitute()">substitute()</A> is used recursively only the submatches in
		the current (deepest) call can be obtained.

		Returns an empty <A HREF="eval.html#string">string</A> or <A HREF="eval.html#list">list</A> on error.

		Examples:
<B>			:s/\d\+/\=submatch(0) + 1/</B>
<B>			:echo substitute(text, '\d\+', '\=submatch(0) + 1', '')</B>
 		This finds the first number in the line and adds one to <A HREF="motion.html#it">it</A>.
		A line break is included <A HREF="motion.html#as">as</A> a newline character.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetNr()-&gt;submatch()</B>


substitute({string}, {pat}, {sub}, {flags})		*<A NAME="substitute()"></A><B>substitute()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is a copy of {string}, in which
		the first match of {pat} is replaced with {sub}.
		When {flags} is &quot;<A HREF="index.html#g">g</A>&quot;, all matches of {pat} in {string} are
		replaced.  Otherwise {flags} should be &quot;&quot;.

		This works like the &quot;<A HREF="change.html#:substitute">:substitute</A>&quot; command (without any flags).
		But the matching with {pat} is always done like the <A HREF="options.html#'magic'">'magic'</A>
		option is set and <A HREF="options.html#'cpoptions'">'cpoptions'</A> is empty (to make scripts
		portable).  <A HREF="options.html#'ignorecase'">'ignorecase'</A> is still relevant, use |<A HREF="pattern.html#/\c">/\c</A>| or |<A HREF="pattern.html#/\C">/\C</A>|
		if you want to ignore or match <A HREF="change.html#case">case</A> and ignore <A HREF="options.html#'ignorecase'">'ignorecase'</A>.
		<A HREF="options.html#'smartcase'">'smartcase'</A> is not used.  See |<A HREF="#string-match">string-match</A>| for how {pat} is
		used.

		A &quot;<A HREF="change.html#~">~</A>&quot; in {sub} is not replaced with the previous {sub}.
		Note that some codes in {sub} have a special meaning
		|<A HREF="change.html#sub-replace-special">sub-replace-special</A>|.  For example, to replace something with
		&quot;\n&quot; (two characters), use &quot;\\\\n&quot; or '\\n'.

		When {pat} does not match in {string}, {string} is returned
		unmodified.

		Example:
<B>		   :let &amp;path = substitute(&amp;path, ",\\=[^,]*$", "", "")</B>
 		This removes the last component of the <A HREF="options.html#'path'">'path'</A> option.
<B>		   :echo substitute("testing", ".*", "\\U\\0", "")</B>
 		results in &quot;TESTING&quot;.

		When {sub} starts with &quot;\=&quot;, the remainder is interpreted <A HREF="motion.html#as">as</A>
		an expression. See |<A HREF="change.html#sub-replace-expression">sub-replace-expression</A>|.  Example:
<B>		   :echo substitute(s, '%\(\x\x\)',</B>
<B>			   \ '\=nr2char("0x" .. submatch(1))', 'g')</B>

 		When {sub} is a <A HREF="eval.html#Funcref">Funcref</A> that function is called, with one
		optional argument.  Example:
<B>		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')</B>
 		The optional argument is a <A HREF="eval.html#list">list</A> which contains the whole
		matched <A HREF="eval.html#string">string</A> and up to nine submatches, like what
		|<A HREF="#submatch()">submatch()</A>| returns.  Example:
<B>		   :echo substitute(s, '%\(\x\x\)', {m -&gt; '0x' .. m[1]}, 'g')</B>

 		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetString()-&gt;substitute(pat, sub, flags)</B>


swapinfo({fname})					*<A NAME="swapinfo()"></A><B>swapinfo()</B>*
		The result is a dictionary, which holds information about the
		swapfile {fname}. The available fields are:
			version Vim version
			user	user name
			host	host name
			fname	original file name
			pid	PID of the Vim process that created the swap
				file
			mtime	last modification time in seconds
			inode	Optional: INODE number of the file
			dirty	1 if file was modified, 0 if not
		Note that &quot;user&quot; and &quot;host&quot; are truncated to at most 39 bytes.
		In <A HREF="change.html#case">case</A> of failure an &quot;error&quot; item is added with the reason:
			Cannot open file: file not found or in accessible
			Cannot read file: cannot read first block
			Not a swap file: does not contain correct block ID
			Magic number mismatch: Info in first block is invalid

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFilename()-&gt;swapinfo()</B>


swapname({buf})						*<A NAME="swapname()"></A><B>swapname()</B>*
		The result is the swap file path of the buffer {expr}.
		For the use of {buf}, see |<A HREF="#bufname()">bufname()</A>| above.
		If buffer {buf} is the current buffer, the result is equal to
		|<A HREF="recover.html#:swapname">:swapname</A>| (unless there is no swap file).
		If buffer {buf} has no swap file, returns an empty <A HREF="eval.html#string">string</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBufname()-&gt;swapname()</B>


synID({lnum}, {col}, {trans})				*<A NAME="synID()"></A><B>synID()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the <A HREF="syntax.html#syntax">syntax</A> ID at the position
		{lnum} and {col} in the current <A HREF="windows.html#window">window</A>.
		The <A HREF="syntax.html#syntax">syntax</A> ID can be used with |<A HREF="#synIDattr()">synIDattr()</A>| and
		|<A HREF="#synIDtrans()">synIDtrans()</A>| to obtain <A HREF="syntax.html#syntax">syntax</A> information about text.

		{col} is 1 for the leftmost column, {lnum} is 1 for the first
		line.  <A HREF="options.html#'synmaxcol'">'synmaxcol'</A> applies, in a longer line zero is returned.
		Note that when the position is after the last character,
		that's where the cursor can be in <A HREF="insert.html#Insert">Insert</A> mode, <A HREF="#synID()">synID()</A> returns
		zero.  {lnum} is used like with |<A HREF="#getline()">getline()</A>|.

		When {trans} is |<A HREF="eval.html#TRUE">TRUE</A>|, transparent items are reduced to the
		item that they reveal.  This is useful when wanting to know
		the effective color.  When {trans} is |<A HREF="eval.html#FALSE">FALSE</A>|, the transparent
		item is returned.  This is useful when wanting to know which
		<A HREF="syntax.html#syntax">syntax</A> item is effective (e.g. inside parens).
		Warning: This function can be very slow.  Best speed is
		obtained by going through the file in forward direction.

		Returns zero on error.

		Example (echoes the name of the <A HREF="syntax.html#syntax">syntax</A> item under the cursor):
<B>			:echo synIDattr(synID(line("."), col("."), 1), "name")</B>
 


synIDattr({synID}, {what} [, {mode}])			*<A NAME="synIDattr()"></A><B>synIDattr()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is the {what} attribute of
		<A HREF="syntax.html#syntax">syntax</A> ID {synID}.  This can be used to obtain information
		about a <A HREF="syntax.html#syntax">syntax</A> item.
		{mode} can be &quot;<A HREF="gui.html#gui">gui</A>&quot;, &quot;cterm&quot; or &quot;term&quot;, to get the attributes
		for that mode.  When {mode} is omitted, or an invalid value is
		used, the attributes for the currently active highlighting are
		used (GUI, cterm or term).
		Use <A HREF="#synIDtrans()">synIDtrans()</A> to follow linked highlight groups.
		{what}		result
		&quot;name&quot;		the name of the <A HREF="syntax.html#syntax">syntax</A> item
		&quot;fg&quot;		foreground color (GUI: color name used to set
				the color, cterm: color number <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>,
				term: empty <A HREF="eval.html#string">string</A>)
		&quot;bg&quot;		background color (as with &quot;fg&quot;)
		&quot;font&quot;		font name (only available in the <A HREF="gui.html#GUI">GUI</A>)
				|<A HREF="syntax.html#highlight-font">highlight-font</A>|
		&quot;sp&quot;		special color for the <A HREF="gui.html#GUI">GUI</A> (as with &quot;fg&quot;)
				|<A HREF="syntax.html#highlight-guisp">highlight-guisp</A>|
		&quot;ul&quot;		<A HREF="syntax.html#underline">underline</A> color for cterm: number <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>
		&quot;fg#&quot;		like &quot;fg&quot;, but for the <A HREF="gui.html#GUI">GUI</A> and the <A HREF="gui.html#GUI">GUI</A> is
				running the name in &quot;#RRGGBB&quot; form
		&quot;bg#&quot;		like &quot;fg#&quot; for &quot;bg&quot;
		&quot;sp#&quot;		like &quot;fg#&quot; for &quot;sp&quot;
		&quot;<A HREF="syntax.html#bold">bold</A>&quot;		&quot;1&quot; if <A HREF="syntax.html#bold">bold</A>
		&quot;<A HREF="syntax.html#italic">italic</A>&quot;	&quot;1&quot; if <A HREF="syntax.html#italic">italic</A>
		&quot;reverse&quot;	&quot;1&quot; if reverse
		&quot;<A HREF="syntax.html#inverse">inverse</A>&quot;	&quot;1&quot; if <A HREF="syntax.html#inverse">inverse</A> (= reverse)
		&quot;<A HREF="syntax.html#standout">standout</A>&quot;	&quot;1&quot; if <A HREF="syntax.html#standout">standout</A>
		&quot;<A HREF="syntax.html#underline">underline</A>&quot;	&quot;1&quot; if underlined
		&quot;<A HREF="syntax.html#undercurl">undercurl</A>&quot;	&quot;1&quot; if undercurled
		&quot;strike&quot;	&quot;1&quot; if <A HREF="syntax.html#strikethrough">strikethrough</A>

		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Example (echoes the color of the <A HREF="syntax.html#syntax">syntax</A> item under the
		cursor):
<B>	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>	:echo synID(line("."), col("."), 1)-&gt;synIDtrans()-&gt;synIDattr("fg")</B>



synIDtrans({synID})					*<A NAME="synIDtrans()"></A><B>synIDtrans()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the translated <A HREF="syntax.html#syntax">syntax</A> ID of
		{synID}.  This is the <A HREF="syntax.html#syntax">syntax</A> group ID of what is being used to
		highlight the character.  Highlight links given with
		&quot;<A HREF="syntax.html#:highlight">:highlight</A> link&quot; are followed.

		Returns zero on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>	:echo synID(line("."), col("."), 1)-&gt;synIDtrans()-&gt;synIDattr("fg")</B>


synconcealed({lnum}, {col})				*<A NAME="synconcealed()"></A><B>synconcealed()</B>*
		The result is a |<A HREF="eval.html#List">List</A>| with currently three items:
		1. The first item in the <A HREF="eval.html#list">list</A> is 0 if the character at the
		   position {lnum} and {col} is not part of a concealable
		   region, 1 if <A HREF="motion.html#it">it</A> is.  {lnum} is used like with |<A HREF="#getline()">getline()</A>|.
		2. The second item in the <A HREF="eval.html#list">list</A> is a <A HREF="eval.html#string">string</A>. If the first item
		   is 1, the second item contains the text which will be
		   displayed in place of the concealed text, depending on the
		   current setting of <A HREF="options.html#'conceallevel'">'conceallevel'</A> and <A HREF="options.html#'listchars'">'listchars'</A>.
		3. The third and final item in the <A HREF="eval.html#list">list</A> is a number
		   representing the specific <A HREF="syntax.html#syntax">syntax</A> region matched in the
		   line. When the character is not concealed the value is
		   zero. This allows detection of the beginning of a new
		   concealable region if there are two consecutive regions
		   with the same replacement character.  For an example, if
		   the text is &quot;123456&quot; and both &quot;23&quot; and &quot;45&quot; are concealed
		   and replaced by the character &quot;<A HREF="change.html#X">X</A>&quot;, then:
<B><FONT COLOR="PURPLE">			call			returns </FONT></B>
			synconcealed(lnum, 1)   [0, <A HREF="motion.html#''">''</A>, 0]
			synconcealed(lnum, 2)   [1, '<A HREF="change.html#X">X</A>', 1]
			synconcealed(lnum, 3)   [1, '<A HREF="change.html#X">X</A>', 1]
			synconcealed(lnum, 4)   [1, '<A HREF="change.html#X">X</A>', 2]
			synconcealed(lnum, 5)   [1, '<A HREF="change.html#X">X</A>', 2]
			synconcealed(lnum, 6)   [0, <A HREF="motion.html#''">''</A>, 0]



synstack({lnum}, {col})					*<A NAME="synstack()"></A><B>synstack()</B>*
		Return a |<A HREF="eval.html#List">List</A>|, which is the stack of <A HREF="syntax.html#syntax">syntax</A> items at the
		position {lnum} and {col} in the current <A HREF="windows.html#window">window</A>.  {lnum} is
		used like with |<A HREF="#getline()">getline()</A>|.  Each item in the <A HREF="eval.html#List">List</A> is an ID
		like what |<A HREF="#synID()">synID()</A>| returns.
		The first item in the <A HREF="eval.html#List">List</A> is the outer region, following are
		items contained in that one.  The last one is what |<A HREF="#synID()">synID()</A>|
		returns, unless not the whole item is highlighted or <A HREF="motion.html#it">it</A> is a
		transparent item.
		This function is useful for debugging a <A HREF="syntax.html#syntax">syntax</A> file.
		Example that shows the <A HREF="syntax.html#syntax">syntax</A> stack under the cursor:
<B>			for id in synstack(line("."), col("."))</B>
<B>			   echo synIDattr(id, "name")</B>
<B>			endfor</B>
 		When the position specified with {lnum} and {col} is invalid
		an empty <A HREF="eval.html#List">List</A> is returned.  The position just after the last
		character in a line and the first column in an empty line are
		valid positions.


system({expr} [, {input}])				*<A NAME="system()"></A><B>system()</B>* *<A NAME="E677"></A><B>E677</B>*
		Get the output of the shell command {expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#String">String</A>|.  See
		|<A HREF="#systemlist()">systemlist()</A>| to get the output <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#List">List</A>|.

		When {input} is given and is a |<A HREF="eval.html#String">String</A>| this <A HREF="eval.html#string">string</A> is written
		to a file and passed <A HREF="motion.html#as">as</A> stdin to the command.  The <A HREF="eval.html#string">string</A> is
		written as-is, you need to take care of using the correct line
		separators yourself.
		If {input} is given and is a |<A HREF="eval.html#List">List</A>| <A HREF="motion.html#it">it</A> is written to the file
		in a way |<A HREF="#writefile()">writefile()</A>| does with {binary} set to &quot;<A HREF="motion.html#b">b</A>&quot; (i.e.
		with a newline between each <A HREF="eval.html#list">list</A> item with newlines inside
		<A HREF="eval.html#list">list</A> items converted to NULs).
		When {input} is given and is a number that is a valid id for
		an existing buffer then the content of the buffer is written
		to the file line by line, each line terminated by a NL and
		NULs characters where the text has a NL.

		Pipes are not used, the <A HREF="options.html#'shelltemp'">'shelltemp'</A> option is not used.

		When prepended by |<A HREF="various.html#:silent">:silent</A>| the <A HREF="terminal.html#terminal">terminal</A> will not be set to
		cooked mode.  This is meant to be used for commands that <A HREF="diff.html#do">do</A>
		not need the user to type.  It avoids stray characters showing
		up on the screen which require |<A HREF="various.html#CTRL-L">CTRL-L</A>| to remove.
<B>			:silent let f = system('ls *.vim')</B>
 
		Note: Use |<A HREF="#shellescape()">shellescape()</A>| or |<A HREF="cmdline.html#::S">::S</A>| with |<A HREF="#expand()">expand()</A>| or
		|<A HREF="#fnamemodify()">fnamemodify()</A>| to <A HREF="intro.html#escape">escape</A> special characters in a command
		argument.  Newlines in {expr} may cause the command to fail.
		The characters in <A HREF="options.html#'shellquote'">'shellquote'</A> and <A HREF="options.html#'shellxquote'">'shellxquote'</A> may also
		cause trouble.
		This is not to be used for interactive commands.

		The result is a <A HREF="eval.html#String">String</A>.  Example:
<B>		    :let files = system('ls ' .. shellescape(expand('%:h')))</B>
<B>		    :let files = system('ls ' .. expand('%:h:S'))</B>

 		To make the result more system-independent, the shell output
		is filtered to replace <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> with <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A> for <A HREF="os_mac.html#Macintosh">Macintosh</A>, and
		&lt;CR&gt;&lt;NL&gt; with <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A> for DOS-like systems.
		To avoid the <A HREF="eval.html#string">string</A> being truncated at a NUL, all NUL
		characters are replaced with SOH (0x01).

		The command executed is constructed using several <A HREF="options.html#options">options</A>:
	<A HREF="options.html#'shell'">'shell'</A> <A HREF="options.html#'shellcmdflag'">'shellcmdflag'</A> <A HREF="options.html#'shellxquote'">'shellxquote'</A> {expr} <A HREF="options.html#'shellredir'">'shellredir'</A> {tmp} <A HREF="options.html#'shellxquote'">'shellxquote'</A>
		({tmp} is an automatically generated file name).
		For <A HREF="os_unix.html#Unix">Unix</A>, braces are put around {expr} to allow for
		concatenated commands.

		The command will be executed in &quot;cooked&quot; mode, so that a
		<A HREF="pattern.html#CTRL-C">CTRL-C</A> will interrupt the command (on <A HREF="os_unix.html#Unix">Unix</A> at least).

		The resulting error code can be found in |<A HREF="eval.html#v:shell_error">v:shell_error</A>|.
		This function will fail in |<A HREF="starting.html#restricted-mode">restricted-mode</A>|.

		Note that any wrong value in the <A HREF="options.html#options">options</A> mentioned above may
		make the function fail.  It has also been reported to fail
		when using a security agent application.
		Unlike &quot;<A HREF="various.html#:!cmd">:!cmd</A>&quot; there is no automatic check for changed files.
		Use |<A HREF="editing.html#:checktime">:checktime</A>| to force a check.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			:echo GetCmd()-&gt;system()</B>



systemlist({expr} [, {input}])				*<A NAME="systemlist()"></A><B>systemlist()</B>*
		Same <A HREF="motion.html#as">as</A> |<A HREF="#system()">system()</A>|, but returns a |<A HREF="eval.html#List">List</A>| with lines (parts of
		output separated by NL) with NULs transformed into NLs. Output
		is the same <A HREF="motion.html#as">as</A> |<A HREF="#readfile()">readfile()</A>| will output with {binary} argument
		set to &quot;<A HREF="motion.html#b">b</A>&quot;, except that there is no extra empty item when the
		result ends in a NL.
		Note that on <A HREF="os_win32.html#MS-Windows">MS-Windows</A> you may get trailing CR characters.

		To see the difference between &quot;echo hello&quot; and &quot;echo <A HREF="starting.html#-n">-n</A> hello&quot;
		use |<A HREF="#system()">system()</A>| and |<A HREF="#split()">split()</A>|:
<B>			echo system('echo hello')-&gt;split('\n', 1)</B>
 
		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			:echo GetCmd()-&gt;systemlist()</B>



tabpagebuflist([{arg}])					*<A NAME="tabpagebuflist()"></A><B>tabpagebuflist()</B>*
		The result is a |<A HREF="eval.html#List">List</A>|, where each item is the number of the
		buffer associated with each <A HREF="windows.html#window">window</A> in the current <A HREF="intro.html#tab">tab</A> page.
		{arg} specifies the number of the <A HREF="intro.html#tab">tab</A> page to be used. When
		omitted the current <A HREF="intro.html#tab">tab</A> page is used.
		When {arg} is invalid the number zero is returned.
		To get a <A HREF="eval.html#list">list</A> of all <A HREF="windows.html#buffers">buffers</A> in all tabs use this:
<B>			let buflist = []</B>
<B>			for i in range(tabpagenr('$'))</B>
<B>			   call extend(buflist, tabpagebuflist(i + 1))</B>
<B>			endfor</B>
 		Note that a buffer may appear in more than one <A HREF="windows.html#window">window</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTabpage()-&gt;tabpagebuflist()</B>


tabpagenr([{arg}])					*<A NAME="tabpagenr()"></A><B>tabpagenr()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the number of the current
		<A HREF="intro.html#tab">tab</A> page.  The first <A HREF="intro.html#tab">tab</A> page has number 1.

		The optional argument {arg} supports the following values:
			$	the number of the last <A HREF="intro.html#tab">tab</A> page (the <A HREF="intro.html#tab">tab</A> page
				<A HREF="intro.html#count">count</A>).
			#	the number of the last accessed <A HREF="intro.html#tab">tab</A> page
				(where |<A HREF="tabpage.html#g&lt;Tab&gt;">g&lt;Tab&gt;</A>| goes to). if there is no
				previous <A HREF="intro.html#tab">tab</A> page 0 is returned.
		The number can be used with the |<A HREF="tabpage.html#:tab">:tab</A>| command.

		Returns zero on error.



tabpagewinnr({tabarg} [, {arg}])			*<A NAME="tabpagewinnr()"></A><B>tabpagewinnr()</B>*
		Like |<A HREF="#winnr()">winnr()</A>| but for <A HREF="intro.html#tab">tab</A> page {tabarg}.
		{tabarg} specifies the number of <A HREF="intro.html#tab">tab</A> page to be used.
		{arg} is used like with YXXYwinnr()|:
		- When omitted the current <A HREF="windows.html#window">window</A> number is returned.  This is
		  the <A HREF="windows.html#window">window</A> which will be used when going to this <A HREF="intro.html#tab">tab</A> page.
		- When &quot;<A HREF="motion.html#$">$</A>&quot; the number of <A HREF="windows.html#windows">windows</A> is returned.
		- When &quot;<A HREF="pattern.html##">#</A>&quot; the previous <A HREF="windows.html#window">window</A> nr is returned.
		Useful examples:
<B>		    tabpagewinnr(1)	    " current window of tab page 1</B>
<B>		    tabpagewinnr(4, '$')    " number of windows in tab page 4</B>
 		When {tabarg} is invalid zero is returned.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTabpage()-&gt;tabpagewinnr()</B>
 

							*<A NAME="tagfiles()"></A><B>tagfiles()</B>*
<A HREF="#tagfiles()">tagfiles()</A>	Returns a |<A HREF="eval.html#List">List</A>| with the file names used to search for <A HREF="tagsrch.html#tags">tags</A>
		for the current buffer.  This is the <A HREF="options.html#'tags'">'tags'</A> option expanded.



taglist({expr} [, {filename}])				*<A NAME="taglist()"></A><B>taglist()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| of <A HREF="tagsrch.html#tags">tags</A> matching the regular <A HREF="eval.html#expression">expression</A> {expr}.

		If {filename} is passed <A HREF="motion.html#it">it</A> is used to prioritize the results
		in the same way that |<A HREF="tagsrch.html#:tselect">:tselect</A>| does. See |<A HREF="tagsrch.html#tag-priority">tag-priority</A>|.
		{filename} should be the full path of the file.

		Each <A HREF="eval.html#list">list</A> item is a dictionary with at least the following
		entries:
			name		Name of the <A HREF="tagsrch.html#tag">tag</A>.
			filename	Name of the file where the <A HREF="tagsrch.html#tag">tag</A> is
					defined.  It is either relative to the
					current directory or a full path.
			cmd		<A HREF="intro.html#Ex">Ex</A> command used to locate the <A HREF="tagsrch.html#tag">tag</A> in
					the file.
			kind		Type of the <A HREF="tagsrch.html#tag">tag</A>.  The value for this
					entry depends on the language specific
					kind values.  Only available when
					using a <A HREF="tagsrch.html#tags">tags</A> file generated by
					Universal/Exuberant <A HREF="tagsrch.html#ctags">ctags</A> or hdrtag.
			static		A file specific <A HREF="tagsrch.html#tag">tag</A>.  Refer to
					|<A HREF="tagsrch.html#static-tag">static-tag</A>| for more information.
		More entries may be present, depending on the content of the
		<A HREF="tagsrch.html#tags">tags</A> file: access, implementation, inherits and signature.
		Refer to the <A HREF="tagsrch.html#ctags">ctags</A> documentation for information about these
		fields.  For C code the fields &quot;struct&quot;, &quot;class&quot; and &quot;enum&quot;
		may appear, they give the name of the entity the <A HREF="tagsrch.html#tag">tag</A> is
		contained in.

		The ex-command &quot;cmd&quot; can be either an <A HREF="starting.html#ex">ex</A> search <A HREF="pattern.html#pattern">pattern</A>, a
		line number or a line number followed by a byte number.

		If there are no matching <A HREF="tagsrch.html#tags">tags</A>, then an empty <A HREF="eval.html#list">list</A> is returned.

		To get an exact <A HREF="tagsrch.html#tag">tag</A> match, the anchors '<A HREF="motion.html#^">^</A>' and '<A HREF="motion.html#$">$</A>' should be
		used in {expr}.  This also make the function work faster.
		Refer to |<A HREF="tagsrch.html#tag-regexp">tag-regexp</A>| for more information about the tag
		search regular <A HREF="eval.html#expression">expression</A> <A HREF="pattern.html#pattern">pattern</A>.

		Refer to |<A HREF="options.html#'tags'">'tags'</A>| for information about how the tags file is
		located by Vim. Refer to |<A HREF="tagsrch.html#tags-file-format">tags-file-format</A>| for the format of
		the <A HREF="tagsrch.html#tags">tags</A> file generated by the different <A HREF="tagsrch.html#ctags">ctags</A> tools.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTagpattern()-&gt;taglist()</B>


tan({expr})						*<A NAME="tan()"></A><B>tan()</B>*
		Return the tangent of {expr}, measured in radians, <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>|
		in the range [-inf, inf].
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo tan(10)</B>
 			0.648361
<B>			:echo tan(-4.01)</B>
 			-1.181502

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;tan()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



tanh({expr})						*<A NAME="tanh()"></A><B>tanh()</B>*
		Return the hyperbolic tangent of {expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| in the
		range [-1, 1].
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			:echo tanh(0.5)</B>
 			0.462117
<B>			:echo tanh(-1)</B>
 			-0.761594

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;tanh()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}



<A HREF="#tempname()">tempname()</A>					*<A NAME="tempname()"></A><B>tempname()</B>* *<A NAME="temp-file-name"></A><B>temp-file-name</B>*
		The result is a <A HREF="eval.html#String">String</A>, which is the name of a file that
		doesn't exist.  It can be used for a temporary file.  The name
		is different for at least 26 consecutive calls.  Example:
<B>			:let tmpfile = tempname()</B>
<B>			:exe "redir &gt; " .. tmpfile</B>
 		For <A HREF="os_unix.html#Unix">Unix</A>, the file will be in a private directory |<A HREF="change.html#tempfile">tempfile</A>|.
		For <A HREF="os_win32.html#MS-Windows">MS-Windows</A> forward slashes are used when the <A HREF="options.html#'shellslash'">'shellslash'</A>
		option is set, or when <A HREF="options.html#'shellcmdflag'">'shellcmdflag'</A> starts with '<A HREF="motion.html#-">-</A>' and
		<A HREF="options.html#'shell'">'shell'</A> does not contain powershell or pwsh.


term_ <A HREF="eval.html#functions">functions</A> are documented here: |<A HREF="terminal.html#terminal-function-details">terminal-function-details</A>|



<A HREF="#terminalprops()">terminalprops()</A>						*<A NAME="terminalprops()"></A><B>terminalprops()</B>*
		Returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| with properties of the <A HREF="terminal.html#terminal">terminal</A> that Vim
		detected from the response to |<A HREF="term.html#t_RV">t_RV</A>| request.  See
		|<A HREF="eval.html#v:termresponse">v:termresponse</A>| for the response itself.  If |<A HREF="eval.html#v:termresponse">v:termresponse</A>|
		is empty most values here will be '<A HREF="undo.html#u">u</A>' for unknown.

		   cursor_style		whether sending |<A HREF="term.html#t_RS">t_RS</A>| works  

		   cursor_blink_mode	whether sending |<A HREF="term.html#t_RC">t_RC</A>| works  

		   underline_rgb	whether |<A HREF="term.html#t_8u">t_8u</A>| works 
		   mouse		mouse type supported


		** value '<A HREF="undo.html#u">u</A>' for unknown, '<A HREF="change.html#y">y</A>' for yes, '<A HREF="pattern.html#n">n</A>' for no

		If the |<A HREF="various.html#+termresponse">+termresponse</A>| feature is missing then the result is
		an empty dictionary.

		If &quot;cursor_style&quot; is '<A HREF="change.html#y">y</A>' then |<A HREF="term.html#t_RS">t_RS</A>| will be sent to request the
		current cursor style.
		If &quot;cursor_blink_mode&quot; is '<A HREF="change.html#y">y</A>' then |<A HREF="term.html#t_RC">t_RC</A>| will be sent to
		request the cursor blink status.
		&quot;cursor_style&quot; and &quot;cursor_blink_mode&quot; are also set if |<A HREF="term.html#t_u7">t_u7</A>|
		is not empty, Vim will detect the working of sending |<A HREF="term.html#t_RS">t_RS</A>|
		and |<A HREF="term.html#t_RC">t_RC</A>| on <A HREF="starting.html#startup">startup</A>.

		When &quot;underline_rgb&quot; is not '<A HREF="change.html#y">y</A>', then |<A HREF="term.html#t_8u">t_8u</A>| will be made empty.
		This avoids sending <A HREF="motion.html#it">it</A> to xterm, which would clear the colors.

		For &quot;mouse&quot; the value '<A HREF="undo.html#u">u</A>' is unknown

		Also see:
		- <A HREF="options.html#'ambiwidth'">'ambiwidth'</A> - detected by using |<A HREF="term.html#t_u7">t_u7</A>|.
		- |<A HREF="eval.html#v:termstyleresp">v:termstyleresp</A>| and |<A HREF="eval.html#v:termblinkresp">v:termblinkresp</A>| for the response to
		  |<A HREF="term.html#t_RS">t_RS</A>| and |<A HREF="term.html#t_RC">t_RC</A>|.


test_ functions are documented here: |<A HREF="testing.html#test-functions-details">test-functions-details</A>|



							*<A NAME="timer_info()"></A><B>timer_info()</B>*
timer_info([{id}])
		Return a <A HREF="eval.html#list">list</A> with information about <A HREF="#timers">timers</A>.
		When {id} is given only information about this <A HREF="#timer">timer</A> is
		returned.  When <A HREF="#timer">timer</A> {id} does not exist an empty <A HREF="eval.html#list">list</A> is
		returned.
		When {id} is omitted information about all <A HREF="#timers">timers</A> is returned.

		For each <A HREF="#timer">timer</A> the information is stored in a |<A HREF="eval.html#Dictionary">Dictionary</A>| with
		these items:
		    &quot;id&quot;	    the <A HREF="#timer">timer</A> ID
		    &quot;time&quot;	    time the <A HREF="#timer">timer</A> was started with
		    &quot;remaining&quot;	    time until the <A HREF="#timer">timer</A> fires
		    &quot;repeat&quot;	    number of times the <A HREF="#timer">timer</A> will still fire;
				    -1 means forever
		    &quot;callback&quot;	    the callback
		    &quot;paused&quot;	    1 if the <A HREF="#timer">timer</A> is paused, 0 otherwise

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTimer()-&gt;timer_info()</B>

 		{only available when compiled with the |<A HREF="various.html#+timers">+timers</A>| feature}


timer_pause({timer}, {paused})				*<A NAME="timer_pause()"></A><B>timer_pause()</B>*
		Pause or unpause a <A HREF="#timer">timer</A>.  A paused <A HREF="#timer">timer</A> does not invoke its
		callback when its time expires.  Unpausing a <A HREF="#timer">timer</A> may cause
		the callback to be invoked almost immediately if enough time
		has passed.

		Pausing a <A HREF="#timer">timer</A> is useful to avoid the callback to be called
		for a short time.

		If {paused} evaluates to a non-zero <A HREF="eval.html#Number">Number</A> or a non-empty
		<A HREF="eval.html#String">String</A>, then the <A HREF="#timer">timer</A> is paused, otherwise <A HREF="motion.html#it">it</A> is unpaused.
		See |<A HREF="eval.html#non-zero-arg">non-zero-arg</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTimer()-&gt;timer_pause(1)</B>

 		{only available when compiled with the |<A HREF="various.html#+timers">+timers</A>| feature}


						*<A NAME="timer_start()"></A><B>timer_start()</B>* *<A NAME="timer"></A><B>timer</B>* *<A NAME="timers"></A><B>timers</B>*
timer_start({time}, {callback} [, {options}])
		Create a <A HREF="#timer">timer</A> and return the <A HREF="#timer">timer</A> ID.

		{time} is the waiting time in milliseconds. This is the
		minimum time before invoking the callback.  When the system is
		busy or Vim is not waiting for input the time will be longer.

		{callback} is the function to call.  It can be the name of a
		function or a |<A HREF="eval.html#Funcref">Funcref</A>|.  It is called with one argument, which
		is the <A HREF="#timer">timer</A> ID.  The callback is only invoked when Vim is
		waiting for input.
		If you want to show a message look at |<A HREF="popup.html#popup_notification()">popup_notification()</A>|
		to avoid interfering with what the user is doing.

		{options} is a dictionary.  Supported entries:
		   &quot;repeat&quot;	<A HREF="eval.html#Number">Number</A> of times to repeat calling the
				callback.  -1 means forever.  When not present
				the callback will be called once.
				If the <A HREF="#timer">timer</A> causes an error three times in a
				row the repeat is cancelled.  This avoids that
				Vim becomes unusable because of all the error
				<A HREF="message.html#messages">messages</A>.

		Returns -1 on error.

		Example:
<B>			func MyHandler(timer)</B>
<B>			  echo 'Handler called'</B>
<B>			endfunc</B>
<B>			let timer = timer_start(500, 'MyHandler',</B>
<B>				\ {'repeat': 3})</B>
 		This will invoke MyHandler() three times at 500 msec
		intervals.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetMsec()-&gt;timer_start(callback)</B>

 		Not available in the |<A HREF="eval.html#sandbox">sandbox</A>|.
		{only available when compiled with the |<A HREF="various.html#+timers">+timers</A>| feature}


timer_stop({timer})					*<A NAME="timer_stop()"></A><B>timer_stop()</B>*
		Stop a <A HREF="#timer">timer</A>.  The <A HREF="#timer">timer</A> callback will no longer be invoked.
		{timer} is an ID returned by <A HREF="#timer_start()">timer_start()</A>, thus <A HREF="motion.html#it">it</A> must be a
		<A HREF="eval.html#Number">Number</A>.  If {timer} does not exist there is no error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTimer()-&gt;timer_stop()</B>

 		{only available when compiled with the |<A HREF="various.html#+timers">+timers</A>| feature}


<A HREF="#timer_stopall()">timer_stopall()</A>						*<A NAME="timer_stopall()"></A><B>timer_stopall()</B>*
		Stop all <A HREF="#timers">timers</A>.  The <A HREF="#timer">timer</A> callbacks will no longer be
		invoked.  Useful if a <A HREF="#timer">timer</A> is misbehaving.  If there are no
		<A HREF="#timers">timers</A> there is no error.

		{only available when compiled with the |<A HREF="various.html#+timers">+timers</A>| feature}


tolower({expr})						*<A NAME="tolower()"></A><B>tolower()</B>*
		The result is a copy of the <A HREF="eval.html#String">String</A> given, with all <A HREF="change.html#uppercase">uppercase</A>
		characters turned into <A HREF="change.html#lowercase">lowercase</A> (just like applying |<A HREF="change.html#gu">gu</A>| to
		the <A HREF="eval.html#string">string</A>).  Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;tolower()</B>


toupper({expr})						*<A NAME="toupper()"></A><B>toupper()</B>*
		The result is a copy of the <A HREF="eval.html#String">String</A> given, with all <A HREF="change.html#lowercase">lowercase</A>
		characters turned into <A HREF="change.html#uppercase">uppercase</A> (just like applying |<A HREF="change.html#gU">gU</A>| to
		the <A HREF="eval.html#string">string</A>).  Returns an empty <A HREF="eval.html#string">string</A> on error.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;toupper()</B>


tr({src}, {fromstr}, {tostr})				*<A NAME="tr()"></A><B>tr()</B>*
		The result is a copy of the {src} <A HREF="eval.html#string">string</A> with all characters
		which appear in {fromstr} replaced by the character in that
		position in the {tostr} <A HREF="eval.html#string">string</A>.  Thus the first character in
		{fromstr} is translated into the first character in {tostr}
		and so on.  Exactly like the <A HREF="os_unix.html#unix">unix</A> &quot;tr&quot; command.
		This code also deals with <A HREF="mbyte.html#multibyte">multibyte</A> characters properly.

		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Examples:
<B>			echo tr("hello there", "ht", "HT")</B>
 		returns &quot;Hello THere&quot;
<B>			echo tr("&lt;blob&gt;", "&lt;&gt;", "{}")</B>
 		returns &quot;{blob}&quot;

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;tr(from, to)</B>


trim({text} [, {mask} [, {dir}]])				*<A NAME="trim()"></A><B>trim()</B>*
		Return {text} <A HREF="motion.html#as">as</A> a <A HREF="eval.html#String">String</A> where any character in {mask} is
		removed from the beginning and/or end of {text}.

		If {mask} is not given, {mask} is all characters up to 0x20,
		which includes <A HREF="intro.html#Tab">Tab</A>, space, NL and CR, plus the non-breaking
		space character 0xa0.

		The optional {dir} argument specifies where to remove the
		characters:
			0	remove from the beginning and end of {text}
			1	remove only at the beginning of {text}
			2	remove only at the end of {text}
		When omitted both ends are trimmed.

		This function deals with <A HREF="mbyte.html#multibyte">multibyte</A> characters properly.
		Returns an empty <A HREF="eval.html#string">string</A> on error.

		Examples:
<B>			echo trim("   some text ")</B>
 		returns &quot;some text&quot;
<B>			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") .. "_TAIL"</B>
 		returns &quot;RESERVE_TAIL&quot;
<B>			echo trim("rm&lt;Xrm&lt;&gt;X&gt;rrm", "rm&lt;&gt;")</B>
 		returns &quot;Xrm&lt;&gt;X&quot; (characters in the middle are not removed)
<B>			echo trim("  vim  ", " ", 2)</B>
 		returns &quot;  vim&quot;

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;trim()</B>


trunc({expr})							*<A NAME="trunc()"></A><B>trunc()</B>*
		Return the largest integral value with magnitude <A HREF="various.html#less">less</A> than or
		equal to {expr} <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#Float">Float</A>| (truncate towards zero).
		{expr} must evaluate to a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Returns 0.0 if {expr} is not a |<A HREF="eval.html#Float">Float</A>| or a |<A HREF="eval.html#Number">Number</A>|.
		Examples:
<B>			echo trunc(1.456)</B>
 			1.0 
<B>			echo trunc(-5.456)</B>
 			-5.0 
<B>			echo trunc(4.0)</B>
 			4.0

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			Compute()-&gt;trunc()</B>
 
		{only available when compiled with the |<A HREF="various.html#+float">+float</A>| feature}


							*<A NAME="type()"></A><B>type()</B>*
type({expr})	The result is a <A HREF="eval.html#Number">Number</A> representing the type of {expr}.
		Instead of using the number directly, <A HREF="motion.html#it">it</A> is better to use the
		v:t_ variable that has the value:
			<A HREF="eval.html#Number">Number</A>:	    0  |<A HREF="eval.html#v:t_number">v:t_number</A>|
			<A HREF="eval.html#String">String</A>:	    1  |<A HREF="eval.html#v:t_string">v:t_string</A>|
			<A HREF="eval.html#Funcref">Funcref</A>:    2  |<A HREF="eval.html#v:t_func">v:t_func</A>|
			<A HREF="eval.html#List">List</A>:	    3  |<A HREF="eval.html#v:t_list">v:t_list</A>|
			<A HREF="eval.html#Dictionary">Dictionary</A>: 4  |<A HREF="eval.html#v:t_dict">v:t_dict</A>|
			<A HREF="eval.html#Float">Float</A>:	    5  |<A HREF="eval.html#v:t_float">v:t_float</A>|
			<A HREF="eval.html#Boolean">Boolean</A>:    6  |<A HREF="eval.html#v:t_bool">v:t_bool</A>| (v:false and <A HREF="eval.html#v:true">v:true</A>)
			<A HREF="eval.html#None">None</A>:	    7  |<A HREF="eval.html#v:t_none">v:t_none</A>| (v:null and <A HREF="eval.html#v:none">v:none</A>)
			<A HREF="eval.html#Job">Job</A>:	    8  |<A HREF="eval.html#v:t_job">v:t_job</A>|
			<A HREF="eval.html#Channel">Channel</A>:    9  |<A HREF="eval.html#v:t_channel">v:t_channel</A>|
			<A HREF="eval.html#Blob">Blob</A>:	   10  |<A HREF="eval.html#v:t_blob">v:t_blob</A>|
		For backward compatibility, this <A HREF="eval.html#method">method</A> can be used:
<B>			:if type(myvar) == type(0)</B>
<B>			:if type(myvar) == type("")</B>
<B>			:if type(myvar) == type(function("tr"))</B>
<B>			:if type(myvar) == type([])</B>
<B>			:if type(myvar) == type({})</B>
<B>			:if type(myvar) == type(0.0)</B>
<B>			:if type(myvar) == type(v:false)</B>
<B>			:if type(myvar) == type(v:none)</B>
 		To check if the v:t_ <A HREF="eval.html#variables">variables</A> exist use this:
<B>			:if exists('v:t_number')</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;type()</B>



typename({expr})					*<A NAME="typename()"></A><B>typename()</B>*
		Return a <A HREF="eval.html#string">string</A> representation of the type of {expr}.
		Example:
<B>			echo typename([1, 2, 3])</B>
<B>			list&lt;number&gt;</B>



undofile({name})					*<A NAME="undofile()"></A><B>undofile()</B>*
		Return the name of the <A HREF="undo.html#undo">undo</A> file that would be used for a file
		with name {name} when <A HREF="editing.html#writing">writing</A>.  This uses the <A HREF="options.html#'undodir'">'undodir'</A>
		option, finding directories that exist.  It does not check if
		the <A HREF="undo.html#undo">undo</A> file exists.
		{name} is always expanded to the full path, since that is what
		is used internally.
		If {name} is empty <A HREF="#undofile()">undofile()</A> returns an empty <A HREF="eval.html#string">string</A>, since a
		buffer without a file name will not write an <A HREF="undo.html#undo">undo</A> file.
		Useful in combination with |<A HREF="undo.html#:wundo">:wundo</A>| and |<A HREF="undo.html#:rundo">:rundo</A>|.
		When compiled without the |<A HREF="various.html#+persistent_undo">+persistent_undo</A>| option this always
		returns an empty <A HREF="eval.html#string">string</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetFilename()-&gt;undofile()</B>


<A HREF="#undotree()">undotree()</A>						*<A NAME="undotree()"></A><B>undotree()</B>*
		Return the current state of the <A HREF="undo.html#undo">undo</A> tree in a dictionary with
		the following items:
		  &quot;seq_last&quot;	The highest <A HREF="undo.html#undo">undo</A> sequence number used.
		  &quot;seq_cur&quot;	The sequence number of the current position in
				the <A HREF="undo.html#undo">undo</A> tree.  This differs from &quot;seq_last&quot;
				when some changes were undone.
		  &quot;time_cur&quot;	Time last used for |<A HREF="undo.html#:earlier">:earlier</A>| and related
				commands.  Use |<A HREF="#strftime()">strftime()</A>| to convert to
				something readable.
		  &quot;save_last&quot;	<A HREF="eval.html#Number">Number</A> of the last file write.  Zero when no
				write yet.
		  &quot;save_cur&quot;	<A HREF="eval.html#Number">Number</A> of the current position in the <A HREF="undo.html#undo">undo</A>
				tree.
		  &quot;synced&quot;	Non-zero when the last <A HREF="undo.html#undo">undo</A> block was synced.
				This happens when waiting from input from the
				user.  See |<A HREF="undo.html#undo-blocks">undo-blocks</A>|.
		  &quot;entries&quot;	A <A HREF="eval.html#list">list</A> of dictionaries with information about
				<A HREF="undo.html#undo">undo</A> blocks.

		The first item in the &quot;entries&quot; <A HREF="eval.html#list">list</A> is the oldest <A HREF="undo.html#undo">undo</A> item.
		Each <A HREF="eval.html#List">List</A> item is a |<A HREF="eval.html#Dictionary">Dictionary</A>| with these items:
		  &quot;seq&quot;		Undo sequence number.  Same <A HREF="motion.html#as">as</A> what appears in
				|<A HREF="undo.html#:undolist">:undolist</A>|.
		  &quot;time&quot;	Timestamp when the change happened.  Use
				|<A HREF="#strftime()">strftime()</A>| to convert to something readable.
		  &quot;newhead&quot;	Only appears in the item that is the last one
				that was added.  This marks the last change
				and where further changes will be added.
		  &quot;curhead&quot;	Only appears in the item that is the last one
				that was undone.  This marks the current
				position in the <A HREF="undo.html#undo">undo</A> tree, the block that will
				be used by a <A HREF="undo.html#redo">redo</A> command.  When nothing was
				undone after the last change this item will
				not appear anywhere.
		  &quot;save&quot;	Only appears on the last block before a file
				write.  The number is the write <A HREF="intro.html#count">count</A>.  The
				first write has number 1, the last one the
				&quot;save_last&quot; mentioned above.
		  &quot;<A HREF="intro.html#alt">alt</A>&quot;		Alternate entry.  This is again a <A HREF="eval.html#List">List</A> of <A HREF="undo.html#undo">undo</A>
				blocks.  Each item may again have an &quot;<A HREF="intro.html#alt">alt</A>&quot;
				item.


uniq({list} [, {func} [, {dict}]])			*<A NAME="uniq()"></A><B>uniq()</B>* *<A NAME="E882"></A><B>E882</B>*
		Remove second and succeeding copies of repeated adjacent
		{list} items in-place.  Returns {list}.  If you want a <A HREF="eval.html#list">list</A>
		to remain unmodified make a copy first:
<B>			:let newlist = uniq(copy(mylist))</B>
 		The default compare function uses the <A HREF="eval.html#string">string</A> representation of
		each item.  For the use of {func} and {dict} see |<A HREF="#sort()">sort()</A>|.

		Returns zero if {list} is not a |<A HREF="eval.html#List">List</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mylist-&gt;uniq()</B>


values({dict})						*<A NAME="values()"></A><B>values()</B>*
		Return a |<A HREF="eval.html#List">List</A>| with all the values of {dict}.  The |<A HREF="eval.html#List">List</A>| is
		in arbitrary order.  Also see |<A HREF="#items()">items()</A>| and |<A HREF="#keys()">keys()</A>|.
		Returns zero if {dict} is not a |<A HREF="eval.html#Dict">Dict</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			mydict-&gt;values()</B>


virtcol({expr} [, {list}])				*<A NAME="virtcol()"></A><B>virtcol()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the screen column of the file
		position given with {expr}.  That is, the last screen position
		occupied by the character at that position, when the screen
		would be of unlimited width.  When there is a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> at the
		position, the returned <A HREF="eval.html#Number">Number</A> will be the column at the end of
		the <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A>.  For example, for a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> in column 1, with <A HREF="options.html#'ts'">'ts'</A>
		set to 8, <A HREF="motion.html#it">it</A> returns 8. |<A HREF="syntax.html#conceal">conceal</A>| is ignored.
		For the byte position use |<A HREF="#col()">col()</A>|.

		For the use of {expr} see |<A HREF="#col()">col()</A>|.

		When <A HREF="options.html#'virtualedit'">'virtualedit'</A> is used {expr} can be [lnum, col, off],
		where &quot;off&quot; is the offset in screen columns from the start of
		the character.  E.g., a position within a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> or after the
		last character.  When &quot;off&quot; is omitted zero is used.  When
		Virtual editing is active in the current mode, a position
		beyond the end of the line can be returned.  Also see
		|<A HREF="options.html#'virtualedit'">'virtualedit'</A>|

		The accepted positions are:
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of displayed characters in the cursor line
			    plus one)
		    'x	    position of <A HREF="motion.html#mark">mark</A> <A HREF="change.html#x">x</A> (if the <A HREF="motion.html#mark">mark</A> is not set, 0 is
			    returned)
		    <A HREF="visual.html#v">v</A>       In <A HREF="visual.html#Visual">Visual</A> mode: the start of the <A HREF="visual.html#Visual">Visual</A> area (the
			    cursor is the end).  When not in <A HREF="visual.html#Visual">Visual</A> mode
			    returns the cursor position.  Differs from |<A HREF="motion.html#'&lt;">'&lt;</A>| in
			    that it's updated right away.

		If {list} is present and non-zero then <A HREF="#virtcol()">virtcol()</A> returns a <A HREF="eval.html#List">List</A>
		with the first and last screen position occupied by the
		character.

		Note that only marks in the current file can be used.
		Examples:
<B>			" With text "foo^Lbar" and cursor on the "^L":</B>

<B>			virtcol(".")	" returns 5</B>
<B>			virtcol(".", 1)	" returns [4, 5]</B>
<B>			virtcol("$")	" returns 9</B>

<B>			" With text "	  there", with 't at 'h':</B>

<B>			virtcol("'t")	" returns 6</B>
 		The first column is 1.  0 is returned for an error.
		A more advanced example that echoes the maximum length of
		all lines:
<B>		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetPos()-&gt;virtcol()</B>


virtcol2col({winid}, {lnum}, {col})			*<A NAME="virtcol2col()"></A><B>virtcol2col()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the byte index of the
		character in <A HREF="windows.html#window">window</A> {winid} at buffer line {lnum} and virtual
		column {col}.

		If {col} is greater than the last virtual column in line
		{lnum}, then the byte index of the character at the last
		virtual column is returned.

		The {winid} argument can be the <A HREF="windows.html#window">window</A> number or the
		|<A HREF="windows.html#window-ID">window-ID</A>|. If this is zero, then the current window is used.

		Returns -1 if the <A HREF="windows.html#window">window</A> {winid} doesn't exist or the buffer
		line {lnum} or virtual column {col} is invalid.

		See also |<A HREF="#screenpos()">screenpos()</A>|, |<A HREF="#virtcol()">virtcol()</A>| and |<A HREF="#col()">col()</A>|.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;virtcol2col(lnum, col)</B>


visualmode([{expr}])						*<A NAME="visualmode()"></A><B>visualmode()</B>*
		The result is a <A HREF="eval.html#String">String</A>, which describes the last <A HREF="visual.html#Visual">Visual</A> mode
		used in the current buffer.  Initially <A HREF="motion.html#it">it</A> returns an empty
		<A HREF="eval.html#string">string</A>, but once <A HREF="visual.html#Visual">Visual</A> mode has been used, <A HREF="motion.html#it">it</A> returns &quot;<A HREF="visual.html#v">v</A>&quot;,
		&quot;<A HREF="visual.html#V">V</A>&quot;, or &quot;&lt;CTRL-V&gt;&quot; (a single <A HREF="visual.html#CTRL-V">CTRL-V</A> character) for
		character-wise, line-wise, or block-wise <A HREF="visual.html#Visual">Visual</A> mode
		respectively.
		Example:
<B>			:exe "normal " .. visualmode()</B>
 		This enters the same <A HREF="visual.html#Visual">Visual</A> mode <A HREF="motion.html#as">as</A> before.  It is also useful
		in scripts if you wish to act differently depending on the
		<A HREF="visual.html#Visual">Visual</A> mode that was used.
		If <A HREF="visual.html#Visual">Visual</A> mode is active, use |<A HREF="#mode()">mode()</A>| to get the <A HREF="visual.html#Visual">Visual</A> mode
		(e.g., in a |<A HREF="map.html#:vmap">:vmap</A>|).
		If {expr} is supplied and <A HREF="motion.html#it">it</A> evaluates to a non-zero <A HREF="eval.html#Number">Number</A> or
		a non-empty <A HREF="eval.html#String">String</A>, then the <A HREF="visual.html#Visual">Visual</A> mode will be cleared and
		the old value is returned.  See |<A HREF="eval.html#non-zero-arg">non-zero-arg</A>|.


<A HREF="#wildmenumode()">wildmenumode()</A>					*<A NAME="wildmenumode()"></A><B>wildmenumode()</B>*
		Returns |<A HREF="eval.html#TRUE">TRUE</A>| when the wildmenu is active and |<A HREF="eval.html#FALSE">FALSE</A>|
		otherwise.  See <A HREF="options.html#'wildmenu'">'wildmenu'</A> and <A HREF="options.html#'wildmode'">'wildmode'</A>.
		This can be used in mappings to handle the <A HREF="options.html#'wildcharm'">'wildcharm'</A> option
		gracefully. (Makes only sense with |<A HREF="map.html#mapmode-c">mapmode-c</A>| mappings).

		For example to make &lt;c-j&gt; work like &lt;down&gt; in wildmode, use:
<B>    :cnoremap &lt;expr&gt; &lt;C-j&gt; wildmenumode() ? "\&lt;Down&gt;\&lt;Tab&gt;" : "\&lt;c-j&gt;"</B>
 
		(Note, this needs the <A HREF="options.html#'wildcharm'">'wildcharm'</A> option set appropriately).


win_execute({id}, {command} [, {silent}])		*<A NAME="win_execute()"></A><B>win_execute()</B>*
		Like `execute()` but in the context of <A HREF="windows.html#window">window</A> {id}.
		The <A HREF="windows.html#window">window</A> will temporarily be made the current <A HREF="windows.html#window">window</A>,
		without triggering <A HREF="autocmd.html#autocommands">autocommands</A> or <A HREF="change.html#changing">changing</A> directory.  When
		executing {command} <A HREF="autocmd.html#autocommands">autocommands</A> will be triggered, this may
		have unexpected side effects.  Use |<A HREF="autocmd.html#:noautocmd">:noautocmd</A>| if needed.
		Example:
<B>			call win_execute(winid, 'set syntax=python')</B>
 		Doing the same with `setwinvar()` would not trigger
		<A HREF="autocmd.html#autocommands">autocommands</A> and not actually show <A HREF="syntax.html#syntax">syntax</A> highlighting.

							*<A NAME="E994"></A><B>E994</B>*
		Not all commands are allowed in <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#windows">windows</A>.
		When <A HREF="windows.html#window">window</A> {id} does not exist then no error is given and
		an empty <A HREF="eval.html#string">string</A> is returned.

		Can also be used <A HREF="motion.html#as">as</A> a |<A HREF="eval.html#method">method</A>|, the base is passed <A HREF="motion.html#as">as</A> the
		second argument:
<B>			GetCommand()-&gt;win_execute(winid)</B>


win_findbuf({bufnr})					*<A NAME="win_findbuf()"></A><B>win_findbuf()</B>*
		Returns a |<A HREF="eval.html#List">List</A>| with |<A HREF="windows.html#window-ID">window-ID</A>|s for <A HREF="windows.html#windows">windows</A> that contain
		buffer {bufnr}.  When there is none the <A HREF="eval.html#list">list</A> is empty.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetBufnr()-&gt;win_findbuf()</B>


win_getid([{win} [, {tab}]])				*<A NAME="win_getid()"></A><B>win_getid()</B>*
		Get the |<A HREF="windows.html#window-ID">window-ID</A>| for the specified window.
		When {win} is missing use the current <A HREF="windows.html#window">window</A>.
		With {win} this is the <A HREF="windows.html#window">window</A> number.  The top <A HREF="windows.html#window">window</A> has
		number 1.
		Without {tab} use the current <A HREF="intro.html#tab">tab</A>, otherwise the <A HREF="intro.html#tab">tab</A> with
		number {tab}.  The first <A HREF="intro.html#tab">tab</A> has number one.
		Return zero if the <A HREF="windows.html#window">window</A> cannot be found.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;win_getid()</B>



win_gettype([{nr}])					*<A NAME="win_gettype()"></A><B>win_gettype()</B>*
		Return the type of the <A HREF="windows.html#window">window</A>:
			&quot;autocmd&quot;	<A HREF="autocmd.html#autocommand">autocommand</A> <A HREF="windows.html#window">window</A>. Temporary <A HREF="windows.html#window">window</A>
					used to execute <A HREF="autocmd.html#autocommands">autocommands</A>.
			&quot;command&quot;	command-line <A HREF="windows.html#window">window</A> |<A HREF="cmdline.html#cmdwin">cmdwin</A>|
			(empty)		normal <A HREF="windows.html#window">window</A>
			&quot;loclist&quot;	|<A HREF="quickfix.html#location-list-window">location-list-window</A>|
			&quot;popup&quot;		popup <A HREF="windows.html#window">window</A> |<A HREF="popup.html#popup">popup</A>|
			&quot;preview&quot;	preview window |<A HREF="windows.html#preview-window">preview-window</A>|
			&quot;quickfix&quot;	|<A HREF="quickfix.html#quickfix-window">quickfix-window</A>|
			&quot;unknown&quot;	<A HREF="windows.html#window">window</A> {nr} not found

		When {nr} is omitted return the type of the current <A HREF="windows.html#window">window</A>.
		When {nr} is given return the type of this <A HREF="windows.html#window">window</A> by number or
		|<A HREF="windows.html#window-ID">window-ID</A>|.

		Also see the <A HREF="options.html#'buftype'">'buftype'</A> option.  When running a <A HREF="terminal.html#terminal">terminal</A> in a
		<A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A> then <A HREF="options.html#'buftype'">'buftype'</A> is &quot;<A HREF="terminal.html#terminal">terminal</A>&quot; and <A HREF="#win_gettype()">win_gettype()</A>
		returns &quot;<A HREF="popup.html#popup">popup</A>&quot;.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;win_gettype()</B>
 

win_gotoid({expr})					*<A NAME="win_gotoid()"></A><B>win_gotoid()</B>*
		Go to <A HREF="windows.html#window">window</A> with ID {expr}.  This may also change the current
		<A HREF="tabpage.html#tabpage">tabpage</A>.
		Return <A HREF="eval.html#TRUE">TRUE</A> if successful, <A HREF="eval.html#FALSE">FALSE</A> if the <A HREF="windows.html#window">window</A> cannot be found.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;win_gotoid()</B>


win_id2tabwin({expr})					*<A NAME="win_id2tabwin()"></A><B>win_id2tabwin()</B>*
		Return a <A HREF="eval.html#list">list</A> with the <A HREF="intro.html#tab">tab</A> number and <A HREF="windows.html#window">window</A> number of <A HREF="windows.html#window">window</A>
		with ID {expr}: [tabnr, winnr].
		Return [0, 0] if the <A HREF="windows.html#window">window</A> cannot be found.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;win_id2tabwin()</B>


win_id2win({expr})					*<A NAME="win_id2win()"></A><B>win_id2win()</B>*
		Return the <A HREF="windows.html#window">window</A> number of <A HREF="windows.html#window">window</A> with ID {expr}.
		Return 0 if the <A HREF="windows.html#window">window</A> cannot be found in the current <A HREF="tabpage.html#tabpage">tabpage</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;win_id2win()</B>


win_move_separator({nr}, <A HREF="pattern.html#{offset}">{offset}</A>)			*<A NAME="win_move_separator()"></A><B>win_move_separator()</B>*
		Move <A HREF="windows.html#window">window</A> {nr}'s vertical separator (i.e., the right border)
		by <A HREF="pattern.html#{offset}">{offset}</A> columns, <A HREF="motion.html#as">as</A> if being dragged by the mouse. {nr}
		can be a window number or |<A HREF="windows.html#window-ID">window-ID</A>|. A positive <A HREF="pattern.html#{offset}">{offset}</A>
		moves right and a negative <A HREF="pattern.html#{offset}">{offset}</A> moves left. Moving a
		window's vertical separator will change the width of the
		<A HREF="windows.html#window">window</A> and the width of other <A HREF="windows.html#windows">windows</A> adjacent to the vertical
		separator. The magnitude of <A HREF="intro.html#movement">movement</A> may be smaller than
		specified (e.g., <A HREF="motion.html#as">as</A> a consequence of maintaining
		<A HREF="options.html#'winminwidth'">'winminwidth'</A>). Returns <A HREF="eval.html#TRUE">TRUE</A> if the <A HREF="windows.html#window">window</A> can be found and
		<A HREF="eval.html#FALSE">FALSE</A> otherwise.
		This will fail for the rightmost <A HREF="windows.html#window">window</A> and a full-width
		<A HREF="windows.html#window">window</A>, since <A HREF="motion.html#it">it</A> has no separator on the right.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;win_move_separator(offset)</B>


win_move_statusline({nr}, <A HREF="pattern.html#{offset}">{offset}</A>)			*<A NAME="win_move_statusline()"></A><B>win_move_statusline()</B>*
		Move <A HREF="windows.html#window">window</A> {nr}'s status line (i.e., the bottom border) by
		<A HREF="pattern.html#{offset}">{offset}</A> rows, <A HREF="motion.html#as">as</A> if being dragged by the mouse. {nr} can be a
		window number or |<A HREF="windows.html#window-ID">window-ID</A>|. A positive <A HREF="pattern.html#{offset}">{offset}</A> moves down
		and a negative <A HREF="pattern.html#{offset}">{offset}</A> moves up. Moving a window's status
		line will change the height of the <A HREF="windows.html#window">window</A> and the height of
		other <A HREF="windows.html#windows">windows</A> adjacent to the status line. The magnitude of
		<A HREF="intro.html#movement">movement</A> may be smaller than specified (e.g., <A HREF="motion.html#as">as</A> a consequence
		of maintaining <A HREF="options.html#'winminheight'">'winminheight'</A>). Returns <A HREF="eval.html#TRUE">TRUE</A> if the <A HREF="windows.html#window">window</A> can
		be found and <A HREF="eval.html#FALSE">FALSE</A> otherwise.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinnr()-&gt;win_move_statusline(offset)</B>


win_screenpos({nr})					*<A NAME="win_screenpos()"></A><B>win_screenpos()</B>*
		Return the screen position of <A HREF="windows.html#window">window</A> {nr} <A HREF="motion.html#as">as</A> a <A HREF="eval.html#list">list</A> with two
		numbers: [row, col].  The first <A HREF="windows.html#window">window</A> always has position
		[1, 1], unless there is a tabline, then <A HREF="motion.html#it">it</A> is [2, 1].
		{nr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.  Use zero
		for the current <A HREF="windows.html#window">window</A>.
		Returns [0, 0] if the <A HREF="windows.html#window">window</A> cannot be found in the current
		<A HREF="tabpage.html#tabpage">tabpage</A>.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;win_screenpos()</B>
 

win_splitmove({nr}, {target} [, {options}])		*<A NAME="win_splitmove()"></A><B>win_splitmove()</B>*
		Move the <A HREF="windows.html#window">window</A> {nr} to a new split of the <A HREF="windows.html#window">window</A> {target}.
		This is similar to moving to {target}, creating a new <A HREF="windows.html#window">window</A>
		using |<A HREF="windows.html#:split">:split</A>| but having the same contents <A HREF="motion.html#as">as</A> <A HREF="windows.html#window">window</A> {nr}, and
		then closing {nr}.

		Both {nr} and {target} can be window numbers or |<A HREF="windows.html#window-ID">window-ID</A>|<A HREF="change.html#s">s</A>.
		Both must be in the current <A HREF="intro.html#tab">tab</A> page.

		Returns zero for success, non-zero for failure.

		{options} is a |<A HREF="eval.html#Dictionary">Dictionary</A>| with the following optional entries:
		  &quot;vertical&quot;	When <A HREF="eval.html#TRUE">TRUE</A>, the split is created vertically,
				like with |<A HREF="windows.html#:vsplit">:vsplit</A>|.
		  &quot;rightbelow&quot;	When <A HREF="eval.html#TRUE">TRUE</A>, the split is made below or to the
				right (if vertical).  When <A HREF="eval.html#FALSE">FALSE</A>, <A HREF="motion.html#it">it</A> is done
				above or to the left (if vertical).  When not
				present, the values of <A HREF="options.html#'splitbelow'">'splitbelow'</A> and
				<A HREF="options.html#'splitright'">'splitright'</A> are used.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;win_splitmove(target)</B>
 


							*<A NAME="winbufnr()"></A><B>winbufnr()</B>*
winbufnr({nr})	The result is a <A HREF="eval.html#Number">Number</A>, which is the number of the buffer
		associated with <A HREF="windows.html#window">window</A> {nr}.  {nr} can be the <A HREF="windows.html#window">window</A> number or
		the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {nr} is zero, the number of the buffer in the current
		<A HREF="windows.html#window">window</A> is returned.
		When <A HREF="windows.html#window">window</A> {nr} doesn't exist, -1 is returned.
		Example:
<B>  :echo "The file in the current window is " . bufname(winbufnr(0))</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			FindWindow()-&gt;winbufnr()-&gt;bufname()</B>
 

							*<A NAME="wincol()"></A><B>wincol()</B>*
<A HREF="#wincol()">wincol()</A>	The result is a <A HREF="eval.html#Number">Number</A>, which is the virtual column of the
		cursor in the <A HREF="windows.html#window">window</A>.  This is counting screen cells from the
		left side of the <A HREF="windows.html#window">window</A>.  The leftmost column is one.


							*<A NAME="windowsversion()"></A><B>windowsversion()</B>*
<A HREF="#windowsversion()">windowsversion()</A>
		The result is a <A HREF="eval.html#String">String</A>.  For <A HREF="os_win32.html#MS-Windows">MS-Windows</A> <A HREF="motion.html#it">it</A> indicates the OS
		version.  E.g, Windows 10 is &quot;10.0&quot;, Windows 8 is &quot;6.2&quot;,
		Windows XP is &quot;5.1&quot;.  For non-MS-Windows systems the result is
		an empty <A HREF="eval.html#string">string</A>.


winheight({nr})						*<A NAME="winheight()"></A><B>winheight()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the height of <A HREF="windows.html#window">window</A> {nr}.
		{nr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {nr} is zero, the height of the current <A HREF="windows.html#window">window</A> is
		returned.  When <A HREF="windows.html#window">window</A> {nr} doesn't exist, -1 is returned.
		An existing <A HREF="windows.html#window">window</A> always has a height of zero or more.
		This excludes any <A HREF="windows.html#window">window</A> toolbar line.
		Examples:
<B>  :echo "The current window has " .. winheight(0) .. " lines."</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;winheight()</B>
 

winlayout([{tabnr}])					*<A NAME="winlayout()"></A><B>winlayout()</B>*
		The result is a nested <A HREF="eval.html#List">List</A> containing the layout of <A HREF="windows.html#windows">windows</A>
		in a <A HREF="tabpage.html#tabpage">tabpage</A>.

		Without {tabnr} use the current <A HREF="tabpage.html#tabpage">tabpage</A>, otherwise the <A HREF="tabpage.html#tabpage">tabpage</A>
		with number {tabnr}. If the <A HREF="tabpage.html#tabpage">tabpage</A> {tabnr} is not found,
		returns an empty <A HREF="eval.html#list">list</A>.

		For a leaf <A HREF="windows.html#window">window</A>, <A HREF="motion.html#it">it</A> returns:
			['leaf', {winid}]
		For horizontally split <A HREF="windows.html#windows">windows</A>, which form a column, <A HREF="motion.html#it">it</A>
		returns:
			['col', [{nested <A HREF="eval.html#list">list</A> of windows}]]
		For vertically split <A HREF="windows.html#windows">windows</A>, which form a row, <A HREF="motion.html#it">it</A> returns:
			['row', [{nested <A HREF="eval.html#list">list</A> of windows}]]

		Example:
<B>			" Only one window in the tab page</B>
<B>			:echo winlayout()</B>
<B>			['leaf', 1000]</B>
<B>			" Two horizontally split windows</B>
<B>			:echo winlayout()</B>
<B>			['col', [['leaf', 1000], ['leaf', 1001]]]</B>
<B>			" The second tab page, with three horizontally split</B>
<B>			" windows, with two vertically split windows in the</B>
<B>			" middle window</B>
<B>			:echo winlayout(2)</B>
<B>			['col', [['leaf', 1002], ['row', [['leaf', 1003],</B>
<B>					    ['leaf', 1001]]], ['leaf', 1000]]]</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetTabnr()-&gt;winlayout()</B>
 

							*<A NAME="winline()"></A><B>winline()</B>*
<A HREF="#winline()">winline()</A>	The result is a <A HREF="eval.html#Number">Number</A>, which is the screen line of the cursor
		in the <A HREF="windows.html#window">window</A>.  This is counting screen lines from the top of
		the <A HREF="windows.html#window">window</A>.  The first line is one.
		If the cursor was moved the <A HREF="starting.html#view">view</A> on the file will be updated
		first, this may cause a scroll.


							*<A NAME="winnr()"></A><B>winnr()</B>*
winnr([{arg}])	The result is a <A HREF="eval.html#Number">Number</A>, which is the number of the current
		<A HREF="windows.html#window">window</A>.  The top <A HREF="windows.html#window">window</A> has number 1.
		Returns zero for a <A HREF="popup.html#popup">popup</A> <A HREF="windows.html#window">window</A>.

		The optional argument {arg} supports the following values:
			$	the number of the last <A HREF="windows.html#window">window</A> (the <A HREF="windows.html#window">window</A>
				<A HREF="intro.html#count">count</A>).
			#	the number of the last accessed <A HREF="windows.html#window">window</A> (where
				|<A HREF="windows.html#CTRL-W_p">CTRL-W_p</A>| goes to).  If there is no previous
				<A HREF="windows.html#window">window</A> or <A HREF="motion.html#it">it</A> is in another <A HREF="intro.html#tab">tab</A> page 0 is
				returned.
			{N}j	the number of the Nth <A HREF="windows.html#window">window</A> below the
				current <A HREF="windows.html#window">window</A> (where |<A HREF="windows.html#CTRL-W_j">CTRL-W_j</A>| goes to).
			{N}k	the number of the Nth <A HREF="windows.html#window">window</A> above the current
				<A HREF="windows.html#window">window</A> (where |<A HREF="windows.html#CTRL-W_k">CTRL-W_k</A>| goes to).
			{N}h	the number of the Nth <A HREF="windows.html#window">window</A> left of the
				current <A HREF="windows.html#window">window</A> (where |<A HREF="windows.html#CTRL-W_h">CTRL-W_h</A>| goes to).
			{N}l	the number of the Nth <A HREF="windows.html#window">window</A> right of the
				current <A HREF="windows.html#window">window</A> (where |<A HREF="windows.html#CTRL-W_l">CTRL-W_l</A>| goes to).
		The number can be used with |<A HREF="windows.html#CTRL-W_w">CTRL-W_w</A>| and &quot;<A HREF="windows.html#:wincmd">:wincmd</A> w&quot;
		|<A HREF="windows.html#:wincmd">:wincmd</A>|.
		When {arg} is invalid an error is given and zero is returned.
		Also see |<A HREF="#tabpagewinnr()">tabpagewinnr()</A>| and |<A HREF="#win_getid()">win_getid()</A>|.
		Examples:
<B>			let window_count = winnr('$')</B>
<B>			let prev_window = winnr('#')</B>
<B>			let wnum = winnr('3k')</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinval()-&gt;winnr()</B>
 

							*<A NAME="winrestcmd()"></A><B>winrestcmd()</B>*
<A HREF="#winrestcmd()">winrestcmd()</A>	Returns a sequence of |<A HREF="windows.html#:resize">:resize</A>| commands that should restore
		the current <A HREF="windows.html#window">window</A> sizes.  Only works properly when no <A HREF="windows.html#windows">windows</A>
		are opened or closed and the current <A HREF="windows.html#window">window</A> and <A HREF="intro.html#tab">tab</A> page is
		unchanged.
		Example:
<B>			:let cmd = winrestcmd()</B>
<B>			:call MessWithWindowSizes()</B>
<B>			:exe cmd</B>
 

							*<A NAME="winrestview()"></A><B>winrestview()</B>*
winrestview({dict})
		Uses the |<A HREF="eval.html#Dictionary">Dictionary</A>| returned by |<A HREF="#winsaveview()">winsaveview()</A>| to restore
		the <A HREF="starting.html#view">view</A> of the current <A HREF="windows.html#window">window</A>.
		Note: The {dict} does not have to contain all values, that are
		returned by |<A HREF="#winsaveview()">winsaveview()</A>|. If values are missing, those
		settings won't be restored. So you can use:
<B>		    :call winrestview({'curswant': 4})</B>
 
		This will only set the curswant value (the column the cursor
		wants to move on vertical movements) of the cursor to column 5
		(yes, that is 5), while all other settings will remain the
		same. This is useful, if you set the cursor position manually.

		If you have changed the values the result is unpredictable.
		If the <A HREF="windows.html#window">window</A> size changed the result won't be the same.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetView()-&gt;winrestview()</B>
 

							*<A NAME="winsaveview()"></A><B>winsaveview()</B>*
<A HREF="#winsaveview()">winsaveview()</A>	Returns a |<A HREF="eval.html#Dictionary">Dictionary</A>| that contains information to restore
		the view of the current <A HREF="windows.html#window">window</A>.  Use |<A HREF="#winrestview()">winrestview()</A>| to
		restore the <A HREF="starting.html#view">view</A>.
		This is useful if you have a <A HREF="map.html#mapping">mapping</A> that jumps around in the
		buffer and you want to go back to the original <A HREF="starting.html#view">view</A>.
		This does not save fold information.  Use the <A HREF="options.html#'foldenable'">'foldenable'</A>
		option to temporarily switch off <A HREF="fold.html#folding">folding</A>, so that <A HREF="fold.html#folds">folds</A> are
		not opened when moving around. This may have side effects.
		The return value includes:
			lnum		cursor line number
			col		cursor column (Note: the first column
					zero, <A HREF="motion.html#as">as</A> opposed to what |<A HREF="#getcurpos()">getcurpos()</A>|
					returns)
			coladd		cursor column offset for <A HREF="options.html#'virtualedit'">'virtualedit'</A>
			curswant	column for vertical <A HREF="intro.html#movement">movement</A> (Note:
					the first column is zero, <A HREF="motion.html#as">as</A> opposed
					to what |<A HREF="#getcurpos()">getcurpos()</A>| returns).  After
					|<A HREF="motion.html#$">$</A>| command <A HREF="motion.html#it">it</A> will be a very large
					number equal to |<A HREF="eval.html#v:maxcol">v:maxcol</A>|.
			topline		first line in the <A HREF="windows.html#window">window</A>
			topfill		filler lines, only in <A HREF="diff.html#diff">diff</A> mode
			leftcol		first column displayed; only used when
					<A HREF="options.html#'wrap'">'wrap'</A> is off
			skipcol		columns skipped
		Note that no option values are saved.



winwidth({nr})						*<A NAME="winwidth()"></A><B>winwidth()</B>*
		The result is a <A HREF="eval.html#Number">Number</A>, which is the width of <A HREF="windows.html#window">window</A> {nr}.
		{nr} can be the window number or the |<A HREF="windows.html#window-ID">window-ID</A>|.
		When {nr} is zero, the width of the current <A HREF="windows.html#window">window</A> is
		returned.  When <A HREF="windows.html#window">window</A> {nr} doesn't exist, -1 is returned.
		An existing <A HREF="windows.html#window">window</A> always has a width of zero or more.
		Examples:
<B>  :echo "The current window has " .. winwidth(0) .. " columns."</B>
<B>  :if winwidth(0) &lt;= 50</B>
<B>  :  50 wincmd |</B>
<B>  :endif</B>
 		For getting the <A HREF="terminal.html#terminal">terminal</A> or screen size, see the <A HREF="options.html#'columns'">'columns'</A>
		option.

		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetWinid()-&gt;winwidth()</B>



<A HREF="#wordcount()">wordcount()</A>						*<A NAME="wordcount()"></A><B>wordcount()</B>*
		The result is a dictionary of byte/chars/word statistics for
		the current buffer.  This is the same info <A HREF="motion.html#as">as</A> provided by
		|<A HREF="editing.html#g_CTRL-G">g_CTRL-G</A>|
		The return value includes:
			bytes		<A HREF="eval.html#Number">Number</A> of bytes in the buffer
			chars		<A HREF="eval.html#Number">Number</A> of chars in the buffer
			words		<A HREF="eval.html#Number">Number</A> of words in the buffer
			cursor_bytes    <A HREF="eval.html#Number">Number</A> of bytes before cursor position
					(not in <A HREF="visual.html#Visual">Visual</A> mode)
			cursor_chars    <A HREF="eval.html#Number">Number</A> of chars before cursor position
					(not in <A HREF="visual.html#Visual">Visual</A> mode)
			cursor_words    <A HREF="eval.html#Number">Number</A> of words before cursor position
					(not in <A HREF="visual.html#Visual">Visual</A> mode)
			visual_bytes    <A HREF="eval.html#Number">Number</A> of bytes visually selected
					(only in <A HREF="visual.html#Visual">Visual</A> mode)
			visual_chars    <A HREF="eval.html#Number">Number</A> of chars visually selected
					(only in <A HREF="visual.html#Visual">Visual</A> mode)
			visual_words    <A HREF="eval.html#Number">Number</A> of words visually selected
					(only in <A HREF="visual.html#Visual">Visual</A> mode)



							*<A NAME="writefile()"></A><B>writefile()</B>*
writefile({object}, {fname} [, {flags}])
		When {object} is a |<A HREF="eval.html#List">List</A>| write <A HREF="motion.html#it">it</A> to file {fname}.  Each <A HREF="eval.html#list">list</A>
		item is separated with a NL.  Each <A HREF="eval.html#list">list</A> item must be a <A HREF="eval.html#String">String</A>
		or <A HREF="eval.html#Number">Number</A>.
		When {flags} contains &quot;<A HREF="motion.html#b">b</A>&quot; then binary mode is used: There will
		not be a NL after the last <A HREF="eval.html#list">list</A> item.  An empty item at the
		end does cause the last line in the file to end in a NL.

		When {object} is a |<A HREF="eval.html#Blob">Blob</A>| write the bytes to file {fname}
		unmodified.

		When {flags} contains &quot;<A HREF="insert.html#a">a</A>&quot; then append mode is used, lines are
		appended to the file:
<B>			:call writefile(["foo"], "event.log", "a")</B>
<B>			:call writefile(["bar"], "event.log", "a")</B>
 
		When {flags} contains &quot;<A HREF="change.html#s">s</A>&quot; then fsync() is called after <A HREF="editing.html#writing">writing</A>
		the file.  This flushes the file to disk, if possible.  This
		takes more time but avoids losing the file if the system
		crashes.
		When {flags} does not contain &quot;<A HREF="change.html#S">S</A>&quot; or &quot;<A HREF="change.html#s">s</A>&quot; then fsync() is
		called if the <A HREF="options.html#'fsync'">'fsync'</A> option is set.
		When {flags} contains &quot;<A HREF="change.html#S">S</A>&quot; then fsync() is not called, even
		when <A HREF="options.html#'fsync'">'fsync'</A> is set.

		All NL characters are replaced with a NUL character.
		Inserting CR characters needs to be done before passing {list}
		to <A HREF="#writefile()">writefile()</A>.
		An existing file is overwritten, if possible.
		When the write fails -1 is returned, otherwise 0.  There is an
		error message if the file can't be created or when <A HREF="editing.html#writing">writing</A>
		fails.
		Also see |<A HREF="#readfile()">readfile()</A>|.
		To copy a file byte for byte:
<B>			:let fl = readfile("foo", "b")</B>
<B>			:call writefile(fl, "foocopy", "b")</B>

 		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			GetText()-&gt;writefile("thefile")</B>



xor({expr}, {expr})					*<A NAME="xor()"></A><B>xor()</B>*
		Bitwise XOR on the two arguments.  The arguments are converted
		to a number.  A <A HREF="eval.html#List">List</A>, <A HREF="eval.html#Dict">Dict</A> or <A HREF="eval.html#Float">Float</A> argument causes an error.
		Also see `and()` and `or()`.
		Example:
<B>			:let bits = xor(bits, 0x80)</B>
 
		Can also be used <A HREF="motion.html#as">as</A> a YXXYmethod|:
<B>			:let bits = bits-&gt;xor(0x80)</B>
 

==============================================================================

3. Feature <A HREF="eval.html#list">list</A>						*<A NAME="feature-list"></A><B>feature-list</B>*

There are three types of features:
1.  Features that are only supported when they have been enabled when Vim
    was compiled |<A HREF="various.html#+feature-list">+feature-list</A>|.  Example:
<B>	:if has("cindent")</B>

 							*<A NAME="gui_running"></A><B>gui_running</B>*
2.  Features that are only supported when certain conditions have been met.
    Example:
<B>	:if has("gui_running")</B>

 							*<A NAME="has-patch"></A><B>has-patch</B>*
3.  Beyond a certain version or at a certain version and including a specific
    patch.  The &quot;patch-7.4.248&quot; feature means that the Vim version is 7.5 or
    later, or <A HREF="motion.html#it">it</A> is version 7.4 and patch 248 was included.  Example:
<B>	:if has("patch-7.4.248")</B>
     Note that it's possible for patch 248 to be omitted even though 249 is
    included.  Only happens when cherry-picking patches.
    Note that this form only works for patch 7.4.237 and later, before that
    you need to check for the patch and the  <A HREF="eval.html#v:version">v:version</A>.  Example (checking
    version 6.2.148 or later):
<B>	:if v:version &gt; 602 || (v:version == 602 &amp;&amp; has("patch148"))</B>

Hint: To find out if Vim supports backslashes in a file name (MS-Windows),
use: `if exists('+shellslash')`


acl			Compiled with |<A HREF="editing.html#ACL">ACL</A>| support.
all_builtin_terms	Compiled with all builtin terminals enabled.
amiga			<A HREF="os_amiga.html#Amiga">Amiga</A> version of Vim.
arabic			Compiled with Arabic support |<A HREF="arabic.html#Arabic">Arabic</A>|.
arp			Compiled with ARP support (Amiga).
autocmd			Compiled with <A HREF="autocmd.html#autocommand">autocommand</A> support. (always <A HREF="vim9.html#true">true</A>)
autochdir		Compiled with support for <A HREF="options.html#'autochdir'">'autochdir'</A>
autoservername		Automatically enable |<A HREF="remote.html#clientserver">clientserver</A>|
balloon_eval		Compiled with |<A HREF="debugger.html#balloon-eval">balloon-eval</A>| support.
balloon_multiline	<A HREF="gui.html#GUI">GUI</A> supports multiline balloons.
<A HREF="os_beos.html#beos">beos</A>			<A HREF="os_beos.html#BeOS">BeOS</A> version of Vim.
browse			Compiled with |<A HREF="editing.html#:browse">:browse</A>| support, and <A HREF="#browse()">browse()</A> will
			work.
browsefilter		Compiled with support for |<A HREF="editing.html#browsefilter">browsefilter</A>|.
bsd			Compiled on an OS in the BSD family (excluding macOS).
<A HREF="term.html#builtin_terms">builtin_terms</A>		Compiled with some builtin terminals.
byte_offset		Compiled with support for '<A HREF="insert.html#o">o</A>' in <A HREF="options.html#'statusline'">'statusline'</A>
channel			Compiled with support for |<A HREF="channel.html#channel">channel</A>| and |<A HREF="channel.html#job">job</A>|
cindent			Compiled with <A HREF="options.html#'cindent'">'cindent'</A> support. (always <A HREF="vim9.html#true">true</A>)
clientserver		Compiled with remote invocation support |<A HREF="remote.html#clientserver">clientserver</A>|.
<A HREF="gui.html#clipboard">clipboard</A>		Compiled with <A HREF="options.html#'clipboard'">'clipboard'</A> support.
clipboard_working	Compiled with <A HREF="options.html#'clipboard'">'clipboard'</A> support and <A HREF="motion.html#it">it</A> can be used.
cmdline_compl		Compiled with |<A HREF="cmdline.html#cmdline-completion">cmdline-completion</A>| support.
cmdline_hist		Compiled with |<A HREF="cmdline.html#cmdline-history">cmdline-history</A>| support.
cmdline_info		Compiled with <A HREF="options.html#'showcmd'">'showcmd'</A> and <A HREF="options.html#'ruler'">'ruler'</A> support.
comments		Compiled with |<A HREF="options.html#'comments'">'comments'</A>| support.
compatible		Compiled to be very <A HREF="intro.html#Vi">Vi</A> compatible.
conpty			Platform where |<A HREF="terminal.html#ConPTY">ConPTY</A>| can be used.
cryptv			Compiled with encryption support |<A HREF="editing.html#encryption">encryption</A>|.
cscope			Compiled with |<A HREF="if_cscop.html#cscope">cscope</A>| support.
cursorbind		Compiled with |<A HREF="options.html#'cursorbind'">'cursorbind'</A>| (always <A HREF="vim9.html#true">true</A>)
debug			Compiled with &quot;DEBUG&quot; defined.
dialog_con		Compiled with console <A HREF="gui_w32.html#dialog">dialog</A> support.
dialog_gui		Compiled with <A HREF="gui.html#GUI">GUI</A> <A HREF="gui_w32.html#dialog">dialog</A> support.
diff			Compiled with |<A HREF="diff.html#vimdiff">vimdiff</A>| and <A HREF="options.html#'diff'">'diff'</A> support.
<A HREF="digraph.html#digraphs">digraphs</A>		Compiled with support for <A HREF="digraph.html#digraphs">digraphs</A>.
directx			Compiled with support for DirectX and <A HREF="options.html#'renderoptions'">'renderoptions'</A>.
dnd			Compiled with support for the &quot;~ <A HREF="sponsor.html#register">register</A> |<A HREF="change.html#quote_~">quote_~</A>|.
drop_file		Compiled with |<A HREF="gui.html#drop_file">drop_file</A>| support.
ebcdic			Compiled on a machine with ebcdic character set.
<A HREF="tagsrch.html#emacs_tags">emacs_tags</A>		Compiled with support for Emacs <A HREF="tagsrch.html#tags">tags</A>.
<A HREF="eval.html#eval">eval</A>			Compiled with <A HREF="eval.html#expression">expression</A> evaluation support.  Always
			<A HREF="vim9.html#true">true</A>, of course!
ex_extra		|<A HREF="various.html#+ex_extra">+ex_extra</A>| (always <A HREF="vim9.html#true">true</A>)
extra_search		Compiled with support for |<A HREF="options.html#'incsearch'">'incsearch'</A>| and
			|<A HREF="options.html#'hlsearch'">'hlsearch'</A>|
farsi			Support for <A HREF="farsi.html#Farsi">Farsi</A> was removed |<A HREF="farsi.html#farsi">farsi</A>|.
file_in_path		Compiled with support for |<A HREF="editing.html#gf">gf</A>| and |<A HREF="cmdline.html#&lt;cfile&gt;">&lt;cfile&gt;</A>|
filterpipe		When <A HREF="options.html#'shelltemp'">'shelltemp'</A> is off pipes are used for shell
			read/write/filter commands
find_in_path		Compiled with support for include file searches
			|<A HREF="various.html#+find_in_path">+find_in_path</A>|.
float			Compiled with support for |<A HREF="eval.html#Float">Float</A>|.
fname_case		Case in file names matters (for <A HREF="os_amiga.html#Amiga">Amiga</A> and <A HREF="os_win32.html#MS-Windows">MS-Windows</A>
			this is not present).
folding			Compiled with |<A HREF="fold.html#folding">folding</A>| support.
footer			Compiled with <A HREF="gui.html#GUI">GUI</A> footer support. |<A HREF="debugger.html#gui-footer">gui-footer</A>|
<A HREF="os_unix.html#fork">fork</A>			Compiled to use fork()/exec() instead of <A HREF="#system()">system()</A>.
gettext			Compiled with message translation |<A HREF="mlang.html#multi-lang">multi-lang</A>|
<A HREF="gui.html#gui">gui</A>			Compiled with <A HREF="gui.html#GUI">GUI</A> enabled.
gui_athena		Compiled with Athena <A HREF="gui.html#GUI">GUI</A> (always <A HREF="vim9.html#false">false</A>).
gui_gnome		Compiled with <A HREF="gui_x11.html#Gnome">Gnome</A> support (gui_gtk is also defined).
gui_gtk			Compiled with <A HREF="gui_x11.html#GTK+">GTK+</A> <A HREF="gui.html#GUI">GUI</A> (any version).
gui_gtk2		Compiled with <A HREF="gui_x11.html#GTK+">GTK+</A> 2 <A HREF="gui.html#GUI">GUI</A> (gui_gtk is also defined).
gui_gtk3		Compiled with <A HREF="gui_x11.html#GTK+">GTK+</A> 3 <A HREF="gui.html#GUI">GUI</A> (gui_gtk is also defined).
gui_haiku		Compiled with <A HREF="os_haiku.html#Haiku">Haiku</A> <A HREF="gui.html#GUI">GUI</A>.
gui_mac			Compiled with <A HREF="os_mac.html#Macintosh">Macintosh</A> <A HREF="gui.html#GUI">GUI</A>.
gui_motif		Compiled with <A HREF="gui_x11.html#Motif">Motif</A> <A HREF="gui.html#GUI">GUI</A>.
gui_photon		Compiled with Photon <A HREF="gui.html#GUI">GUI</A>.
<A HREF="#gui_running">gui_running</A>		Vim is running in the <A HREF="gui.html#GUI">GUI</A>, or <A HREF="motion.html#it">it</A> will start soon.
gui_win32		Compiled with <A HREF="os_win32.html#MS-Windows">MS-Windows</A> <A HREF="os_win32.html#Win32">Win32</A> <A HREF="gui.html#GUI">GUI</A>.
gui_win32s		idem, and Win32s system being used (Windows 3.1)
haiku			<A HREF="os_haiku.html#Haiku">Haiku</A> version of Vim.
hangul_input		Compiled with Hangul input support. |<A HREF="hangulin.html#hangul">hangul</A>|
hpux			HP-UX version of Vim.
iconv			Can use <A HREF="#iconv()">iconv()</A> for conversion.
<A HREF="insert.html#insert_expand">insert_expand</A>		Compiled with support for <A HREF="change.html#CTRL-X">CTRL-X</A> expansion commands in
			<A HREF="insert.html#Insert">Insert</A> mode. (always <A HREF="vim9.html#true">true</A>)
job			Compiled with support for |<A HREF="channel.html#channel">channel</A>| and |<A HREF="channel.html#job">job</A>|
ipv6			Compiled with support for IPv6 networking in |<A HREF="channel.html#channel">channel</A>|.
jumplist		Compiled with |<A HREF="motion.html#jumplist">jumplist</A>| support. (always <A HREF="vim9.html#true">true</A>)
keymap			Compiled with <A HREF="options.html#'keymap'">'keymap'</A> support.
lambda			Compiled with |<A HREF="eval.html#lambda">lambda</A>| support.
langmap			Compiled with <A HREF="options.html#'langmap'">'langmap'</A> support.
libcall			Compiled with |<A HREF="#libcall()">libcall()</A>| support.
linebreak		Compiled with <A HREF="options.html#'linebreak'">'linebreak'</A>, <A HREF="options.html#'breakat'">'breakat'</A>, <A HREF="options.html#'showbreak'">'showbreak'</A> and
			<A HREF="options.html#'breakindent'">'breakindent'</A> support.
linux			Linux version of Vim.
lispindent		Compiled with support for lisp indenting.
			(always <A HREF="vim9.html#true">true</A>)
listcmds		Compiled with commands for the buffer <A HREF="eval.html#list">list</A> |<A HREF="windows.html#:files">:files</A>|
			and the argument list |<A HREF="editing.html#arglist">arglist</A>|.
localmap		Compiled with local mappings and abbr. |<A HREF="map.html#:map-local">:map-local</A>|
<A HREF="if_lua.html#lua">lua</A>			Compiled with Lua interface |<A HREF="if_lua.html#Lua">Lua</A>|.
<A HREF="os_mac.html#mac">mac</A>			Any <A HREF="os_mac.html#Macintosh">Macintosh</A> version of Vim  cf. osx
macunix			Synonym for osxdarwin
menu			Compiled with support for |<A HREF="gui.html#:menu">:menu</A>|.
mksession		Compiled with support for |<A HREF="starting.html#:mksession">:mksession</A>|.
modify_fname		Compiled with file name modifiers. |<A HREF="cmdline.html#filename-modifiers">filename-modifiers</A>|
			(always <A HREF="vim9.html#true">true</A>)
mouse			Compiled with support for mouse.
mouse_dec		Compiled with support for Dec <A HREF="terminal.html#terminal">terminal</A> mouse.
mouse_gpm		Compiled with support for gpm (Linux console mouse)
mouse_gpm_enabled	GPM mouse is working
mouse_netterm		Compiled with support for netterm mouse.
mouse_pterm		Compiled with support for <A HREF="os_qnx.html#qnx">qnx</A> pterm mouse.
mouse_sysmouse		Compiled with support for <A HREF="term.html#sysmouse">sysmouse</A> (*BSD console mouse)
mouse_sgr		Compiled with support for sgr mouse.
mouse_urxvt		Compiled with support for urxvt mouse.
mouse_xterm		Compiled with support for xterm mouse.
mouseshape		Compiled with support for <A HREF="options.html#'mouseshape'">'mouseshape'</A>.
multi_byte		Compiled with support for <A HREF="options.html#'encoding'">'encoding'</A> (always <A HREF="vim9.html#true">true</A>)
multi_byte_encoding	<A HREF="options.html#'encoding'">'encoding'</A> is set to a <A HREF="mbyte.html#multibyte">multibyte</A> encoding.
multi_byte_ime		Compiled with support for <A HREF="mbyte.html#IME">IME</A> input <A HREF="eval.html#method">method</A>.
multi_lang		Compiled with support for multiple languages.
mzscheme		Compiled with <A HREF="if_mzsch.html#MzScheme">MzScheme</A> interface |<A HREF="if_mzsch.html#mzscheme">mzscheme</A>|.
nanotime		Compiled with sub-second time stamp checks.
netbeans_enabled	Compiled with support for |<A HREF="netbeans.html#netbeans">netbeans</A>| and connected.
netbeans_intg		Compiled with support for |<A HREF="netbeans.html#netbeans">netbeans</A>|.
num64			Compiled with 64-bit |<A HREF="eval.html#Number">Number</A>| support. (always <A HREF="vim9.html#true">true</A>)
ole			Compiled with OLE automation support for <A HREF="os_win32.html#Win32">Win32</A>.
osx			Compiled for macOS  cf. <A HREF="os_mac.html#mac">mac</A>
osxdarwin		Compiled for macOS, with |<A HREF="os_mac.html#mac-darwin-feature">mac-darwin-feature</A>|
packages		Compiled with |<A HREF="repeat.html#packages">packages</A>| support.
path_extra		Compiled with up/downwards search in <A HREF="options.html#'path'">'path'</A> and <A HREF="options.html#'tags'">'tags'</A>
<A HREF="if_perl.html#perl">perl</A>			Compiled with <A HREF="if_perl.html#Perl">Perl</A> interface.
persistent_undo		Compiled with support for persistent <A HREF="undo.html#undo">undo</A> <A HREF="cmdline.html#history">history</A>.
postscript		Compiled with PostScript file <A HREF="print.html#printing">printing</A>.
printer			Compiled with |<A HREF="print.html#:hardcopy">:hardcopy</A>| support.
profile			Compiled with |<A HREF="repeat.html#:profile">:profile</A>| support.
python			<A HREF="if_pyth.html#Python">Python</A> 2.x interface available. |<A HREF="if_pyth.html#has-python">has-python</A>|
python_compiled		Compiled with <A HREF="if_pyth.html#Python">Python</A> 2.x interface. |<A HREF="if_pyth.html#has-python">has-python</A>|
python_dynamic		<A HREF="if_pyth.html#Python">Python</A> 2.x interface is dynamically loaded. |<A HREF="if_pyth.html#has-python">has-python</A>|
<A HREF="if_pyth.html#python3">python3</A>			<A HREF="if_pyth.html#Python">Python</A> 3.x interface available. |<A HREF="if_pyth.html#has-python">has-python</A>|
python3_compiled	Compiled with <A HREF="if_pyth.html#Python">Python</A> 3.x interface. |<A HREF="if_pyth.html#has-python">has-python</A>|
python3_dynamic		<A HREF="if_pyth.html#Python">Python</A> 3.x interface is dynamically loaded. |<A HREF="if_pyth.html#has-python">has-python</A>|
<A HREF="if_pyth.html#pythonx">pythonx</A>			<A HREF="if_pyth.html#Python">Python</A> 2.x and/or 3.x interface available. |<A HREF="if_pyth.html#python_x">python_x</A>|
<A HREF="os_qnx.html#qnx">qnx</A>			<A HREF="os_qnx.html#QNX">QNX</A> version of Vim.
quickfix		Compiled with |<A HREF="quickfix.html#quickfix">quickfix</A>| support.
reltime			Compiled with |<A HREF="#reltime()">reltime()</A>| support.
rightleft		Compiled with <A HREF="options.html#'rightleft'">'rightleft'</A> support.
ruby			Compiled with <A HREF="if_ruby.html#Ruby">Ruby</A> interface |<A HREF="if_ruby.html#ruby">ruby</A>|.
scrollbind		Compiled with <A HREF="options.html#'scrollbind'">'scrollbind'</A> support. (always <A HREF="vim9.html#true">true</A>)
showcmd			Compiled with <A HREF="options.html#'showcmd'">'showcmd'</A> support.
<A HREF="sign.html#signs">signs</A>			Compiled with |<A HREF="sign.html#:sign">:sign</A>| support.
smartindent		Compiled with <A HREF="options.html#'smartindent'">'smartindent'</A> support. (always <A HREF="vim9.html#true">true</A>)
sodium			Compiled with libsodium for better crypt support
sound			Compiled with sound support, e.g. `sound_playevent()`
spell			Compiled with spell checking support |<A HREF="spell.html#spell">spell</A>|.
startuptime		Compiled with |<A HREF="starting.html#--startuptime">--startuptime</A>| support.
statusline		Compiled with support for <A HREF="options.html#'statusline'">'statusline'</A>, <A HREF="options.html#'rulerformat'">'rulerformat'</A>
			and special formats of <A HREF="options.html#'titlestring'">'titlestring'</A> and <A HREF="options.html#'iconstring'">'iconstring'</A>.
sun			SunOS version of Vim.
sun_workshop		Support for Sun |<A HREF="workshop.html#workshop">workshop</A>| has been removed.
syntax			Compiled with syntax highlighting support |<A HREF="syntax.html#syntax">syntax</A>|.
syntax_items		There are active <A HREF="syntax.html#syntax">syntax</A> highlighting items for the
			current buffer.
system			Compiled to use <A HREF="#system()">system()</A> instead of fork()/exec().
tag_binary		Compiled with binary searching in <A HREF="tagsrch.html#tags">tags</A> files
			|<A HREF="tagsrch.html#tag-binary-search">tag-binary-search</A>|. (always <A HREF="vim9.html#true">true</A>)
tag_old_static		Support for old static <A HREF="tagsrch.html#tags">tags</A> was removed, see
			|<A HREF="tagsrch.html#tag-old-static">tag-old-static</A>|.
<A HREF="if_tcl.html#tcl">tcl</A>			Compiled with <A HREF="if_tcl.html#Tcl">Tcl</A> interface.
termguicolors		Compiled with <A HREF="vim9.html#true">true</A> color in <A HREF="terminal.html#terminal">terminal</A> support.
terminal		Compiled with |<A HREF="terminal.html#terminal">terminal</A>| support.
<A HREF="term.html#terminfo">terminfo</A>		Compiled with <A HREF="term.html#terminfo">terminfo</A> instead of <A HREF="term.html#termcap">termcap</A>.
termresponse		Compiled with support for |<A HREF="term.html#t_RV">t_RV</A>| and |<A HREF="eval.html#v:termresponse">v:termresponse</A>|.
textobjects		Compiled with support for |<A HREF="motion.html#text-objects">text-objects</A>|.
<A HREF="textprop.html#textprop">textprop</A>		Compiled with support for |<A HREF="textprop.html#text-properties">text-properties</A>|.
tgetent			Compiled with tgetent support, able to use a <A HREF="term.html#termcap">termcap</A>
			or <A HREF="term.html#terminfo">terminfo</A> file.
<A HREF="#timers">timers</A>			Compiled with |<A HREF="#timer_start()">timer_start()</A>| support.
title			Compiled with <A HREF="windows.html#window">window</A> title support |<A HREF="options.html#'title'">'title'</A>|.
			(always <A HREF="vim9.html#true">true</A>)
toolbar			Compiled with support for |<A HREF="gui.html#gui-toolbar">gui-toolbar</A>|.
ttyin			input is a <A HREF="terminal.html#terminal">terminal</A> (tty)
ttyout			output is a <A HREF="terminal.html#terminal">terminal</A> (tty)

<A HREF="os_unix.html#unix">unix</A>			<A HREF="os_unix.html#Unix">Unix</A> version of Vim. *<A NAME="+unix"></A><B>+unix</B>*
unnamedplus		Compiled with support for &quot;unnamedplus&quot; in <A HREF="options.html#'clipboard'">'clipboard'</A>
user_commands		User-defined commands. (always <A HREF="vim9.html#true">true</A>)
vartabs			Compiled with variable tabstop support |<A HREF="options.html#'vartabstop'">'vartabstop'</A>|.
vcon			<A HREF="os_win32.html#Win32">Win32</A>: Virtual console support is working, can use
			<A HREF="options.html#'termguicolors'">'termguicolors'</A>. Also see |<A HREF="various.html#+vtp">+vtp</A>|.
vertsplit		Compiled with vertically split <A HREF="windows.html#windows">windows</A> |<A HREF="windows.html#:vsplit">:vsplit</A>|.
			(always <A HREF="vim9.html#true">true</A>)
<A HREF="#vim_starting">vim_starting</A>		True while initial source'ing takes place. |<A HREF="starting.html#startup">startup</A>|

			*<A NAME="vim_starting"></A><B>vim_starting</B>*
<A HREF="vim9.html#vim9script">vim9script</A>		Compiled with |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> support
<A HREF="starting.html#viminfo">viminfo</A>			Compiled with <A HREF="starting.html#viminfo">viminfo</A> support.
vimscript-1		Compiled Vim <A HREF="usr_41.html#script">script</A> version 1 support
vimscript-2		Compiled Vim <A HREF="usr_41.html#script">script</A> version 2 support
vimscript-3		Compiled Vim <A HREF="usr_41.html#script">script</A> version 3 support
vimscript-4		Compiled Vim <A HREF="usr_41.html#script">script</A> version 4 support
virtualedit		Compiled with <A HREF="options.html#'virtualedit'">'virtualedit'</A> option. (always <A HREF="vim9.html#true">true</A>)
visual			Compiled with <A HREF="visual.html#Visual">Visual</A> mode. (always <A HREF="vim9.html#true">true</A>)
visualextra		Compiled with extra <A HREF="visual.html#Visual">Visual</A> mode commands. (always
			<A HREF="vim9.html#true">true</A>) |<A HREF="visual.html#blockwise-operators">blockwise-operators</A>|.
<A HREF="os_vms.html#vms">vms</A>			<A HREF="os_vms.html#VMS">VMS</A> version of Vim.
vreplace		Compiled with |<A HREF="change.html#gR">gR</A>| and |<A HREF="change.html#gr">gr</A>| commands. (always <A HREF="vim9.html#true">true</A>)
vtp			Compiled for vcon support |<A HREF="various.html#+vtp">+vtp</A>| (check vcon to find
			out if <A HREF="motion.html#it">it</A> works in the current console).
wildignore		Compiled with <A HREF="options.html#'wildignore'">'wildignore'</A> option.
wildmenu		Compiled with <A HREF="options.html#'wildmenu'">'wildmenu'</A> option.
<A HREF="os_win32.html#win16">win16</A>			old version for <A HREF="os_win32.html#MS-Windows">MS-Windows</A> 3.1 (always <A HREF="vim9.html#false">false</A>)
<A HREF="os_win32.html#win32">win32</A>			<A HREF="os_win32.html#Win32">Win32</A> version of Vim (MS-Windows 95 and later, 32 or
			64 bits)
win32unix		<A HREF="os_win32.html#Win32">Win32</A> version of Vim, using <A HREF="os_unix.html#Unix">Unix</A> files (Cygwin)
win64			Win64 version of Vim (MS-Windows 64 bit).
win95			<A HREF="os_win32.html#Win32">Win32</A> version for <A HREF="os_win32.html#MS-Windows">MS-Windows</A> 95/98/ME (always <A HREF="vim9.html#false">false</A>)
winaltkeys		Compiled with <A HREF="options.html#'winaltkeys'">'winaltkeys'</A> option.
<A HREF="windows.html#windows">windows</A>			Compiled with support for more than one <A HREF="windows.html#window">window</A>.
			(always <A HREF="vim9.html#true">true</A>)
writebackup		Compiled with <A HREF="options.html#'writebackup'">'writebackup'</A> default on.
xfontset		Compiled with X fontset support |<A HREF="mbyte.html#xfontset">xfontset</A>|.
xim			Compiled with X input <A HREF="eval.html#method">method</A> support |<A HREF="mbyte.html#xim">xim</A>|.
xpm			Compiled with pixmap support.
xpm_w32			Compiled with pixmap support for <A HREF="os_win32.html#Win32">Win32</A>. (Only for
			backward compatibility. Use &quot;xpm&quot; instead.)
xsmp			Compiled with X session management support.
xsmp_interact		Compiled with interactive X session management support.
xterm_clipboard		Compiled with support for xterm <A HREF="gui.html#clipboard">clipboard</A>.
xterm_save		Compiled with support for saving and restoring the
			xterm screen.
x11			Compiled with <A HREF="options.html#X11">X11</A> support.


==============================================================================

4. Matching a <A HREF="pattern.html#pattern">pattern</A> in a <A HREF="eval.html#String">String</A>			*<A NAME="string-match"></A><B>string-match</B>*

This is common between several <A HREF="eval.html#functions">functions</A>.  A <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A> <A HREF="motion.html#as">as</A> explained at
|<A HREF="pattern.html#pattern">pattern</A>| is normally used to find a match in the buffer lines.  When a
<A HREF="pattern.html#pattern">pattern</A> is used to find a match in a <A HREF="eval.html#String">String</A>, almost everything works in the
same way.  The difference is that a <A HREF="eval.html#String">String</A> is handled like <A HREF="motion.html#it">it</A> is one line.
When <A HREF="motion.html#it">it</A> contains a &quot;\n&quot; character, this is not seen <A HREF="motion.html#as">as</A> a line break for the
<A HREF="pattern.html#pattern">pattern</A>.  It can be matched with a &quot;\n&quot; in the <A HREF="pattern.html#pattern">pattern</A>, or with &quot;<A HREF="repeat.html#.">.</A>&quot;.  Example:

<B>	:let a = "aaaa\nxxxx"</B>
<B>	:echo matchstr(a, "..\n..")</B>
<B>	aa</B>
<B>	xx</B>
<B>	:echo matchstr(a, "a.x")</B>
<B>	a</B>
<B>	x</B>

Don't forget that &quot;<A HREF="motion.html#^">^</A>&quot; will only match at the first character of the <A HREF="eval.html#String">String</A> and
&quot;<A HREF="motion.html#$">$</A>&quot; at the last character of the <A HREF="eval.html#string">string</A>.  They don't match after or before a
&quot;\n&quot;.

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
