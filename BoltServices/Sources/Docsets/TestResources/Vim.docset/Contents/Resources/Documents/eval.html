<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Vim documentation: eval</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Vim documentation: eval</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="eval.txt"></A><B>eval.txt</B>*	For Vim version 9.0.  Last change: 2022 Jun 17


		  VIM REFERENCE MANUAL	  by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>



Expression evaluation			*<A NAME="expression"></A><B>expression</B>* *<A NAME="expr"></A><B>expr</B>* *<A NAME="E15"></A><B>E15</B>* *<A NAME="eval"></A><B>eval</B>*

							*<A NAME="E1002"></A><B>E1002</B>*
Using expressions is introduced in chapter 41 of the user manual |<A HREF="usr_41.html">usr_41.txt</A>|.

Note: Expression evaluation can be disabled at compile time.  If this has been
done, the features in this document are not available.  See |<A HREF="various.html#+eval">+eval</A>| and
|<A HREF="#no-eval-feature">no-eval-feature</A>|.

This file is mainly about the backwards compatible (legacy) Vim <A HREF="usr_41.html#script">script</A>.  For
specifics of <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A>, which can execute much faster, supports type
checking and much more, see |<A HREF="vim9.html">vim9.txt</A>|.  Where the <A HREF="syntax.html#syntax">syntax</A> or semantics differ
a remark is given.

1.  Variables			|<A HREF="#variables">variables</A>|
    1.1 Variable types
    1.2 Function references		|<A HREF="#Funcref">Funcref</A>|
    1.3 Lists				|<A HREF="#Lists">Lists</A>|
    1.4 Dictionaries			|<A HREF="#Dictionaries">Dictionaries</A>|
    1.5 Blobs				|<A HREF="#Blobs">Blobs</A>|
    1.6 More about variables		|<A HREF="#more-variables">more-variables</A>|
2.  Expression syntax		|<A HREF="#expression-syntax">expression-syntax</A>|
3.  Internal variable		|<A HREF="#internal-variables">internal-variables</A>|
4.  Builtin Functions		|<A HREF="#functions">functions</A>|
5.  Defining functions		|<A HREF="#user-functions">user-functions</A>|
6.  Curly braces names		|<A HREF="#curly-braces-names">curly-braces-names</A>|
7.  Commands			|<A HREF="#expression-commands">expression-commands</A>|
8.  Exception handling		|<A HREF="#exception-handling">exception-handling</A>|
9.  Examples			|<A HREF="#eval-examples">eval-examples</A>|
10. Vim script version		|<A HREF="#vimscript-version">vimscript-version</A>|
11. No <A HREF="various.html#+eval">+eval</A> feature		|<A HREF="#no-eval-feature">no-eval-feature</A>|
12. The sandbox			|<A HREF="#eval-sandbox">eval-sandbox</A>|
13. Textlock			|<A HREF="#textlock">textlock</A>|

Testing support is documented in |<A HREF="testing.html">testing.txt</A>|.
Profiling is documented at |<A HREF="repeat.html#profiling">profiling</A>|.

==============================================================================

1. Variables						*<A NAME="variables"></A><B>variables</B>*

<B><FONT COLOR="PURPLE">1.1 Variable types </FONT></B>

					*<A NAME="E712"></A><B>E712</B>* *<A NAME="E896"></A><B>E896</B>* *<A NAME="E897"></A><B>E897</B>* *<A NAME="E899"></A><B>E899</B>* *<A NAME="E1098"></A><B>E1098</B>*

					*<A NAME="E1107"></A><B>E1107</B>* *<A NAME="E1135"></A><B>E1135</B>* *<A NAME="E1138"></A><B>E1138</B>*
There are ten types of <A HREF="#variables">variables</A>:


							*<A NAME="Number"></A><B>Number</B>* *<A NAME="Integer"></A><B>Integer</B>*
<A HREF="#Number">Number</A>		A 32 or 64 bit signed number.  |<A HREF="#expr-number">expr-number</A>|
		The number of bits is available in |<A HREF="#v:numbersize">v:numbersize</A>|.
		Examples:  -123  0x10  0177  0o177 0b1011


<A HREF="#Float">Float</A>		A floating point number. |<A HREF="#floating-point-format">floating-point-format</A>| *<A NAME="Float"></A><B>Float</B>*

		{only when compiled with the |<A HREF="various.html#+float">+float</A>| feature} *<A NAME="E1076"></A><B>E1076</B>*
		Examples: 123.456  1.15e-6  -1.1e3

<A HREF="#String">String</A>		A NUL terminated <A HREF="#string">string</A> of 8-bit unsigned characters (bytes).
		|<A HREF="#expr-string">expr-string</A>| Examples: &quot;ab\txx\&quot;--&quot;  'x-z''a,c'

List		An ordered sequence of items, see |<A HREF="#List">List</A>| for details.
		Example: [1, 2, ['a', 'b']]

<A HREF="#Dictionary">Dictionary</A>	An associative, unordered array: Each entry has a key and a
		value. |<A HREF="#Dictionary">Dictionary</A>|
		Examples:
			{'blue': &quot;#0000ff&quot;, 'red': &quot;#ff0000&quot;}
			#{blue: &quot;#0000ff&quot;, red: &quot;#ff0000&quot;}

Funcref		A reference to a function |<A HREF="#Funcref">Funcref</A>|.
		Example: function(&quot;strlen&quot;)
		It can be bound to a dictionary and arguments, <A HREF="motion.html#it">it</A> then works
		like a <A HREF="#Partial">Partial</A>.
		Example: function(&quot;Callback&quot;, [arg], myDict)


<A HREF="#Special">Special</A>		|<A HREF="#v:false">v:false</A>|, |<A HREF="#v:true">v:true</A>|, |<A HREF="#v:none">v:none</A>| and |<A HREF="#v:null">v:null</A>|.  *<A NAME="Special"></A><B>Special</B>*


<A HREF="#Job">Job</A>		Used for a job, see |<A HREF="channel.html#job_start()">job_start()</A>|. *<A NAME="Job"></A><B>Job</B>* *<A NAME="Jobs"></A><B>Jobs</B>*


<A HREF="#Channel">Channel</A>		Used for a <A HREF="channel.html#channel">channel</A>, see |<A HREF="channel.html#ch_open()">ch_open()</A>|. *<A NAME="Channel"></A><B>Channel</B>* *<A NAME="Channels"></A><B>Channels</B>*

Blob		Binary Large Object. Stores any sequence of bytes.  See |<A HREF="#Blob">Blob</A>|
		for details
		Example: 0zFF00ED015DAF
		0z is an empty <A HREF="#Blob">Blob</A>.

The <A HREF="#Number">Number</A> and <A HREF="#String">String</A> types are converted automatically, depending on how they
are used.

Conversion from a <A HREF="#Number">Number</A> to a <A HREF="#String">String</A> is by making the ASCII representation of
the <A HREF="#Number">Number</A>.  Examples:
<B><FONT COLOR="PURPLE">	Number 123	--&gt;	String "123" </FONT></B>
<B><FONT COLOR="PURPLE">	Number 0	--&gt;	String "0" </FONT></B>
<B><FONT COLOR="PURPLE">	Number -1	--&gt;	String "-1" </FONT></B>

							*<A NAME="octal"></A><B>octal</B>*
Conversion from a <A HREF="#String">String</A> to a <A HREF="#Number">Number</A> only happens in legacy Vim <A HREF="usr_41.html#script">script</A>, not in
<A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A>.  It is done by converting the first digits to a number.
Hexadecimal &quot;0xf9&quot;, Octal &quot;017&quot; or &quot;0o17&quot;, and Binary &quot;0b10&quot;
numbers are recognized
NOTE: when using |<A HREF="vim9.html#Vim9">Vim9</A>| script or |<A HREF="#scriptversion-4">scriptversion-4</A>| <A HREF="#octal">octal</A> with a leading &quot;<A HREF="motion.html#0">0</A>&quot;
is not recognized.  The <A HREF="#0o">0o</A> <A HREF="intro.html#notation">notation</A> requires patch 8.2.0886.
If the <A HREF="#String">String</A> doesn't start with digits, the result is zero.
Examples:
<B><FONT COLOR="PURPLE">	String "456"	--&gt;	Number 456 </FONT></B>
<B><FONT COLOR="PURPLE">	String "6bar"	--&gt;	Number 6 </FONT></B>
<B><FONT COLOR="PURPLE">	String "foo"	--&gt;	Number 0 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0xf1"	--&gt;	Number 241 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0100"	--&gt;	Number 64 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0o100"	--&gt;	Number 64 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0b101"	--&gt;	Number 5 </FONT></B>
<B><FONT COLOR="PURPLE">	String "-8"	--&gt;	Number -8 </FONT></B>
<B><FONT COLOR="PURPLE">	String "+8"	--&gt;	Number 0 </FONT></B>

To force conversion from <A HREF="#String">String</A> to <A HREF="#Number">Number</A>, add zero to <A HREF="motion.html#it">it</A>:
<B>	:echo "0100" + 0</B>
<B><FONT COLOR="PURPLE"> 	64 </FONT></B>

To avoid a leading zero to cause <A HREF="#octal">octal</A> conversion, or for using a different
base, use |<A HREF="builtin.html#str2nr()">str2nr()</A>|.


						*<A NAME="TRUE"></A><B>TRUE</B>* *<A NAME="FALSE"></A><B>FALSE</B>* *<A NAME="Boolean"></A><B>Boolean</B>*
For <A HREF="options.html#boolean">boolean</A> operators Numbers are used.  Zero is <A HREF="#FALSE">FALSE</A>, non-zero is <A HREF="#TRUE">TRUE</A>.
You can also use |<A HREF="#v:false">v:false</A>| and |<A HREF="#v:true">v:true</A>|, in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> |<A HREF="vim9.html#false">false</A>| and |<A HREF="vim9.html#true">true</A>|.
When <A HREF="#TRUE">TRUE</A> is returned from a function <A HREF="motion.html#it">it</A> is the <A HREF="#Number">Number</A> one, <A HREF="#FALSE">FALSE</A> is the
number zero.

Note that in the command:
<B>	:if "foo"</B>
<B>	:" NOT executed</B>
&quot;foo&quot; is converted to 0, which means <A HREF="#FALSE">FALSE</A>.  If the <A HREF="#string">string</A> starts with a
non-zero number <A HREF="motion.html#it">it</A> means <A HREF="#TRUE">TRUE</A>:
<B>	:if "8foo"</B>
<B>	:" executed</B>
To test for a non-empty <A HREF="#string">string</A>, use <A HREF="builtin.html#empty()">empty()</A>:
<B>	:if !empty("foo")</B>


 						*<A NAME="falsy"></A><B>falsy</B>* *<A NAME="truthy"></A><B>truthy</B>*
An <A HREF="#expression">expression</A> can be used <A HREF="motion.html#as">as</A> a condition, ignoring the type and only using
whether the value is &quot;sort of true&quot; or &quot;sort of false&quot;.  Falsy is:
	the number zero
	empty <A HREF="#string">string</A>, <A HREF="#blob">blob</A>, <A HREF="#list">list</A> or dictionary
Other values are <A HREF="#truthy">truthy</A>.  Examples:
	0	<A HREF="#falsy">falsy</A>
	1	<A HREF="#truthy">truthy</A>
	-1	<A HREF="#truthy">truthy</A>
	0.0	<A HREF="#falsy">falsy</A>
	0.1	<A HREF="#truthy">truthy</A>
	<A HREF="motion.html#''">''</A>	<A HREF="#falsy">falsy</A>
	'<A HREF="change.html#x">x</A>'	<A HREF="#truthy">truthy</A>
	<A HREF="motion.html#[]">[]</A>	<A HREF="#falsy">falsy</A>
	[0]	<A HREF="#truthy">truthy</A>
	<A HREF="intro.html#{}">{}</A>	<A HREF="#falsy">falsy</A>
	#{x: 1} <A HREF="#truthy">truthy</A>
	0z	<A HREF="#falsy">falsy</A>
	0z00	<A HREF="#truthy">truthy</A>


							*<A NAME="non-zero-arg"></A><B>non-zero-arg</B>*
Function arguments often behave slightly different from |TRUE|: If the
argument is present and <A HREF="motion.html#it">it</A> evaluates to a non-zero <A HREF="#Number">Number</A>, |<A HREF="#v:true">v:true</A>| or a
non-empty <A HREF="#String">String</A>, then the value is considered to be <A HREF="#TRUE">TRUE</A>.
Note that &quot; &quot; and &quot;<A HREF="motion.html#0">0</A>&quot; are also non-empty strings, thus considered to be <A HREF="#TRUE">TRUE</A>.
A <A HREF="#List">List</A>, <A HREF="#Dictionary">Dictionary</A> or <A HREF="#Float">Float</A> is not a <A HREF="#Number">Number</A> or <A HREF="#String">String</A>, thus evaluate to <A HREF="#FALSE">FALSE</A>.


		*<A NAME="E611"></A><B>E611</B>* *<A NAME="E745"></A><B>E745</B>* *<A NAME="E728"></A><B>E728</B>* *<A NAME="E703"></A><B>E703</B>* *<A NAME="E729"></A><B>E729</B>* *<A NAME="E730"></A><B>E730</B>* *<A NAME="E731"></A><B>E731</B>* *<A NAME="E908"></A><B>E908</B>* *<A NAME="E910"></A><B>E910</B>*

		*<A NAME="E913"></A><B>E913</B>* *<A NAME="E974"></A><B>E974</B>* *<A NAME="E975"></A><B>E975</B>* *<A NAME="E976"></A><B>E976</B>*
|<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>|, |<A HREF="#Funcref">Funcref</A>|, |<A HREF="#Job">Job</A>|, |<A HREF="#Channel">Channel</A>| and |<A HREF="#Blob">Blob</A>| types are not
automatically converted.


							*<A NAME="E805"></A><B>E805</B>* *<A NAME="E806"></A><B>E806</B>* *<A NAME="E808"></A><B>E808</B>*
When mixing <A HREF="#Number">Number</A> and <A HREF="#Float">Float</A> the <A HREF="#Number">Number</A> is converted to <A HREF="#Float">Float</A>.  Otherwise
there is no automatic conversion of <A HREF="#Float">Float</A>.  You can use <A HREF="builtin.html#str2float()">str2float()</A> for <A HREF="#String">String</A>
to <A HREF="#Float">Float</A>, <A HREF="builtin.html#printf()">printf()</A> for <A HREF="#Float">Float</A> to <A HREF="#String">String</A> and <A HREF="builtin.html#float2nr()">float2nr()</A> for <A HREF="#Float">Float</A> to <A HREF="#Number">Number</A>.


			*<A NAME="E362"></A><B>E362</B>* *<A NAME="E891"></A><B>E891</B>* *<A NAME="E892"></A><B>E892</B>* *<A NAME="E893"></A><B>E893</B>* *<A NAME="E894"></A><B>E894</B>* *<A NAME="E907"></A><B>E907</B>* *<A NAME="E911"></A><B>E911</B>* *<A NAME="E914"></A><B>E914</B>*
When expecting a <A HREF="#Float">Float</A> a <A HREF="#Number">Number</A> can also be used, but nothing else.


						*<A NAME="no-type-checking"></A><B>no-type-checking</B>*
You will not get an error if you try to change the type of a variable.


<B><FONT COLOR="PURPLE">1.2 Function references </FONT></B>

					*<A NAME="Funcref"></A><B>Funcref</B>* *<A NAME="E695"></A><B>E695</B>* *<A NAME="E718"></A><B>E718</B>* *<A NAME="E1192"></A><B>E1192</B>*
A <A HREF="#Funcref">Funcref</A> variable is obtained with the |<A HREF="builtin.html#function()">function()</A>| function, the |<A HREF="builtin.html#funcref()">funcref()</A>|
function, (in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A>) the name of a function, or created with the
lambda <A HREF="#expression">expression</A> |<A HREF="#expr-lambda">expr-lambda</A>|.  It can be used in an <A HREF="#expression">expression</A> in the place
of a function name, before the parenthesis around the arguments, to invoke the
function <A HREF="motion.html#it">it</A> refers to.  Example in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A>:

<B>	:var Fn = MyFunc</B>
<B>	:echo Fn()</B>

Legacy <A HREF="usr_41.html#script">script</A>:
<B>	:let Fn = function("MyFunc")</B>
<B>	:echo Fn()</B>

 							*<A NAME="E704"></A><B>E704</B>* *<A NAME="E705"></A><B>E705</B>* *<A NAME="E707"></A><B>E707</B>*
A <A HREF="#Funcref">Funcref</A> variable must start with a capital, &quot;s:&quot;, &quot;<A HREF="#w:">w:</A>&quot;, &quot;<A HREF="#t:">t:</A>&quot; or &quot;<A HREF="#b:">b:</A>&quot;.  You
can use &quot;<A HREF="#g:">g:</A>&quot; but the following name must still start with a capital.  You
cannot have both a <A HREF="#Funcref">Funcref</A> variable and a function with the same name.

A special <A HREF="change.html#case">case</A> is defining a function and directly assigning its <A HREF="#Funcref">Funcref</A> to a
<A HREF="#Dictionary">Dictionary</A> entry.  Example:
<B>	:function dict.init() dict</B>
<B>	:   let self.val = 0</B>
<B>	:endfunction</B>

The key of the <A HREF="#Dictionary">Dictionary</A> can start with a lower <A HREF="change.html#case">case</A> <A HREF="print.html#letter">letter</A>.  The actual
function name is not used here.  Also see |<A HREF="#numbered-function">numbered-function</A>|.

A <A HREF="#Funcref">Funcref</A> can also be used with the |<A HREF="#:call">:call</A>| command:
<B>	:call Fn()</B>
<B>	:call dict.init()</B>

The name of the referenced function can be obtained with |<A HREF="builtin.html#string()">string()</A>|.
<B>	:let func = string(Fn)</B>

You can use |<A HREF="builtin.html#call()">call()</A>| to invoke a <A HREF="#Funcref">Funcref</A> and use a <A HREF="#list">list</A> variable for the
arguments:
<B>	:let r = call(Fn, mylist)</B>
 

								*<A NAME="Partial"></A><B>Partial</B>*
A <A HREF="#Funcref">Funcref</A> optionally binds a <A HREF="#Dictionary">Dictionary</A> and/or arguments.  This is also called
a <A HREF="#Partial">Partial</A>.  This is created by passing the <A HREF="#Dictionary">Dictionary</A> and/or arguments to
<A HREF="builtin.html#function()">function()</A> or <A HREF="builtin.html#funcref()">funcref()</A>.  When calling the function the <A HREF="#Dictionary">Dictionary</A> and/or
arguments will be passed to the function.  Example:

<B>	let Cb = function('Callback', ['foo'], myDict)</B>
<B>	call Cb('bar')</B>

This will invoke the function <A HREF="motion.html#as">as</A> if using:
<B>	call myDict.Callback('foo', 'bar')</B>

This is very useful when passing a function around, e.g. in the arguments of
|<A HREF="channel.html#ch_open()">ch_open()</A>|.

Note that binding a function to a <A HREF="#Dictionary">Dictionary</A> also happens when the function is
a member of the <A HREF="#Dictionary">Dictionary</A>:

<B>	let myDict.myFunction = MyFunction</B>
<B>	call myDict.myFunction()</B>

Here MyFunction() will get myDict passed <A HREF="motion.html#as">as</A> &quot;<A HREF="#self">self</A>&quot;.  This happens when the
&quot;myFunction&quot; member is accessed.  When making assigning &quot;myFunction&quot; to
otherDict and calling <A HREF="motion.html#it">it</A>, <A HREF="motion.html#it">it</A> will be bound to otherDict:

<B>	let otherDict.myFunction = myDict.myFunction</B>
<B>	call otherDict.myFunction()</B>

Now &quot;<A HREF="#self">self</A>&quot; will be &quot;otherDict&quot;.  But when the dictionary was bound explicitly
this won't happen:

<B>	let myDict.myFunction = function(MyFunction, myDict)</B>
<B>	let otherDict.myFunction = myDict.myFunction</B>
<B>	call otherDict.myFunction()</B>

Here &quot;<A HREF="#self">self</A>&quot; will be &quot;myDict&quot;, because <A HREF="motion.html#it">it</A> was bound explicitly.


<B><FONT COLOR="PURPLE">1.3 Lists </FONT></B>

						*<A NAME="list"></A><B>list</B>* *<A NAME="List"></A><B>List</B>* *<A NAME="Lists"></A><B>Lists</B>* *<A NAME="E686"></A><B>E686</B>*
A <A HREF="#List">List</A> is an ordered sequence of items.  An item can be of any type.  Items
can be accessed by their index number.  Items can be added and removed at any
position in the sequence.


<B><FONT COLOR="PURPLE">List creation </FONT></B>

							*<A NAME="E696"></A><B>E696</B>* *<A NAME="E697"></A><B>E697</B>*
A <A HREF="#List">List</A> is created with a comma-separated <A HREF="#list">list</A> of items in square brackets.
Examples:
<B>	:let mylist = [1, two, 3, "four"]</B>
<B>	:let emptylist = []</B>

An item can be any <A HREF="#expression">expression</A>.  Using a <A HREF="#List">List</A> for an item creates a
<A HREF="#List">List</A> of <A HREF="#Lists">Lists</A>:
<B>	:let nestlist = [[11, 12], [21, 22], [31, 32]]</B>

An extra comma after the last item is ignored.


<B><FONT COLOR="PURPLE">List index </FONT></B>

							*<A NAME="list-index"></A><B>list-index</B>* *<A NAME="E684"></A><B>E684</B>*
An item in the <A HREF="#List">List</A> can be accessed by putting the index in square brackets
after the <A HREF="#List">List</A>.  Indexes are zero-based, thus the first item has index zero.
<B>	:let item = mylist[0]		" get the first item: 1</B>
<B>	:let item = mylist[2]		" get the third item: 3</B>

When the resulting item is a <A HREF="#list">list</A> this can be repeated:
<B>	:let item = nestlist[0][1]	" get the first list, second item: 12</B>
 
A negative index is counted from the end.  Index -1 refers to the last item in
the <A HREF="#List">List</A>, -2 to the last but one item, etc.
<B>	:let last = mylist[-1]		" get the last item: "four"</B>

To avoid an error for an invalid index use the |<A HREF="builtin.html#get()">get()</A>| function.  When an item
is not available <A HREF="motion.html#it">it</A> returns zero or the default value you specify:
<B>	:echo get(mylist, idx)</B>
<B>	:echo get(mylist, idx, "NONE")</B>


<B><FONT COLOR="PURPLE">List concatenation </FONT></B>

							*<A NAME="list-concatenation"></A><B>list-concatenation</B>*
Two lists can be concatenated with the &quot;<A HREF="motion.html#+">+</A>&quot; <A HREF="motion.html#operator">operator</A>:
<B>	:let longlist = mylist + [5, 6]</B>
<B>	:let mylist += [7, 8]</B>

To prepend or append an item, turn the item into a <A HREF="#list">list</A> by putting <A HREF="motion.html#[]">[]</A> around
<A HREF="motion.html#it">it</A>.  To change a list in-place, refer to |<A HREF="#list-modification">list-modification</A>| below.


<B><FONT COLOR="PURPLE">Sublist </FONT></B>

							*<A NAME="sublist"></A><B>sublist</B>*
A part of the <A HREF="#List">List</A> can be obtained by specifying the first and last index,
separated by a colon in square brackets:
<B>	:let shortlist = mylist[2:-1]	" get List [3, "four"]</B>

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1.
<B>	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]</B>
<B>	:let shortlist = mylist[2:2]	" List with one item: [3]</B>
<B>	:let otherlist = mylist[:]	" make a copy of the List</B>

Notice that the last index is <A HREF="motion.html#inclusive">inclusive</A>.  If you prefer using an <A HREF="motion.html#exclusive">exclusive</A>
index use the |<A HREF="builtin.html#slice()">slice()</A>| <A HREF="#method">method</A>.

If the first index is beyond the last item of the <A HREF="#List">List</A> or the second item is
before the first item, the result is an empty <A HREF="#list">list</A>.  There is no error
message.

If the second index is equal to or greater than the length of the <A HREF="#list">list</A> the
length minus one is used:
<B>	:let mylist = [0, 1, 2, 3]</B>
<B>	:echo mylist[2:8]		" result: [2, 3]</B>

NOTE: mylist[s:e] means using the variable &quot;s:e&quot; <A HREF="motion.html#as">as</A> index.  Watch out for
using a single <A HREF="print.html#letter">letter</A> variable before the &quot;<A HREF="cmdline.html#:">:</A>&quot;.  <A HREF="insert.html#Insert">Insert</A> a space when needed:
mylist[s : e].


<B><FONT COLOR="PURPLE">List identity </FONT></B>

							*<A NAME="list-identity"></A><B>list-identity</B>*
When variable &quot;aa&quot; is a <A HREF="#list">list</A> and you assign <A HREF="motion.html#it">it</A> to another variable &quot;bb&quot;, both
<A HREF="#variables">variables</A> refer to the same <A HREF="#list">list</A>.  Thus <A HREF="change.html#changing">changing</A> the <A HREF="#list">list</A> &quot;aa&quot; will also
change &quot;bb&quot;:
<B>	:let aa = [1, 2, 3]</B>
<B>	:let bb = aa</B>
<B>	:call add(aa, 4)</B>
<B>	:echo bb</B>
 	[1, 2, 3, 4]

Making a copy of a <A HREF="#list">list</A> is done with the |<A HREF="builtin.html#copy()">copy()</A>| function.  Using [:] also
works, <A HREF="motion.html#as">as</A> explained above.  This creates a shallow copy of the <A HREF="#list">list</A>: Changing
a <A HREF="#list">list</A> item in the <A HREF="#list">list</A> will also change the item in the copied <A HREF="#list">list</A>:
<B>	:let aa = [[1, 'a'], 2, 3]</B>
<B>	:let bb = copy(aa)</B>
<B>	:call add(aa, 4)</B>
<B>	:let aa[0][1] = 'aaa'</B>
<B>	:echo aa</B>
 	[[1, aaa], 2, 3, 4]
<B>	:echo bb</B>
 	[[1, aaa], 2, 3]

To make a completely independent <A HREF="#list">list</A> use |<A HREF="builtin.html#deepcopy()">deepcopy()</A>|.  This also makes a
copy of the values in the <A HREF="#list">list</A>, recursively.  Up to a hundred levels deep.

The <A HREF="motion.html#operator">operator</A> &quot;is&quot; can be used to check if two <A HREF="#variables">variables</A> refer to the same
<A HREF="#List">List</A>.  &quot;isnot&quot; does the opposite.  In contrast &quot;<A HREF="change.html#==">==</A>&quot; compares if two lists have
the same value.
<B>	:let alist = [1, 2, 3]</B>
<B>	:let blist = [1, 2, 3]</B>
<B>	:echo alist is blist</B>
 	0
<B>	:echo alist == blist</B>
 	1

Note about comparing lists: Two lists are considered equal if they have the
same length and all items compare equal, <A HREF="motion.html#as">as</A> with using &quot;<A HREF="change.html#==">==</A>&quot;.  There is one
exception: When comparing a number with a <A HREF="#string">string</A> they are considered
different.  There is no automatic type conversion, <A HREF="motion.html#as">as</A> with using &quot;<A HREF="change.html#==">==</A>&quot; on
<A HREF="#variables">variables</A>.  Example:
<B>	echo 4 == "4"</B>
 	1
<B>	echo [4] == ["4"]</B>
 	0

Thus comparing <A HREF="#Lists">Lists</A> is more strict than comparing numbers and strings.  You
can compare simple values this way too by putting them in a <A HREF="#list">list</A>:

<B>	:let a = 5</B>
<B>	:let b = "5"</B>
<B>	:echo a == b</B>
 	1
<B>	:echo [a] == [b]</B>
 	0


<B><FONT COLOR="PURPLE">List unpack </FONT></B>

To unpack the items in a <A HREF="#list">list</A> to individual <A HREF="#variables">variables</A>, put the <A HREF="#variables">variables</A> in
square brackets, like <A HREF="#list">list</A> items:
<B>	:let [var1, var2] = mylist</B>

When the number of <A HREF="#variables">variables</A> does not match the number of items in the <A HREF="#list">list</A>
this produces an error.  To handle any extra items from the <A HREF="#list">list</A> append &quot;<A HREF="motion.html#;">;</A>&quot;
and a variable name:
<B>	:let [var1, var2; rest] = mylist</B>

This works like:
<B>	:let var1 = mylist[0]</B>
<B>	:let var2 = mylist[1]</B>
<B>	:let rest = mylist[2:]</B>

Except that there is no error if there are only two items.  &quot;rest&quot; will be an
empty <A HREF="#list">list</A> then.


<B><FONT COLOR="PURPLE">List modification </FONT></B>

							*<A NAME="list-modification"></A><B>list-modification</B>*
To change a specific item of a <A HREF="#list">list</A> use |<A HREF="#:let">:let</A>| this way:
<B>	:let list[4] = "four"</B>
<B>	:let listlist[0][3] = item</B>

To change part of a <A HREF="#list">list</A> you can specify the first and last item to be
modified.  The value must at least have the number of items in the range:
<B>	:let list[3:5] = [3, 4, 5]</B>

Adding and removing items from a <A HREF="#list">list</A> is done with <A HREF="#functions">functions</A>.  Here are a few
examples:
<B>	:call insert(list, 'a')		" prepend item 'a'</B>
<B>	:call insert(list, 'a', 3)	" insert item 'a' before list[3]</B>
<B>	:call add(list, "new")		" append String item</B>
<B>	:call add(list, [1, 2])		" append a List as one new item</B>
<B>	:call extend(list, [1, 2])	" extend the list with two more items</B>
<B>	:let i = remove(list, 3)	" remove item 3</B>
<B>	:unlet list[3]			" idem</B>
<B>	:let l = remove(list, 3, -1)	" remove items 3 to last item</B>
<B>	:unlet list[3 : ]		" idem</B>
<B>	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'</B>

Changing the order of items in a <A HREF="#list">list</A>:
<B>	:call sort(list)		" sort a list alphabetically</B>
<B>	:call reverse(list)		" reverse the order of items</B>
<B>	:call uniq(sort(list))		" sort and remove duplicates</B>


<B><FONT COLOR="PURPLE">For loop </FONT></B>

The |<A HREF="#:for">:for</A>| loop executes commands for each item in a <A HREF="#List">List</A>, <A HREF="#String">String</A> or <A HREF="#Blob">Blob</A>.
A variable is set to each item in sequence.  Example with a <A HREF="#List">List</A>:
<B>	:for item in mylist</B>
<B>	:   call Doit(item)</B>
<B>	:endfor</B>

This works like:
<B>	:let index = 0</B>
<B>	:while index &lt; len(mylist)</B>
<B>	:   let item = mylist[index]</B>
<B>	:   :call Doit(item)</B>
<B>	:   let index = index + 1</B>
<B>	:endwhile</B>

If all you want to <A HREF="diff.html#do">do</A> is modify each item in the <A HREF="#list">list</A> then the |<A HREF="builtin.html#map()">map()</A>|
function will be a simpler <A HREF="#method">method</A> than a for loop.

Just like the |<A HREF="#:let">:let</A>| command, |<A HREF="#:for">:for</A>| also accepts a <A HREF="#list">list</A> of <A HREF="#variables">variables</A>.  This
requires the argument to be a <A HREF="#List">List</A> of <A HREF="#Lists">Lists</A>.
<B>	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]</B>
<B>	:   call Doit(lnum, col)</B>
<B>	:endfor</B>

This works like a |<A HREF="#:let">:let</A>| command is done for each <A HREF="#list">list</A> item.  Again, the types
must remain the same to avoid an error.

It is also possible to put remaining items in a <A HREF="#List">List</A> variable:
<B>	:for [i, j; rest] in listlist</B>
<B>	:   call Doit(i, j)</B>
<B>	:   if !empty(rest)</B>
<B>	:      echo "remainder: " .. string(rest)</B>
<B>	:   endif</B>
<B>	:endfor</B>

For a <A HREF="#Blob">Blob</A> one byte at a time is used.

For a <A HREF="#String">String</A> one character, including any composing characters, is used <A HREF="motion.html#as">as</A> a
<A HREF="#String">String</A>.  Example:
<B>	for c in text</B>
<B>	  echo 'This character is ' .. c</B>
<B>	endfor</B>


<B><FONT COLOR="PURPLE">List functions </FONT></B>

						*<A NAME="E714"></A><B>E714</B>*
Functions that are useful with a <A HREF="#List">List</A>:
<B>	:let r = call(funcname, list)	" call a function with an argument list</B>
<B>	:if empty(list)			" check if list is empty</B>
<B>	:let l = len(list)		" number of items in list</B>
<B>	:let big = max(list)		" maximum value in list</B>
<B>	:let small = min(list)		" minimum value in list</B>
<B>	:let xs = count(list, 'x')	" count nr of times 'x' appears in list</B>
<B>	:let i = index(list, 'x')	" index of first 'x' in list</B>
<B>	:let lines = getline(1, 10)	" get ten text lines from buffer</B>
<B>	:call append('$', lines)	" append text lines in buffer</B>
<B>	:let list = split("a b c")	" create list from items in a string</B>
<B>	:let string = join(list, ', ')	" create string from list items</B>
<B>	:let s = string(list)		" String representation of list</B>
<B>	:call map(list, '"&gt;&gt; " .. v:val')  " prepend "&gt;&gt; " to each item</B>

Don't forget that a combination of features can make things simple.  For
example, to add up all the numbers in a <A HREF="#list">list</A>:
<B>	:exe 'let sum = ' .. join(nrlist, '+')</B>


<B><FONT COLOR="PURPLE">1.4 Dictionaries </FONT></B>

				*<A NAME="dict"></A><B>dict</B>* *<A NAME="Dict"></A><B>Dict</B>* *<A NAME="Dictionaries"></A><B>Dictionaries</B>* *<A NAME="Dictionary"></A><B>Dictionary</B>*
A <A HREF="#Dictionary">Dictionary</A> is an associative array: Each entry has a key and a value.  The
entry can be located with the key.  The entries are stored without a specific
ordering.


<B><FONT COLOR="PURPLE">Dictionary creation </FONT></B>

						*<A NAME="E720"></A><B>E720</B>* *<A NAME="E721"></A><B>E721</B>* *<A NAME="E722"></A><B>E722</B>* *<A NAME="E723"></A><B>E723</B>*
A <A HREF="#Dictionary">Dictionary</A> is created with a comma-separated <A HREF="#list">list</A> of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once.  Examples:
<B>	:let mydict = {1: 'one', 2: 'two', 3: 'three'}</B>
<B>	:let emptydict = {}</B>

 							*<A NAME="E713"></A><B>E713</B>* *<A NAME="E716"></A><B>E716</B>* *<A NAME="E717"></A><B>E717</B>*
A key is always a <A HREF="#String">String</A>.  You can use a <A HREF="#Number">Number</A>, <A HREF="motion.html#it">it</A> will be converted to a
<A HREF="#String">String</A> automatically.  Thus the <A HREF="#String">String</A> '4' and the number 4 will find the same
entry.  Note that the <A HREF="#String">String</A> '04' and the <A HREF="#Number">Number</A> 04 are different, since the
<A HREF="#Number">Number</A> will be converted to the <A HREF="#String">String</A> '4', leading zeros are dropped.  The
empty <A HREF="#string">string</A> can also be used <A HREF="motion.html#as">as</A> a key.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> a literal key can be used if <A HREF="motion.html#it">it</A> consists only of alphanumeric
characters, underscore and dash, see |<A HREF="vim9.html#vim9-literal-dict">vim9-literal-dict</A>|.

						*<A NAME="literal-Dict"></A><B>literal-Dict</B>* *<A NAME="#{}"></A><B>#{}</B>*
To avoid having to put <A HREF="quotes.html#quotes">quotes</A> around every key the <A HREF="##{}">#{}</A> form can be used in
legacy <A HREF="usr_41.html#script">script</A>.  This does require the key to consist only of ASCII letters,
digits, '<A HREF="motion.html#-">-</A>' and '<A HREF="motion.html#_">_</A>'.  Example:
<B>	:let mydict = #{zero: 0, one_key: 1, two-key: 2, 333: 3}</B>
Note that 333 here is the <A HREF="#string">string</A> &quot;333&quot;.  Empty keys are not possible with <A HREF="##{}">#{}</A>.
In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the <A HREF="##{}">#{}</A> form cannot be used because <A HREF="motion.html#it">it</A> can be confused with
the start of a comment.

A value can be any <A HREF="#expression">expression</A>.  Using a <A HREF="#Dictionary">Dictionary</A> for a value creates a
nested <A HREF="#Dictionary">Dictionary</A>:
<B>	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}</B>

An extra comma after the last entry is ignored.


<B><FONT COLOR="PURPLE">Accessing entries </FONT></B>

The normal way to access an entry is by putting the key in square brackets:
<B>	:let val = mydict["one"]</B>
<B>	:let mydict["four"] = 4</B>

You can add new entries to an existing <A HREF="#Dictionary">Dictionary</A> this way, unlike <A HREF="#Lists">Lists</A>.

For keys that consist entirely of letters, digits and underscore the following
form can be used YXXYexpr-entry|:
<B>	:let val = mydict.one</B>
<B>	:let mydict.four = 4</B>

Since an entry can be any type, also a <A HREF="#List">List</A> and a <A HREF="#Dictionary">Dictionary</A>, the indexing and
key lookup can be repeated:
<B>	:echo dict.key[idx].key</B>


<B><FONT COLOR="PURPLE">Dictionary to List conversion </FONT></B>

You may want to loop over the entries in a dictionary.  For this you need to
turn the <A HREF="#Dictionary">Dictionary</A> into a <A HREF="#List">List</A> and pass <A HREF="motion.html#it">it</A> to |<A HREF="#:for">:for</A>|.

Most often you want to loop over the keys, using the |<A HREF="builtin.html#keys()">keys()</A>| function:
<B>	:for key in keys(mydict)</B>
<B>	:   echo key .. ': ' .. mydict[key]</B>
<B>	:endfor</B>

The <A HREF="#List">List</A> of keys is unsorted.  You may want to sort them first:
<B>	:for key in sort(keys(mydict))</B>

To loop over the values use the |<A HREF="builtin.html#values()">values()</A>| function: 
<B>	:for v in values(mydict)</B>
<B>	:   echo "value: " .. v</B>
<B>	:endfor</B>

If you want both the key and the value use the |<A HREF="builtin.html#items()">items()</A>| function.  It returns
a <A HREF="#List">List</A> in which each item is a <A HREF="#List">List</A> with two items, the key and the value:
<B>	:for [key, value] in items(mydict)</B>
<B>	:   echo key .. ': ' .. value</B>
<B>	:endfor</B>


<B><FONT COLOR="PURPLE">Dictionary identity </FONT></B>

							*<A NAME="dict-identity"></A><B>dict-identity</B>*
Just like <A HREF="#Lists">Lists</A> you need to use |<A HREF="builtin.html#copy()">copy()</A>| and |<A HREF="builtin.html#deepcopy()">deepcopy()</A>| to make a copy of a
<A HREF="#Dictionary">Dictionary</A>.  Otherwise, assignment results in referring to the same
<A HREF="#Dictionary">Dictionary</A>:
<B>	:let onedict = {'a': 1, 'b': 2}</B>
<B>	:let adict = onedict</B>
<B>	:let adict['a'] = 11</B>
<B>	:echo onedict['a']</B>
<B>	11</B>

Two <A HREF="#Dictionaries">Dictionaries</A> compare equal if all the key-value pairs compare equal.  For
more info see |<A HREF="#list-identity">list-identity</A>|.


<B><FONT COLOR="PURPLE">Dictionary modification </FONT></B>

							*<A NAME="dict-modification"></A><B>dict-modification</B>*
To change an already existing entry of a <A HREF="#Dictionary">Dictionary</A>, or to add a new entry,
use |<A HREF="#:let">:let</A>| this way:
<B>	:let dict[4] = "four"</B>
<B>	:let dict['one'] = item</B>

Removing an entry from a <A HREF="#Dictionary">Dictionary</A> is done with |<A HREF="builtin.html#remove()">remove()</A>| or |<A HREF="#:unlet">:unlet</A>|.
Three ways to remove the entry with key &quot;aaa&quot; from <A HREF="#dict">dict</A>:
<B>	:let i = remove(dict, 'aaa')</B>
<B>	:unlet dict.aaa</B>
<B>	:unlet dict['aaa']</B>

Merging a <A HREF="#Dictionary">Dictionary</A> with another is done with YXXYextend()|:
<B>	:call extend(adict, bdict)</B>
This extends adict with all entries from bdict.  Duplicate keys cause entries
in adict to be overwritten.  An optional third argument can change this.
Note that the order of entries in a <A HREF="#Dictionary">Dictionary</A> is irrelevant, thus don't
expect &quot;<A HREF="#:echo">:echo</A> adict&quot; to show the items from bdict after the older entries in
adict.

Weeding out entries from a <A HREF="#Dictionary">Dictionary</A> can be done with YXXYfilter()|:
<B>	:call filter(dict, 'v:val =~ "x"')</B>
This removes all entries from &quot;<A HREF="#dict">dict</A>&quot; with a value not matching '<A HREF="change.html#x">x</A>'.
This can also be used to remove all entries:
<B>	call filter(dict, 0)</B>


<B><FONT COLOR="PURPLE">Dictionary function </FONT></B>

				*<A NAME="Dictionary-function"></A><B>Dictionary-function</B>* *<A NAME="self"></A><B>self</B>* *<A NAME="E725"></A><B>E725</B>* *<A NAME="E862"></A><B>E862</B>*
When a function is defined with the &quot;<A HREF="#dict">dict</A>&quot; attribute <A HREF="motion.html#it">it</A> can be used in a
special way with a dictionary.  Example:
<B>	:function Mylen() dict</B>
<B>	:   return len(self.data)</B>
<B>	:endfunction</B>
<B>	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}</B>
<B>	:echo mydict.len()</B>

This is like a <A HREF="#method">method</A> in object oriented programming.  The entry in the
<A HREF="#Dictionary">Dictionary</A> is a |<A HREF="#Funcref">Funcref</A>|.  The local variable &quot;<A HREF="#self">self</A>&quot; refers to the dictionary
the function was invoked from.

It is also possible to add a function without the &quot;<A HREF="#dict">dict</A>&quot; attribute <A HREF="motion.html#as">as</A> a
<A HREF="#Funcref">Funcref</A> to a <A HREF="#Dictionary">Dictionary</A>, but the &quot;<A HREF="#self">self</A>&quot; variable is not available then.


				*<A NAME="numbered-function"></A><B>numbered-function</B>* *<A NAME="anonymous-function"></A><B>anonymous-function</B>*
To avoid the extra name for the function <A HREF="motion.html#it">it</A> can be defined and directly
assigned to a <A HREF="#Dictionary">Dictionary</A> in this way:
<B>	:let mydict = {'data': [0, 1, 2, 3]}</B>
<B>	:function mydict.len()</B>
<B>	:   return len(self.data)</B>
<B>	:endfunction</B>
<B>	:echo mydict.len()</B>

The function will then get a number and the value of dict.len is a |<A HREF="#Funcref">Funcref</A>|
that references this function.  The function can only be used through a
|<A HREF="#Funcref">Funcref</A>|.  It will automatically be deleted when there is no |<A HREF="#Funcref">Funcref</A>|
remaining that refers to <A HREF="motion.html#it">it</A>.

It is not necessary to use the &quot;<A HREF="#dict">dict</A>&quot; attribute for a numbered function.

If you get an error for a numbered function, you can find out what <A HREF="motion.html#it">it</A> is with
a trick.  Assuming the function is <A HREF="usr_42.html#42">42</A>, the command is:
<B>	:function g:42</B>


<B><FONT COLOR="PURPLE">Functions for Dictionaries </FONT></B>

							*<A NAME="E715"></A><B>E715</B>*
Functions that can be used with a <A HREF="#Dictionary">Dictionary</A>:
<B>	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"</B>
<B>	:if empty(dict)			" TRUE if dict is empty</B>
<B>	:let l = len(dict)		" number of items in dict</B>
<B>	:let big = max(dict)		" maximum value in dict</B>
<B>	:let small = min(dict)		" minimum value in dict</B>
<B>	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict</B>
<B>	:let s = string(dict)		" String representation of dict</B>
<B>	:call map(dict, '"&gt;&gt; " .. v:val')  " prepend "&gt;&gt; " to each item</B>


<B><FONT COLOR="PURPLE">1.5 Blobs </FONT></B>

						*<A NAME="blob"></A><B>blob</B>* *<A NAME="Blob"></A><B>Blob</B>* *<A NAME="Blobs"></A><B>Blobs</B>* *<A NAME="E978"></A><B>E978</B>*
A <A HREF="#Blob">Blob</A> is a binary object.  It can be used to read an image from a file and
send <A HREF="motion.html#it">it</A> over a <A HREF="channel.html#channel">channel</A>, for example.

A <A HREF="#Blob">Blob</A> mostly behaves like a |<A HREF="#List">List</A>| of numbers, where each number has the
value of an 8-bit byte, from 0 to 255.


<B><FONT COLOR="PURPLE">Blob creation </FONT></B>

A <A HREF="#Blob">Blob</A> can be created with a YXXYblob-literal|:
<B>	:let b = 0zFF00ED015DAF</B>
Dots can be inserted between bytes (pair of hex characters) for readability,
they don't change the value:
<B>	:let b = 0zFF00.ED01.5DAF</B>

A <A HREF="#blob">blob</A> can be read from a file with |<A HREF="builtin.html#readfile()">readfile()</A>| passing the {type} argument
set to &quot;<A HREF="motion.html#B">B</A>&quot;, for example:
<B>	:let b = readfile('image.png', 'B')</B>

A blob can be read from a <A HREF="channel.html#channel">channel</A> with the |<A HREF="channel.html#ch_readblob()">ch_readblob()</A>| function.


<B><FONT COLOR="PURPLE">Blob index </FONT></B>

							*<A NAME="blob-index"></A><B>blob-index</B>* *<A NAME="E979"></A><B>E979</B>*
A byte in the <A HREF="#Blob">Blob</A> can be accessed by putting the index in square brackets
after the <A HREF="#Blob">Blob</A>.  Indexes are zero-based, thus the first byte has index zero.
<B>	:let myblob = 0z00112233</B>
<B>	:let byte = myblob[0]		" get the first byte: 0x00</B>
<B>	:let byte = myblob[2]		" get the third byte: 0x22</B>

A negative index is counted from the end.  Index -1 refers to the last byte in
the <A HREF="#Blob">Blob</A>, -2 to the last but one byte, etc.
<B>	:let last = myblob[-1]		" get the last byte: 0x33</B>

To avoid an error for an invalid index use the |<A HREF="builtin.html#get()">get()</A>| function.  When an item
is not available <A HREF="motion.html#it">it</A> returns -1 or the default value you specify:
<B>	:echo get(myblob, idx)</B>
<B>	:echo get(myblob, idx, 999)</B>


<B><FONT COLOR="PURPLE">Blob iteration </FONT></B>

The |<A HREF="#:for">:for</A>| loop executes commands for each byte of a <A HREF="#Blob">Blob</A>.  The loop variable is
set to each byte in the <A HREF="#Blob">Blob</A>.  Example:
<B>	:for byte in 0z112233</B>
<B>	:   call Doit(byte)</B>
<B>	:endfor</B>
This calls Doit() with 0x11, 0x22 and 0x33.


<B><FONT COLOR="PURPLE">Blob concatenation </FONT></B>

Two blobs can be concatenated with the &quot;<A HREF="motion.html#+">+</A>&quot; <A HREF="motion.html#operator">operator</A>:
<B>	:let longblob = myblob + 0z4455</B>
<B>	:let myblob += 0z6677</B>

To change a blob in-place see |<A HREF="#blob-modification">blob-modification</A>| below.


<B><FONT COLOR="PURPLE">Part of a blob </FONT></B>

A part of the <A HREF="#Blob">Blob</A> can be obtained by specifying the first and last index,
separated by a colon in square brackets:
<B>	:let myblob = 0z00112233</B>
<B>	:let shortblob = myblob[1:2]	" get 0z1122</B>
<B>	:let shortblob = myblob[2:-1]	" get 0z2233</B>

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1.
<B>	:let endblob = myblob[2:]	" from item 2 to the end: 0z2233</B>
<B>	:let shortblob = myblob[2:2]	" Blob with one byte: 0z22</B>
<B>	:let otherblob = myblob[:]	" make a copy of the Blob</B>

If the first index is beyond the last byte of the <A HREF="#Blob">Blob</A> or the second index is
before the first index, the result is an empty <A HREF="#Blob">Blob</A>.  There is no error
message.

If the second index is equal to or greater than the length of the <A HREF="#list">list</A> the
length minus one is used:
<B>	:echo myblob[2:8]		" result: 0z2233</B>


<B><FONT COLOR="PURPLE">Blob modification </FONT></B>

					*<A NAME="blob-modification"></A><B>blob-modification</B>* *<A NAME="E1182"></A><B>E1182</B>* *<A NAME="E1184"></A><B>E1184</B>*
To change a specific byte of a <A HREF="#blob">blob</A> use |<A HREF="#:let">:let</A>| this way:
<B>	:let blob[4] = 0x44</B>

When the index is just one beyond the end of the <A HREF="#Blob">Blob</A>, <A HREF="motion.html#it">it</A> is appended. Any
higher index is an error.

To change a sequence of bytes the [:] <A HREF="intro.html#notation">notation</A> can be used:
<B>	let blob[1:3] = 0z445566</B>
The length of the replaced bytes must be exactly the same <A HREF="motion.html#as">as</A> the value

provided. *<A NAME="E972"></A><B>E972</B>*

To change part of a <A HREF="#blob">blob</A> you can specify the first and last byte to be
modified.  The value must have the same number of bytes in the range:
<B>	:let blob[3:5] = 0z334455</B>

You can also use the <A HREF="#functions">functions</A> |<A HREF="builtin.html#add()">add()</A>|, |<A HREF="builtin.html#remove()">remove()</A>| and |<A HREF="builtin.html#insert()">insert()</A>|.


<B><FONT COLOR="PURPLE">Blob identity </FONT></B>

<A HREF="#Blobs">Blobs</A> can be compared for equality:
<B>	if blob == 0z001122</B>
And for equal identity:
<B>	if blob is otherblob</B>

 							*<A NAME="blob-identity"></A><B>blob-identity</B>* *<A NAME="E977"></A><B>E977</B>*
When variable &quot;aa&quot; is a <A HREF="#Blob">Blob</A> and you assign <A HREF="motion.html#it">it</A> to another variable &quot;bb&quot;, both
<A HREF="#variables">variables</A> refer to the same <A HREF="#Blob">Blob</A>.  Then the &quot;is&quot; <A HREF="motion.html#operator">operator</A> returns <A HREF="vim9.html#true">true</A>.

When making a copy using [:] or |<A HREF="builtin.html#copy()">copy()</A>| the values are the same, but the
identity is different:
<B>	:let blob = 0z112233</B>
<B>	:let blob2 = blob</B>
<B>	:echo blob == blob2</B>
 	1
<B>	:echo blob is blob2</B>
 	1
<B>	:let blob3 = blob[:]</B>
<B>	:echo blob == blob3</B>
 	1
<B>	:echo blob is blob3</B>
 	0

Making a copy of a <A HREF="#Blob">Blob</A> is done with the |<A HREF="builtin.html#copy()">copy()</A>| function.  Using [:] also
works, <A HREF="motion.html#as">as</A> explained above.


<B><FONT COLOR="PURPLE">1.6 More about variables </FONT></B>

							*<A NAME="more-variables"></A><B>more-variables</B>*
If you need to know the type of a variable or <A HREF="#expression">expression</A>, use the |<A HREF="builtin.html#type()">type()</A>|
function.

When the '<A HREF="change.html#!">!</A>' flag is included in the <A HREF="options.html#'viminfo'">'viminfo'</A> option, global <A HREF="#variables">variables</A> that
start with an <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A>, and don't contain a <A HREF="change.html#lowercase">lowercase</A> <A HREF="print.html#letter">letter</A>, are
stored in the viminfo file |<A HREF="starting.html#viminfo-file">viminfo-file</A>|.

When the <A HREF="options.html#'sessionoptions'">'sessionoptions'</A> option contains &quot;global&quot;, global <A HREF="#variables">variables</A> that
start with an <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A> and contain at least one <A HREF="change.html#lowercase">lowercase</A> <A HREF="print.html#letter">letter</A> are
stored in the session file |<A HREF="starting.html#session-file">session-file</A>|.

<B><FONT COLOR="PURPLE">variable name		can be stored where </FONT></B>
my_var_6		not
My_Var_6		session file
MY_VAR_6		<A HREF="starting.html#viminfo">viminfo</A> file


In legacy <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> is possible to form a variable name with curly braces, see
|<A HREF="#curly-braces-names">curly-braces-names</A>|.

==============================================================================

2. Expression <A HREF="syntax.html#syntax">syntax</A>					*<A NAME="expression-syntax"></A><B>expression-syntax</B>*

							*<A NAME="E1143"></A><B>E1143</B>*
Expression <A HREF="syntax.html#syntax">syntax</A> summary, from least to most significant:

|<A HREF="#expr1">expr1</A>|	<A HREF="#expr2">expr2</A>
	<A HREF="#expr2">expr2</A> ? <A HREF="#expr1">expr1</A> : <A HREF="#expr1">expr1</A>	if-then-else

|<A HREF="#expr2">expr2</A>|	<A HREF="#expr3">expr3</A>
	<A HREF="#expr3">expr3</A> &#124;&#124; <A HREF="#expr3">expr3</A> <A HREF="#...">...</A>	logical OR

|<A HREF="#expr3">expr3</A>|	<A HREF="#expr4">expr4</A>
	<A HREF="#expr4">expr4</A> &amp;&amp; <A HREF="#expr4">expr4</A> <A HREF="#...">...</A>	logical AND

|<A HREF="#expr4">expr4</A>|	<A HREF="#expr5">expr5</A>
	<A HREF="#expr5">expr5</A> <A HREF="change.html#==">==</A> <A HREF="#expr5">expr5</A>		equal
	<A HREF="#expr5">expr5</A> != <A HREF="#expr5">expr5</A>		not equal
	<A HREF="#expr5">expr5</A> <A HREF="change.html#&gt;">&gt;</A>	 <A HREF="#expr5">expr5</A>		greater than
	<A HREF="#expr5">expr5</A> &gt;= <A HREF="#expr5">expr5</A>		greater than or equal
	<A HREF="#expr5">expr5</A> <A HREF="change.html#&lt;">&lt;</A>	 <A HREF="#expr5">expr5</A>		smaller than
	<A HREF="#expr5">expr5</A> &lt;= <A HREF="#expr5">expr5</A>		smaller than or equal
	<A HREF="#expr5">expr5</A> =~ <A HREF="#expr5">expr5</A>		<A HREF="pattern.html#regexp">regexp</A> matches
	<A HREF="#expr5">expr5</A> !~ <A HREF="#expr5">expr5</A>		<A HREF="pattern.html#regexp">regexp</A> doesn't match

	<A HREF="#expr5">expr5</A> <A HREF="change.html#==">==</A>? <A HREF="#expr5">expr5</A>		equal, ignoring <A HREF="change.html#case">case</A>
	<A HREF="#expr5">expr5</A> ==# <A HREF="#expr5">expr5</A>		equal, match <A HREF="change.html#case">case</A>
	etc.			As above, append ? for ignoring <A HREF="change.html#case">case</A>, # for
				matching <A HREF="change.html#case">case</A>

	<A HREF="#expr5">expr5</A> is <A HREF="#expr5">expr5</A>		same |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>| instance
	<A HREF="#expr5">expr5</A> isnot <A HREF="#expr5">expr5</A>	different |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>|
				instance

|<A HREF="#expr5">expr5</A>|	<A HREF="#expr6">expr6</A> <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> <A HREF="#expr6">expr6</A>		bitwise left <A HREF="intro.html#shift">shift</A>
	<A HREF="#expr6">expr6</A> <A HREF="change.html#&gt;&gt;">&gt;&gt;</A> <A HREF="#expr6">expr6</A>		bitwise right <A HREF="intro.html#shift">shift</A>

|<A HREF="#expr6">expr6</A>|	<A HREF="#expr7">expr7</A>
	<A HREF="#expr7">expr7</A> +	 <A HREF="#expr7">expr7</A> <A HREF="#...">...</A>	number addition, <A HREF="#list">list</A> or <A HREF="#blob">blob</A> concatenation
	<A HREF="#expr7">expr7</A> -	 <A HREF="#expr7">expr7</A> <A HREF="#...">...</A>	number subtraction
	<A HREF="#expr7">expr7</A> .	 <A HREF="#expr7">expr7</A> <A HREF="#...">...</A>	<A HREF="#string">string</A> concatenation
	<A HREF="#expr7">expr7</A> .. <A HREF="#expr7">expr7</A> <A HREF="#...">...</A>	<A HREF="#string">string</A> concatenation

|<A HREF="#expr7">expr7</A>|	<A HREF="#expr8">expr8</A>
	<A HREF="#expr8">expr8</A> &#42;	 <A HREF="#expr8">expr8</A> <A HREF="#...">...</A>	number multiplication
	<A HREF="#expr8">expr8</A> /	 <A HREF="#expr8">expr8</A> <A HREF="#...">...</A>	number division
	<A HREF="#expr8">expr8</A> <A HREF="motion.html#&#37;">&#37;</A>	 <A HREF="#expr8">expr8</A> <A HREF="#...">...</A>	number modulo

|<A HREF="#expr8">expr8</A>|	<A HREF="#expr9">expr9</A>
	&lt;type&gt;expr9		type check and conversion (|<A HREF="vim9.html#Vim9">Vim9</A>| only)

|<A HREF="#expr9">expr9</A>|	<A HREF="#expr10">expr10</A>
	! <A HREF="#expr9">expr9</A>			logical NOT
	- <A HREF="#expr9">expr9</A>			unary minus
	+ <A HREF="#expr9">expr9</A>			unary plus

|<A HREF="#expr10">expr10</A>|  <A HREF="#expr11">expr11</A>
	expr10[expr1]		byte of a <A HREF="#String">String</A> or item of a |<A HREF="#List">List</A>|
	expr10[expr1 : expr1]	<A HREF="#substring">substring</A> of a <A HREF="#String">String</A> or <A HREF="#sublist">sublist</A> of a |<A HREF="#List">List</A>|
	expr10.name		entry in a |<A HREF="#Dictionary">Dictionary</A>|
	expr10(expr1, <A HREF="#...">...</A>)	function call with |<A HREF="#Funcref">Funcref</A>| variable
	expr10-&gt;name(expr1, <A HREF="#...">...</A>)	|<A HREF="#method">method</A>| call

|<A HREF="#expr11">expr11</A>|  number		number constant
	&quot;<A HREF="#string">string</A>&quot;		<A HREF="#string">string</A> constant, <A HREF="intro.html#backslash">backslash</A> is special
	'<A HREF="#string">string</A>'		<A HREF="#string">string</A> constant, '' is doubled
	[expr1, ...]		|<A HREF="#List">List</A>|
	{expr1: <A HREF="#expr1">expr1</A>, ...}	|<A HREF="#Dictionary">Dictionary</A>|
	#{key: <A HREF="#expr1">expr1</A>, ...}	legacy |<A HREF="#Dictionary">Dictionary</A>|
	&amp;option			option value
	(expr1)			nested <A HREF="#expression">expression</A>
	variable		internal variable
	va{ria}ble		internal variable with curly braces
	$VAR			environment variable
	<A HREF="#@r">@r</A>			contents of <A HREF="sponsor.html#register">register</A> '<A HREF="change.html#r">r</A>'
	function(expr1, <A HREF="#...">...</A>)	function call
	func{ti}on(expr1, <A HREF="#...">...</A>)	function call with curly braces
	{args <A HREF="#-&gt;">-&gt;</A> expr1}		legacy <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>
	(args) =&gt; <A HREF="#expr1">expr1</A>		<A HREF="vim9.html#Vim9">Vim9</A> <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>


&quot;<A HREF="#...">...</A>&quot; indicates that the operations in this level can be concatenated.
Example:
<B>	&amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</B>

All expressions within one level are parsed from left to right.

Expression nesting is limited to 1000 levels deep (300 when build with MSVC)

to avoid running out of stack and crashing. *<A NAME="E1169"></A><B>E1169</B>*



<A HREF="#expr1">expr1</A>				*<A NAME="expr1"></A><B>expr1</B>* *<A NAME="ternary"></A><B>ternary</B>* *<A NAME="falsy-operator"></A><B>falsy-operator</B>* *<A NAME="??"></A><B>??</B>* *<A NAME="E109"></A><B>E109</B>*

The <A HREF="#ternary">ternary</A> <A HREF="motion.html#operator">operator</A>: <A HREF="#expr2">expr2</A> ? <A HREF="#expr1">expr1</A> : <A HREF="#expr1">expr1</A>
The <A HREF="#falsy">falsy</A> <A HREF="motion.html#operator">operator</A>:   <A HREF="#expr2">expr2</A> <A HREF="#??">??</A> <A HREF="#expr1">expr1</A>

<B><FONT COLOR="PURPLE">Ternary operator </FONT></B>

In legacy <A HREF="usr_41.html#script">script</A> the <A HREF="#expression">expression</A> before the '<A HREF="pattern.html#?">?</A>' is evaluated to a number.  If
<A HREF="motion.html#it">it</A> evaluates to |<A HREF="#TRUE">TRUE</A>|, the result is the value of the <A HREF="#expression">expression</A> between the
'<A HREF="pattern.html#?">?</A>' and '<A HREF="cmdline.html#:">:</A>', otherwise the result is the value of the <A HREF="#expression">expression</A> after the
'<A HREF="cmdline.html#:">:</A>'.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the first <A HREF="#expression">expression</A> must evaluate to a <A HREF="options.html#boolean">boolean</A>, see
|<A HREF="vim9.html#vim9-boolean">vim9-boolean</A>|.

Example:
<B>	:echo lnum == 1 ? "top" : lnum</B>

Since the first <A HREF="#expression">expression</A> is an &quot;<A HREF="#expr2">expr2</A>&quot;, <A HREF="motion.html#it">it</A> cannot contain another ?:.  The
other two expressions can, thus allow for recursive use of ?:.
Example:
<B>	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum</B>

To keep this readable, using |<A HREF="repeat.html#line-continuation">line-continuation</A>| is suggested:
<B>	:echo lnum == 1</B>
<B>	:\	? "top"</B>
<B>	:\	: lnum == 1000</B>
<B>	:\		? "last"</B>
<B>	:\		: lnum</B>

You should always put a space before the '<A HREF="cmdline.html#:">:</A>', otherwise <A HREF="motion.html#it">it</A> can be mistaken for
use in a variable such <A HREF="motion.html#as">as</A> &quot;<A HREF="#a:1">a:1</A>&quot;.

<B><FONT COLOR="PURPLE">Falsy operator </FONT></B>

This is also known <A HREF="motion.html#as">as</A> the &quot;<A HREF="vim9.html#null">null</A> coalescing operator&quot;, but that's too
complicated, thus we just call <A HREF="motion.html#it">it</A> the <A HREF="#falsy">falsy</A> <A HREF="motion.html#operator">operator</A>.

The <A HREF="#expression">expression</A> before the '<A HREF="#??">??</A>' is evaluated.  If <A HREF="motion.html#it">it</A> evaluates to
|<A HREF="#truthy">truthy</A>|, this is used <A HREF="motion.html#as">as</A> the result.  Otherwise the <A HREF="#expression">expression</A> after the '<A HREF="#??">??</A>'
is evaluated and used <A HREF="motion.html#as">as</A> the result.  This is most useful to have a default
value for an <A HREF="#expression">expression</A> that may result in zero or empty:
<B>	echo theList ?? 'list is empty'</B>
<B>	echo GetName() ?? 'unknown'</B>

These are similar, but not equal:
<B>	expr2 ?? expr1</B>
<B>	expr2 ? expr2 : expr1</B>
In the second line &quot;<A HREF="#expr2">expr2</A>&quot; is evaluated <A HREF="if_cscop.html#twice">twice</A>.  And in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the type
of <A HREF="#expr2">expr2</A> before &quot;<A HREF="pattern.html#?">?</A>&quot; must be a <A HREF="options.html#boolean">boolean</A>.



<A HREF="#expr2">expr2</A> and <A HREF="#expr3">expr3</A>						*<A NAME="expr2"></A><B>expr2</B>* *<A NAME="expr3"></A><B>expr3</B>*


<A HREF="#expr3">expr3</A> &#124;&#124; <A HREF="#expr3">expr3</A> ..	logical OR		*<A NAME="expr-barbar"></A><B>expr-barbar</B>*

<A HREF="#expr4">expr4</A> &amp;&amp; <A HREF="#expr4">expr4</A> ..	logical AND		*<A NAME="expr-&amp;&amp;"></A><B>expr-&amp;&amp;</B>*

The &quot;&#124;&#124;&quot; and &quot;&amp;&amp;&quot; operators take one argument on each side.

In legacy <A HREF="usr_41.html#script">script</A> the arguments are (converted to) Numbers.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the values must be boolean, see |<A HREF="vim9.html#vim9-boolean">vim9-boolean</A>|.  Use &quot;<A HREF="change.html#!!">!!</A>&quot; to
convert any type to a <A HREF="options.html#boolean">boolean</A>.

The result is:
<B><FONT COLOR="PURPLE">    input			 output </FONT></B>
<B><FONT COLOR="PURPLE">n1	n2		n1 || n2	n1 &amp;&amp; n2 </FONT></B>
|<A HREF="#FALSE">FALSE</A>|	|<A HREF="#FALSE">FALSE</A>|		|<A HREF="#FALSE">FALSE</A>|		|<A HREF="#FALSE">FALSE</A>|
|<A HREF="#FALSE">FALSE</A>|	|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#FALSE">FALSE</A>|
|<A HREF="#TRUE">TRUE</A>|	|<A HREF="#FALSE">FALSE</A>|		|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#FALSE">FALSE</A>|
|<A HREF="#TRUE">TRUE</A>|	|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#TRUE">TRUE</A>|

The operators can be concatenated, for example:

<B>	&amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</B>

Note that &quot;&amp;&amp;&quot; takes precedence over &quot;&#124;&#124;&quot;, so this has the meaning of:

<B>	&amp;nu || (&amp;list &amp;&amp; &amp;shell == "csh")</B>

Once the result is known, the <A HREF="#expression">expression</A> &quot;short-circuits&quot;, that is, further
arguments are not evaluated.  This is like what happens in C.  For example:

<B>	let a = 1</B>
<B>	echo a || b</B>

This is valid even if there is no variable called &quot;<A HREF="motion.html#b">b</A>&quot; because &quot;<A HREF="insert.html#a">a</A>&quot; is |<A HREF="#TRUE">TRUE</A>|,
so the result must be |<A HREF="#TRUE">TRUE</A>|.  Similarly below:

<B>	echo exists("b") &amp;&amp; b == "yes"</B>

This is valid whether &quot;<A HREF="motion.html#b">b</A>&quot; has been defined or not.  The second clause will
only be evaluated if &quot;<A HREF="motion.html#b">b</A>&quot; has been defined.



<A HREF="#expr4">expr4</A>							*<A NAME="expr4"></A><B>expr4</B>* *<A NAME="E1153"></A><B>E1153</B>*

<A HREF="#expr5">expr5</A> {cmp} <A HREF="#expr5">expr5</A>

Compare two <A HREF="#expr5">expr5</A> expressions.  In legacy <A HREF="usr_41.html#script">script</A> the result is a 0 if <A HREF="motion.html#it">it</A>
evaluates to <A HREF="vim9.html#false">false</A>, or 1 if <A HREF="motion.html#it">it</A> evaluates to <A HREF="vim9.html#true">true</A>.  In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the result
is |<A HREF="vim9.html#true">true</A>| or |<A HREF="vim9.html#false">false</A>|.


			*<A NAME="expr-=="></A><B>expr-==</B>*  *<A NAME="expr-!="></A><B>expr-!=</B>*  *<A NAME="expr-&gt;"></A><B>expr-&gt;</B>*	 *<A NAME="expr-&gt;="></A><B>expr-&gt;=</B>*

			*<A NAME="expr-&lt;"></A><B>expr-&lt;</B>*   *<A NAME="expr-&lt;="></A><B>expr-&lt;=</B>*  *<A NAME="expr-=~"></A><B>expr-=~</B>*  *<A NAME="expr-!~"></A><B>expr-!~</B>*

			*<A NAME="expr-==#"></A><B>expr-==#</B>* *<A NAME="expr-!=#"></A><B>expr-!=#</B>* *<A NAME="expr-&gt;#"></A><B>expr-&gt;#</B>*  *<A NAME="expr-&gt;=#"></A><B>expr-&gt;=#</B>*

			*<A NAME="expr-&lt;#"></A><B>expr-&lt;#</B>*  *<A NAME="expr-&lt;=#"></A><B>expr-&lt;=#</B>* *<A NAME="expr-=~#"></A><B>expr-=~#</B>* *<A NAME="expr-!~#"></A><B>expr-!~#</B>*

			*<A NAME="expr-==?"></A><B>expr-==?</B>* *<A NAME="expr-!=?"></A><B>expr-!=?</B>* *<A NAME="expr-&gt;?"></A><B>expr-&gt;?</B>*  *<A NAME="expr-&gt;=?"></A><B>expr-&gt;=?</B>*

			*<A NAME="expr-&lt;?"></A><B>expr-&lt;?</B>*  *<A NAME="expr-&lt;=?"></A><B>expr-&lt;=?</B>* *<A NAME="expr-=~?"></A><B>expr-=~?</B>* *<A NAME="expr-!~?"></A><B>expr-!~?</B>*

			*<A NAME="expr-is"></A><B>expr-is</B>* *<A NAME="expr-isnot"></A><B>expr-isnot</B>* *<A NAME="expr-is#"></A><B>expr-is#</B>* *<A NAME="expr-isnot#"></A><B>expr-isnot#</B>*

			*<A NAME="expr-is?"></A><B>expr-is?</B>* *<A NAME="expr-isnot?"></A><B>expr-isnot?</B>* *<A NAME="E1072"></A><B>E1072</B>*
<B><FONT COLOR="PURPLE">		use 'ignorecase'    match case	   ignore case </FONT></B>
equal			<A HREF="change.html#==">==</A>		==#		<A HREF="change.html#==">==</A>?
not equal		!=		!=#		!=?
greater than		<A HREF="change.html#&gt;">&gt;</A>		&gt;#		<A HREF="change.html#&gt;">&gt;</A>?
greater than or equal	&gt;=		&gt;=#		&gt;=?
smaller than		<A HREF="change.html#&lt;">&lt;</A>		&lt;#		<A HREF="change.html#&lt;">&lt;</A>?
smaller than or equal	&lt;=		&lt;=#		&lt;=?
<A HREF="pattern.html#regexp">regexp</A> matches		=~		=~#		=~?
<A HREF="pattern.html#regexp">regexp</A> doesn't match	!~		!~#		!~?
same instance		is		is#		is?
different instance	isnot		isnot#		isnot?

Examples:
&quot;abc&quot; ==# &quot;Abc&quot;	  evaluates to 0
&quot;abc&quot; <A HREF="change.html#==">==</A>? &quot;Abc&quot;	  evaluates to 1
&quot;abc&quot; <A HREF="change.html#==">==</A> &quot;Abc&quot;	  evaluates to 1 if <A HREF="options.html#'ignorecase'">'ignorecase'</A> is set, 0 otherwise
NOTE: In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> <A HREF="options.html#'ignorecase'">'ignorecase'</A> is not used.


							*<A NAME="E691"></A><B>E691</B>* *<A NAME="E692"></A><B>E692</B>*
A |<A HREF="#List">List</A>| can only be compared with a |<A HREF="#List">List</A>| and only &quot;equal&quot;, &quot;not equal&quot;,
&quot;is&quot; and &quot;isnot&quot; can be used.  This compares the values of the <A HREF="#list">list</A>,
recursively.  Ignoring <A HREF="change.html#case">case</A> means <A HREF="change.html#case">case</A> is ignored when comparing item values.


							*<A NAME="E735"></A><B>E735</B>* *<A NAME="E736"></A><B>E736</B>*
A |<A HREF="#Dictionary">Dictionary</A>| can only be compared with a |<A HREF="#Dictionary">Dictionary</A>| and only &quot;equal&quot;, &quot;not
equal&quot;, &quot;is&quot; and &quot;isnot&quot; can be used.  This compares the key/values of the
|<A HREF="#Dictionary">Dictionary</A>| recursively.  Ignoring <A HREF="change.html#case">case</A> means <A HREF="change.html#case">case</A> is ignored when comparing
item values.


							*<A NAME="E694"></A><B>E694</B>*
A |<A HREF="#Funcref">Funcref</A>| can only be compared with a |<A HREF="#Funcref">Funcref</A>| and only &quot;equal&quot;, &quot;not
equal&quot;, &quot;is&quot; and &quot;isnot&quot; can be used.  Case is never ignored.  Whether
arguments or a <A HREF="#Dictionary">Dictionary</A> are bound (with a <A HREF="builtin.html#partial">partial</A>) matters.  The
<A HREF="#Dictionaries">Dictionaries</A> must also be equal (or the same, in <A HREF="change.html#case">case</A> of &quot;is&quot;) and the
arguments must be equal (or the same).

To compare Funcrefs to see if they refer to the same function, ignoring bound
<A HREF="#Dictionary">Dictionary</A> and arguments, use |<A HREF="builtin.html#get()">get()</A>| to get the function name:
<B>	if get(Part1, 'name') == get(Part2, 'name')</B>
<B>	   " Part1 and Part2 refer to the same function</B>

 							*<A NAME="E1037"></A><B>E1037</B>*
Using &quot;is&quot; or &quot;isnot&quot; with a |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>| checks whether
the expressions are referring to the same |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>|
instance.  A copy of a |<A HREF="#List">List</A>| is different from the original |<A HREF="#List">List</A>|.  When
using &quot;is&quot; without a |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>|, <A HREF="motion.html#it">it</A> is equivalent to
using &quot;equal&quot;, using &quot;isnot&quot; equivalent to using &quot;not equal&quot;.  Except that
a different type means the values are different:
<B>	echo 4 == '4'</B>
<B>	1</B>
<B>	echo 4 is '4'</B>
<B>	0</B>
<B>	echo 0 is []</B>
<B>	0</B>
&quot;is#&quot;/&quot;isnot#&quot; and &quot;is?&quot;/&quot;isnot?&quot; can be used to match and ignore <A HREF="change.html#case">case</A>.

In legacy <A HREF="usr_41.html#script">script</A>, when comparing a <A HREF="#String">String</A> with a <A HREF="#Number">Number</A>, the <A HREF="#String">String</A> is
converted to a <A HREF="#Number">Number</A>, and the comparison is done on Numbers.  This means
that:
<B>	echo 0 == 'x'</B>
<B>	1</B>
because '<A HREF="change.html#x">x</A>' converted to a <A HREF="#Number">Number</A> is zero.  However:
<B>	echo [0] == ['x']</B>
<B>	0</B>
Inside a <A HREF="#List">List</A> or <A HREF="#Dictionary">Dictionary</A> this conversion is not used.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the types must match.

When comparing two Strings, this is done with strcmp() or stricmp().  This
results in the mathematical difference (comparing byte values), not
necessarily the alphabetical difference in the local language.

When using the operators with a trailing '<A HREF="pattern.html##">#</A>', or the short version and
<A HREF="options.html#'ignorecase'">'ignorecase'</A> is off, the comparing is done with strcmp(): <A HREF="change.html#case">case</A> matters.

When using the operators with a trailing '<A HREF="pattern.html#?">?</A>', or the short version and
<A HREF="options.html#'ignorecase'">'ignorecase'</A> is set, the comparing is done with stricmp(): <A HREF="change.html#case">case</A> is ignored.

<A HREF="options.html#'smartcase'">'smartcase'</A> is not used.

The &quot;=~&quot; and &quot;!~&quot; operators match the lefthand argument with the righthand
argument, which is used <A HREF="motion.html#as">as</A> a pattern.  See |<A HREF="pattern.html#pattern">pattern</A>| for what a pattern is.
This matching is always done like <A HREF="options.html#'magic'">'magic'</A> was set and <A HREF="options.html#'cpoptions'">'cpoptions'</A> is empty, no
matter what the actual value of <A HREF="options.html#'magic'">'magic'</A> or <A HREF="options.html#'cpoptions'">'cpoptions'</A> is.  This makes scripts
portable.  To avoid backslashes in the <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A> to be doubled, use a
single-quote string, see |<A HREF="#literal-string">literal-string</A>|.
Since a <A HREF="#string">string</A> is considered to be a single line, a multi-line <A HREF="pattern.html#pattern">pattern</A>
(containing \n, backslash-n) will not match.  However, a literal NL character
can be matched like an ordinary character.  Examples:
	&quot;foo\nbar&quot; =~ &quot;\n&quot;	evaluates to 1
	&quot;foo\nbar&quot; =~ &quot;\\n&quot;	evaluates to 0



<A HREF="#expr5">expr5</A>						*<A NAME="expr5"></A><B>expr5</B>* *<A NAME="bitwise-shift"></A><B>bitwise-shift</B>*

<A HREF="#expr6">expr6</A> <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> <A HREF="#expr6">expr6</A>	bitwise left <A HREF="intro.html#shift">shift</A>				*<A NAME="expr-&lt;&lt;"></A><B>expr-&lt;&lt;</B>*

<A HREF="#expr6">expr6</A> <A HREF="change.html#&gt;&gt;">&gt;&gt;</A> <A HREF="#expr6">expr6</A>	bitwise right <A HREF="intro.html#shift">shift</A>				*<A NAME="expr-&gt;&gt;"></A><B>expr-&gt;&gt;</B>*

							*<A NAME="E1282"></A><B>E1282</B>* *<A NAME="E1283"></A><B>E1283</B>*
The &quot;<A HREF="change.html#&lt;&lt;">&lt;&lt;</A>&quot; and &quot;<A HREF="change.html#&gt;&gt;">&gt;&gt;</A>&quot; operators can be used to perform bitwise left or right <A HREF="intro.html#shift">shift</A>
of the left operand by the number of bits specified by the right operand.  The
operands are used <A HREF="motion.html#as">as</A> positive numbers.  When shifting right with &quot;<A HREF="change.html#&gt;&gt;">&gt;&gt;</A>&quot; the
topmost bit (sometimes called the sign bit) is cleared.  If the right operand
(shift amount) is more than the maximum number of bits in a number
(|<A HREF="#v:numbersize">v:numbersize</A>|) the result is zero.



<A HREF="#expr6">expr6</A> and <A HREF="#expr7">expr7</A>				*<A NAME="expr6"></A><B>expr6</B>* *<A NAME="expr7"></A><B>expr7</B>* *<A NAME="E1036"></A><B>E1036</B>* *<A NAME="E1051"></A><B>E1051</B>*

<A HREF="#expr7">expr7</A> + <A HREF="#expr7">expr7</A>   <A HREF="#Number">Number</A> addition, |<A HREF="#List">List</A>| or |<A HREF="#Blob">Blob</A>| concatenation	*<A NAME="expr-+"></A><B>expr-+</B>*

<A HREF="#expr7">expr7</A> - <A HREF="#expr7">expr7</A>   <A HREF="#Number">Number</A> subtraction				*<A NAME="expr--"></A><B>expr--</B>*

<A HREF="#expr7">expr7</A> . <A HREF="#expr7">expr7</A>   <A HREF="#String">String</A> concatenation				*<A NAME="expr-."></A><B>expr-.</B>*

<A HREF="#expr7">expr7</A> .. <A HREF="#expr7">expr7</A>  <A HREF="#String">String</A> concatenation				*<A NAME="expr-.."></A><B>expr-..</B>*

For |<A HREF="#Lists">Lists</A>| only &quot;<A HREF="motion.html#+">+</A>&quot; is possible and then both <A HREF="#expr7">expr7</A> must be a <A HREF="#list">list</A>.  The
result is a new <A HREF="#list">list</A> with the two lists Concatenated.

For <A HREF="#String">String</A> concatenation &quot;..&quot; is preferred, since &quot;<A HREF="repeat.html#.">.</A>&quot; is ambiguous, <A HREF="motion.html#it">it</A> is also
used for |<A HREF="#Dict">Dict</A>| member access and floating point numbers.
In |<A HREF="vim9.html#Vim9">Vim9</A>| script and when |<A HREF="#vimscript-version">vimscript-version</A>| is 2 or higher, using &quot;<A HREF="repeat.html#.">.</A>&quot; is not
allowed.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the arguments of &quot;..&quot; are converted to <A HREF="#String">String</A> for simple
types: <A HREF="#Number">Number</A>, <A HREF="#Float">Float</A>, <A HREF="#Special">Special</A> and Bool.  For other types |<A HREF="builtin.html#string()">string()</A>| should be
used.


<A HREF="#expr8">expr8</A> &#42; <A HREF="#expr8">expr8</A>  <A HREF="#Number">Number</A> multiplication				*<A NAME="expr-star"></A><B>expr-star</B>*

<A HREF="#expr8">expr8</A> / <A HREF="#expr8">expr8</A>  <A HREF="#Number">Number</A> division					*<A NAME="expr-/"></A><B>expr-/</B>*

<A HREF="#expr8">expr8</A> <A HREF="motion.html#&#37;">&#37;</A> <A HREF="#expr8">expr8</A>  <A HREF="#Number">Number</A> modulo					*<A NAME="expr-&#37;"></A><B>expr-&#37;</B>*

In legacy <A HREF="usr_41.html#script">script</A>, for all operators except &quot;<A HREF="repeat.html#.">.</A>&quot; and &quot;..&quot;, Strings are converted
to Numbers.

For bitwise operators see |<A HREF="builtin.html#and()">and()</A>|, |<A HREF="builtin.html#or()">or()</A>| and |<A HREF="builtin.html#xor()">xor()</A>|.

Note the difference between &quot;<A HREF="motion.html#+">+</A>&quot; and &quot;..&quot; in legacy <A HREF="usr_41.html#script">script</A>:
	&quot;123&quot; + &quot;456&quot; = 579
	&quot;123&quot; .. &quot;456&quot; = &quot;123456&quot;

Since '..' has the same precedence <A HREF="motion.html#as">as</A> '<A HREF="motion.html#+">+</A>' and '<A HREF="motion.html#-">-</A>', you need to read:
<B>	1 .. 90 + 90.0</B>
As:
<B>	(1 .. 90) + 90.0</B>
That works in legacy <A HREF="usr_41.html#script">script</A>, since the <A HREF="#String">String</A> &quot;190&quot; is automatically converted
to the <A HREF="#Number">Number</A> 190, which can be added to the <A HREF="#Float">Float</A> 90.0.  However:
<B>	1 .. 90 * 90.0</B>
Should be read <A HREF="motion.html#as">as</A>:
<B>	1 .. (90 * 90.0)</B>
Since '..' has lower precedence than '*'.  This does NOT work, since this
attempts to concatenate a <A HREF="#Float">Float</A> and a <A HREF="#String">String</A>.

When dividing a <A HREF="#Number">Number</A> by zero the result depends on the value:
	  0 / 0  = -0x80000000	(like NaN for <A HREF="#Float">Float</A>)
	 &gt;0 / 0  =  0x7fffffff	(like positive infinity)
	 &lt;0 / 0  = -0x7fffffff	(like negative infinity)
	(before Vim 7.2 <A HREF="motion.html#it">it</A> was always 0x7fffffff)

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> dividing a number by zero is an error.	*<A NAME="E1154"></A><B>E1154</B>*

When 64-bit <A HREF="#Number">Number</A> support is enabled:
	  0 / 0  = -0x8000000000000000	(like NaN for <A HREF="#Float">Float</A>)
	 &gt;0 / 0  =  0x7fffffffffffffff	(like positive infinity)
	 &lt;0 / 0  = -0x7fffffffffffffff	(like negative infinity)

When the righthand side of '<A HREF="motion.html#&#37;">&#37;</A>' is zero, the result is 0.

<A HREF="#None">None</A> of these work for |<A HREF="#Funcref">Funcref</A>|<A HREF="change.html#s">s</A>.


&quot;<A HREF="repeat.html#.">.</A>&quot;, &quot;..&quot; and &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; <A HREF="diff.html#do">do</A> not work for <A HREF="#Float">Float</A>. *<A NAME="E804"></A><B>E804</B>* *<A NAME="E1035"></A><B>E1035</B>*



<A HREF="#expr8">expr8</A>							*<A NAME="expr8"></A><B>expr8</B>*
&lt;type&gt;expr9

This is only available in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A>, see |<A HREF="vim9.html#type-casting">type-casting</A>|.



<A HREF="#expr9">expr9</A>							*<A NAME="expr9"></A><B>expr9</B>*

! <A HREF="#expr9">expr9</A>			logical NOT		*<A NAME="expr-!"></A><B>expr-!</B>*

- <A HREF="#expr9">expr9</A>			unary minus		*<A NAME="expr-unary--"></A><B>expr-unary--</B>*

+ <A HREF="#expr9">expr9</A>			unary plus		*<A NAME="expr-unary-+"></A><B>expr-unary-+</B>*

For '<A HREF="change.html#!">!</A>' |<A HREF="#TRUE">TRUE</A>| becomes |<A HREF="#FALSE">FALSE</A>|, |<A HREF="#FALSE">FALSE</A>| becomes |<A HREF="#TRUE">TRUE</A>| (one).
For '<A HREF="motion.html#-">-</A>' the sign of the number is changed.
For '<A HREF="motion.html#+">+</A>' the number is unchanged.  Note: &quot;++&quot; has no effect.

In legacy <A HREF="usr_41.html#script">script</A> a <A HREF="#String">String</A> will be converted to a <A HREF="#Number">Number</A> first.  Note that if
the <A HREF="#string">string</A> does not start with a digit you likely don't get what you expect.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an error is given when &quot;<A HREF="motion.html#-">-</A>&quot; or &quot;<A HREF="motion.html#+">+</A>&quot; is used and the type is not
a number.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> &quot;<A HREF="change.html#!">!</A>&quot; can be used for any type and the result is always a
<A HREF="options.html#boolean">boolean</A>.  Use &quot;<A HREF="change.html#!!">!!</A>&quot; to convert any type to a <A HREF="options.html#boolean">boolean</A>, according to whether the
value is |<A HREF="#falsy">falsy</A>|.

These three can be repeated and mixed.  Examples:
	!-1	    <A HREF="change.html#==">==</A> 0
	!!8	    <A HREF="change.html#==">==</A> 1
	--9	    <A HREF="change.html#==">==</A> 9



<A HREF="#expr10">expr10</A>							*<A NAME="expr10"></A><B>expr10</B>*
This <A HREF="#expression">expression</A> is either |<A HREF="#expr11">expr11</A>| or a sequence of the alternatives below,
in any order.  E.g., these are all possible:
	expr10[expr1].name
	expr10.name[expr1]
	expr10(expr1, ...)[expr1].name
	expr10-&gt;(expr1, ...)[expr1]
Evaluation is always from left to right.


expr10[expr1]		item of <A HREF="#String">String</A> or |<A HREF="#List">List</A>|	*<A NAME="expr-[]"></A><B>expr-[]</B>* *<A NAME="E111"></A><B>E111</B>*

						*<A NAME="E909"></A><B>E909</B>* *<A NAME="subscript"></A><B>subscript</B>* *<A NAME="E1062"></A><B>E1062</B>*
In legacy Vim <A HREF="usr_41.html#script">script</A>:
If <A HREF="#expr10">expr10</A> is a <A HREF="#Number">Number</A> or <A HREF="#String">String</A> this results in a <A HREF="#String">String</A> that contains the
expr1'th single byte from <A HREF="#expr10">expr10</A>.  <A HREF="#expr10">expr10</A> is used <A HREF="motion.html#as">as</A> a <A HREF="#String">String</A> (a number is
automatically converted to a String), <A HREF="#expr1">expr1</A> <A HREF="motion.html#as">as</A> a <A HREF="#Number">Number</A>.  This doesn't
recognize <A HREF="mbyte.html#multibyte">multibyte</A> encodings, see `byteidx()` for an alternative, or use
`split()` to turn the <A HREF="#string">string</A> into a <A HREF="#list">list</A> of characters.  Example, to get the
byte under the cursor:
<B>	:let c = getline(".")[col(".") - 1]</B>


In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A>:					*<A NAME="E1147"></A><B>E1147</B>* *<A NAME="E1148"></A><B>E1148</B>*
If <A HREF="#expr10">expr10</A> is a <A HREF="#String">String</A> this results in a <A HREF="#String">String</A> that contains the expr1'th
single character (including any composing characters) from <A HREF="#expr10">expr10</A>.  To use byte
indexes use |<A HREF="builtin.html#strpart()">strpart()</A>|.

Index zero gives the first byte or character.  Careful: text column numbers
start with one!

If the length of the <A HREF="#String">String</A> is <A HREF="various.html#less">less</A> than the index, the result is an empty
<A HREF="#String">String</A>.  A negative index always results in an empty <A HREF="#string">string</A> (reason: backward
compatibility).  Use [-1:] to get the last byte or character.
In <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> a negative index is used like with a <A HREF="#list">list</A>: <A HREF="intro.html#count">count</A> from the end.

If <A HREF="#expr10">expr10</A> is a |<A HREF="#List">List</A>| then <A HREF="motion.html#it">it</A> results the item at index <A HREF="#expr1">expr1</A>.  See |<A HREF="#list-index">list-index</A>|
for possible index values.  If the index is out of range this results in an
error.  Example:
<B>	:let item = mylist[-1]		" get last item</B>

Generally, if a |<A HREF="#List">List</A>| index is equal to or higher than the length of the
|<A HREF="#List">List</A>|, or more negative than the length of the |<A HREF="#List">List</A>|, this results in an
error.



expr10[expr1a : expr1b]	<A HREF="#substring">substring</A> or |<A HREF="#sublist">sublist</A>|		*<A NAME="expr-[:]"></A><B>expr-[:]</B>* *<A NAME="substring"></A><B>substring</B>*

If <A HREF="#expr10">expr10</A> is a <A HREF="#String">String</A> this results in the <A HREF="#substring">substring</A> with the bytes or
characters from expr1a to and including expr1b.  <A HREF="#expr10">expr10</A> is used <A HREF="motion.html#as">as</A> a <A HREF="#String">String</A>,
expr1a and expr1b are used <A HREF="motion.html#as">as</A> a <A HREF="#Number">Number</A>.

In legacy Vim <A HREF="usr_41.html#script">script</A> the indexes are byte indexes.  This doesn't recognize
<A HREF="mbyte.html#multibyte">multibyte</A> encodings, see |<A HREF="builtin.html#byteidx()">byteidx()</A>| for computing the indexes.  If <A HREF="#expr10">expr10</A> is
a <A HREF="#Number">Number</A> <A HREF="motion.html#it">it</A> is first converted to a <A HREF="#String">String</A>.

In <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> the indexes are character indexes and include composing
characters.  To use byte indexes use |<A HREF="builtin.html#strpart()">strpart()</A>|.  To use character indexes
without including composing characters use |<A HREF="builtin.html#strcharpart()">strcharpart()</A>|.

The item at index expr1b is included, <A HREF="motion.html#it">it</A> is <A HREF="motion.html#inclusive">inclusive</A>.  For an <A HREF="motion.html#exclusive">exclusive</A> index
use the |<A HREF="builtin.html#slice()">slice()</A>| function.

If expr1a is omitted zero is used.  If expr1b is omitted the length of the
<A HREF="#string">string</A> minus one is used.

A negative number can be used to measure from the end of the <A HREF="#string">string</A>.  -1 is
the last character, -2 the last but one, etc.

If an index goes out of range for the <A HREF="#string">string</A> characters are omitted.  If
expr1b is smaller than expr1a the result is an empty <A HREF="#string">string</A>.

Examples:
<B>	:let c = name[-1:]		" last byte of a string</B>
<B>	:let c = name[0:-1]		" the whole string</B>
<B>	:let c = name[-2:-2]		" last but one byte of a string</B>
<B>	:let s = line(".")[4:]		" from the fifth byte to the end</B>
<B>	:let s = s[:-3]			" remove last two bytes</B>
 

							*<A NAME="slice"></A><B>slice</B>*
If <A HREF="#expr10">expr10</A> is a |<A HREF="#List">List</A>| this results in a new |<A HREF="#List">List</A>| with the items indicated by
the indexes expr1a and expr1b.  This works like with a <A HREF="#String">String</A>, <A HREF="motion.html#as">as</A> explained
just above. Also see |<A HREF="#sublist">sublist</A>| below.  Examples:
<B>	:let l = mylist[:3]		" first four items</B>
<B>	:let l = mylist[4:4]		" List with one item</B>
<B>	:let l = mylist[:]		" shallow copy of a List</B>

If <A HREF="#expr10">expr10</A> is a |<A HREF="#Blob">Blob</A>| this results in a new |<A HREF="#Blob">Blob</A>| with the bytes in the
indexes expr1a and expr1b, <A HREF="motion.html#inclusive">inclusive</A>.  Examples:
<B>	:let b = 0zDEADBEEF</B>
<B>	:let bs = b[1:2]		" 0zADBE</B>
<B>	:let bs = b[:]			" copy of 0zDEADBEEF</B>

Using expr10[expr1] or expr10[expr1a : expr1b] on a |<A HREF="#Funcref">Funcref</A>| results in an
error.

Watch out for confusion between a namespace and a variable followed by a colon
for a <A HREF="#sublist">sublist</A>:
<B>	mylist[n:]     " uses variable n</B>
<B>	mylist[s:]     " uses namespace s:, error!</B>



expr10.name		entry in a |<A HREF="#Dictionary">Dictionary</A>|		*<A NAME="expr-entry"></A><B>expr-entry</B>*

							*<A NAME="E1203"></A><B>E1203</B>* *<A NAME="E1229"></A><B>E1229</B>*
If <A HREF="#expr10">expr10</A> is a |<A HREF="#Dictionary">Dictionary</A>| and <A HREF="motion.html#it">it</A> is followed by a dot, then the following
name will be used <A HREF="motion.html#as">as</A> a key in the |<A HREF="#Dictionary">Dictionary</A>|.  This is just like:
expr10[name].

The name must consist of alphanumeric characters, just like a variable name,
but <A HREF="motion.html#it">it</A> may start with a number.  Curly braces cannot be used.

There must not be white space before or after the dot.

Examples:
<B>	:let dict = {"one": 1, 2: "two"}</B>
<B>	:echo dict.one		" shows "1"</B>
<B>	:echo dict.2		" shows "two"</B>
<B>	:echo dict .2		" error because of space before the dot</B>

Note that the dot is also used for <A HREF="#String">String</A> concatenation.  To avoid confusion
always put spaces around the dot for <A HREF="#String">String</A> concatenation.



expr10(expr1, <A HREF="#...">...</A>)	|<A HREF="#Funcref">Funcref</A>| function call  	*<A NAME="E1085"></A><B>E1085</B>*

When <A HREF="#expr10">expr10</A> is a |<A HREF="#Funcref">Funcref</A>| type variable, invoke the function <A HREF="motion.html#it">it</A> refers to.



expr10-&gt;name([args])	<A HREF="#method">method</A> call			*<A NAME="method"></A><B>method</B>* *<A NAME="-&gt;"></A><B>-&gt;</B>*
expr10-&gt;{lambda}([args])

							*<A NAME="E260"></A><B>E260</B>* *<A NAME="E276"></A><B>E276</B>* *<A NAME="E1265"></A><B>E1265</B>*
For methods that are also available <A HREF="motion.html#as">as</A> global <A HREF="#functions">functions</A> this is the same <A HREF="motion.html#as">as</A>:
<B>	name(expr10 [, args])</B>
There can also be methods specifically for the type of &quot;<A HREF="#expr10">expr10</A>&quot;.

This allows for chaining, passing the value that one <A HREF="#method">method</A> returns to the
next <A HREF="#method">method</A>:
<B>	mylist-&gt;filter(filterexpr)-&gt;map(mapexpr)-&gt;sort()-&gt;join()</B>
 
Example of using a <A HREF="#lambda">lambda</A>:
<B>	GetPercentage()-&gt;{x -&gt; x * 100}()-&gt;printf('%d%%')</B>
 
When using <A HREF="#-&gt;">-&gt;</A> the |<A HREF="#expr9">expr9</A>| operators will be applied first, thus:
<B>	-1.234-&gt;string()</B>
Is equivalent to:
<B>	(-1.234)-&gt;string()</B>
And NOT:
<B>	-(1.234-&gt;string())</B>

What comes after &quot;<A HREF="#-&gt;">-&gt;</A>&quot; can be a name, a simple <A HREF="#expression">expression</A> (not containing any
parenthesis), or any <A HREF="#expression">expression</A> in parentheses:
<B>	base-&gt;name(args)</B>
<B>	base-&gt;some.name(args)</B>
<B>	base-&gt;alist[idx](args)</B>
<B>	base-&gt;(getFuncRef())(args)</B>
Note that in the last call the base is passed to the function resulting from
&quot;(getFuncRef())&quot;, inserted before &quot;args&quot;.


							*<A NAME="E274"></A><B>E274</B>*
&quot;-&gt;name(&quot; must not contain white space.  There can be white space before the
&quot;<A HREF="#-&gt;">-&gt;</A>&quot; and after the &quot;<A HREF="motion.html#(">(</A>&quot;, thus you can split the lines like this:
<B>	mylist</B>
<B>	\ -&gt;filter(filterexpr)</B>
<B>	\ -&gt;map(mapexpr)</B>
<B>	\ -&gt;sort()</B>
<B>	\ -&gt;join()</B>

When using the <A HREF="#lambda">lambda</A> form there must be no white space between the } and the
(.



							*<A NAME="expr11"></A><B>expr11</B>*
number

number			number constant			*<A NAME="expr-number"></A><B>expr-number</B>*


			*<A NAME="0x"></A><B>0x</B>* *<A NAME="hex-number"></A><B>hex-number</B>* *<A NAME="0o"></A><B>0o</B>* *<A NAME="octal-number"></A><B>octal-number</B>* *<A NAME="binary-number"></A><B>binary-number</B>*
Decimal, Hexadecimal (starting with <A HREF="#0x">0x</A> or 0X), Binary (starting with 0b or 0B)
and Octal (starting with 0, <A HREF="#0o">0o</A> or 0O).

Assuming 64 bit numbers are used (see |<A HREF="#v:numbersize">v:numbersize</A>|) an unsigned number is
truncated to 0x7fffffffffffffff or 9223372036854775807.  You can use -1 to get
0xffffffffffffffff.


						*<A NAME="floating-point-format"></A><B>floating-point-format</B>*
Floating point numbers can be written in two forms:

	[-+]{N}.{M}
	[-+]{N}.{M}[eE][-+]{exp}

{N} and {M} are numbers.  Both {N} and {M} must be present and can only
contain digits, except that in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> in {N} single <A HREF="quotes.html#quotes">quotes</A> between
digits are ignored.
[-+] means there is an optional plus or minus sign.
{exp} is the exponent, power of 10.
Only a decimal point is accepted, not a comma.  No matter what the current
<A HREF="mbyte.html#locale">locale</A> is.
{only when compiled with the |<A HREF="various.html#+float">+float</A>| feature}

Examples:
	123.456
	+0.0001
	55.0
	-0.123
	1.234e03
	1.0E-6
	-3.1416e+88

These are INVALID:
	3.		empty {M}
	1e40		missing .{M}

Rationale:
Before floating point was introduced, the text &quot;123.456&quot; was interpreted <A HREF="motion.html#as">as</A>
the two numbers &quot;123&quot; and &quot;456&quot;, both converted to a <A HREF="#string">string</A> and concatenated,
resulting in the <A HREF="#string">string</A> &quot;123456&quot;.  Since this was considered pointless, and we
could not find <A HREF="motion.html#it">it</A> intentionally being used in Vim scripts, this backwards
incompatibility was accepted in favor of being able to use the normal <A HREF="intro.html#notation">notation</A>
for floating point numbers.


							*<A NAME="float-pi"></A><B>float-pi</B>* *<A NAME="float-e"></A><B>float-e</B>*
A few useful values to copy&amp;paste:
<B>	:let pi = 3.14159265359</B>
<B>	:let e  = 2.71828182846</B>
Or, if you don't want to write them in <A HREF="motion.html#as">as</A> floating-point literals, you can
also use <A HREF="#functions">functions</A>, like the following:
<B>	:let pi = acos(-1.0)</B>
<B>	:let e  = exp(1.0)</B>
 

						*<A NAME="floating-point-precision"></A><B>floating-point-precision</B>*
The precision and range of floating points numbers depends on what &quot;double&quot;
means in the library Vim was compiled with.  There is no way to change this at
runtime.

The default for displaying a |<A HREF="#Float">Float</A>| is to use 6 decimal places, like using
printf(&quot;&#37;g&quot;, <A HREF="motion.html#f">f</A>f).  You can select something else when using the |<A HREF="builtin.html#printf()">printf()</A>|
function.  Example:
<B>	:echo printf('%.15e', atan(1))</B>
 	7.853981633974483e-01




<A HREF="#string">string</A>					*<A NAME="string"></A><B>string</B>* *<A NAME="String"></A><B>String</B>* *<A NAME="expr-string"></A><B>expr-string</B>* *<A NAME="E114"></A><B>E114</B>*

&quot;<A HREF="#string">string</A>&quot;		<A HREF="#string">string</A> constant		*<A NAME="expr-quote"></A><B>expr-quote</B>*

Note that double <A HREF="quotes.html#quotes">quotes</A> are used.

A <A HREF="#string">string</A> constant accepts these special characters:
\...	three-digit <A HREF="#octal">octal</A> number (e.g., &quot;\316&quot;)
\..	two-digit <A HREF="#octal">octal</A> number (must be followed by non-digit)
\.	one-digit <A HREF="#octal">octal</A> number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., &quot;\x1f&quot;)
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same <A HREF="motion.html#as">as</A> \x..
\X.	same <A HREF="motion.html#as">as</A> \x.
\u....	character specified with up to 4 hex numbers, stored according to the
	current value of <A HREF="options.html#'encoding'">'encoding'</A> (e.g., &quot;\u02a4&quot;)
\U....	same <A HREF="motion.html#as">as</A> \u but allows up to 8 hex numbers.
\b	backspace <A HREF="motion.html#&lt;BS&gt;">&lt;BS&gt;</A>
\e	<A HREF="intro.html#escape">escape</A> <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>
\f	formfeed 0x0C
\n	newline <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A>
\r	return <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A>
\t	<A HREF="intro.html#tab">tab</A> <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A>
\\	<A HREF="intro.html#backslash">backslash</A>
\&quot;	double <A HREF="change.html#quote">quote</A>
\&lt;xxx&gt;	<A HREF="#Special">Special</A> key named &quot;xxx&quot;.  e.g. &quot;\&lt;C-W&gt;&quot; for <A HREF="index.html#CTRL-W">CTRL-W</A>.  This is for use
	in mappings, the 0x80 byte is escaped.
	To use the double <A HREF="change.html#quote">quote</A> character <A HREF="motion.html#it">it</A> must be escaped: &quot;&lt;M-\&quot;&gt;&quot;.
	Don't use &lt;Char-xxxx&gt; to get a <A HREF="mbyte.html#UTF-8">UTF-8</A> character, use \uxxxx <A HREF="motion.html#as">as</A>
	mentioned above.
\&lt;*xxx&gt;	Like \&lt;xxx&gt; but prepends a modifier instead of including <A HREF="motion.html#it">it</A> in the
	character.  E.g. &quot;\&lt;C-w&gt;&quot; is one character 0x17 while &quot;\&lt;*C-w&gt;&quot; is four
	bytes: 3 for the CTRL modifier and then character &quot;<A HREF="motion.html#W">W</A>&quot;.

Note that &quot;\xff&quot; is stored <A HREF="motion.html#as">as</A> the byte 255, which may be invalid in some
encodings.  Use &quot;\u00ff&quot; to store character 255 according to the current value
of <A HREF="options.html#'encoding'">'encoding'</A>.

Note that &quot;\000&quot; and &quot;\x00&quot; force the end of the <A HREF="#string">string</A>.



<A HREF="#blob-literal">blob-literal</A>				*<A NAME="blob-literal"></A><B>blob-literal</B>* *<A NAME="E973"></A><B>E973</B>*

Hexadecimal starting with 0z or 0Z, with an arbitrary number of bytes.
The sequence must be an even number of hex characters.  Example:
<B>	:let b = 0zFF00ED015DAF</B>



<A HREF="#literal-string">literal-string</A>						*<A NAME="literal-string"></A><B>literal-string</B>* *<A NAME="E115"></A><B>E115</B>*

'<A HREF="#string">string</A>'		<A HREF="#string">string</A> constant			*<A NAME="expr-'"></A><B>expr-'</B>*

Note that single <A HREF="quotes.html#quotes">quotes</A> are used.

This <A HREF="#string">string</A> is taken <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> is.  No backslashes are removed or have a special
meaning.  The only exception is that two <A HREF="quotes.html#quotes">quotes</A> stand for one <A HREF="change.html#quote.">quote.</A>

Single quoted strings are useful for patterns, so that backslashes <A HREF="diff.html#do">do</A> not need
to be doubled.  These two commands are equivalent:
<B>	if a =~ "\\s*"</B>
<B>	if a =~ '\s*'</B>



interpolated-string				*<A NAME="$quote"></A><B>$quote</B>* *<A NAME="interp-string"></A><B>interp-string</B>* *<A NAME="E256"></A><B>E256</B>*

$&quot;string&quot;		interpolated <A HREF="#string">string</A> constant		*<A NAME="expr-$quote"></A><B>expr-$quote</B>*

$'string'		interpolated literal <A HREF="#string">string</A> constant	*<A NAME="expr-$'"></A><B>expr-$'</B>*

Interpolated strings are an extension of the |<A HREF="#string">string</A>| and |<A HREF="#literal-string">literal-string</A>|,
allowing the <A HREF="helphelp.html#inclusion">inclusion</A> of Vim <A HREF="usr_41.html#script">script</A> expressions (see |<A HREF="#expr1">expr1</A>|).  Any
<A HREF="#expression">expression</A> returning a value can be enclosed between curly braces.  The value
is converted to a <A HREF="#string">string</A>.  All the text and results of the expressions
are concatenated to make a new <A HREF="#string">string</A>.

								*<A NAME="E1278"></A><B>E1278</B>*
To include an opening brace '<A HREF="motion.html#{">{</A>' or closing brace '<A HREF="motion.html#}">}</A>' in the <A HREF="#string">string</A> content
double <A HREF="motion.html#it">it</A>.  For double quoted strings using a <A HREF="intro.html#backslash">backslash</A> also works.  A single
closing brace '<A HREF="motion.html#}">}</A>' will result in an error.

Examples:
<B>	let your_name = input("What's your name? ")</B>
<B><FONT COLOR="PURPLE"> 	What's your name?  Peter </FONT></B>

<B>	echo</B>
<B>	echo $"Hello, {your_name}!"</B>
<B><FONT COLOR="PURPLE"> 	Hello, Peter! </FONT></B>

<B>	echo $"The square root of {{9}} is {sqrt(9)}"</B>
<B><FONT COLOR="PURPLE"> 	The square root of {9} is 3.0 </FONT></B>



option						*<A NAME="expr-option"></A><B>expr-option</B>* *<A NAME="E112"></A><B>E112</B>* *<A NAME="E113"></A><B>E113</B>*
&amp;option			option value, local value if possible
&amp;g:option		global option value
&amp;l:option		local option value

Examples:
<B>	echo "tabstop is " .. &amp;tabstop</B>
<B>	if &amp;insertmode</B>

Any option name can be used here.  See |<A HREF="options.html#options">options</A>|.  When using the local value
and there is no buffer-local or window-local value, the global value is used
anyway.



<A HREF="sponsor.html#register">register</A>						*<A NAME="expr-register"></A><B>expr-register</B>* *<A NAME="@r"></A><B>@r</B>*
<A HREF="#@r">@r</A>			contents of <A HREF="sponsor.html#register">register</A> '<A HREF="change.html#r">r</A>'

The result is the contents of the named <A HREF="sponsor.html#register">register</A>, <A HREF="motion.html#as">as</A> a single <A HREF="#string">string</A>.
Newlines are inserted where required.  To get the contents of the unnamed
register use @&quot; or <A HREF="repeat.html#@@">@@</A>.  See |<A HREF="change.html#registers">registers</A>| for an explanation of the available
<A HREF="change.html#registers">registers</A>.

When using the '<A HREF="change.html#=">=</A>' <A HREF="sponsor.html#register">register</A> you get the <A HREF="#expression">expression</A> itself, not what <A HREF="motion.html#it">it</A>
evaluates to.  Use |<A HREF="builtin.html#eval()">eval()</A>| to evaluate <A HREF="motion.html#it">it</A>.



nesting						*<A NAME="expr-nesting"></A><B>expr-nesting</B>* *<A NAME="E110"></A><B>E110</B>*
(expr1)			nested <A HREF="#expression">expression</A>



environment variable					*<A NAME="expr-env"></A><B>expr-env</B>*
$VAR			environment variable

The <A HREF="#String">String</A> value of any environment variable.  When <A HREF="motion.html#it">it</A> is not defined, the
result is an empty <A HREF="#string">string</A>.

The <A HREF="#functions">functions</A> `getenv()` and `setenv()` can also be used and work for
environment <A HREF="#variables">variables</A> with non-alphanumeric names.
The function `environ()` can be used to get a <A HREF="#Dict">Dict</A> with all environment
<A HREF="#variables">variables</A>.



						*<A NAME="expr-env-expand"></A><B>expr-env-expand</B>*
Note that there is a difference between using $VAR directly and using
expand(&quot;$VAR&quot;).  Using <A HREF="motion.html#it">it</A> directly will only expand environment <A HREF="#variables">variables</A> that
are known inside the current Vim session.  Using <A HREF="builtin.html#expand()">expand()</A> will first try using
the environment <A HREF="#variables">variables</A> known inside the current Vim session.  If that
fails, a shell will be used to expand the variable.  This can be slow, but <A HREF="motion.html#it">it</A>
does expand all <A HREF="#variables">variables</A> that the shell knows about.  Example:
<B>	:echo $shell</B>
<B>	:echo expand("$shell")</B>
The first one probably doesn't echo anything, the second echoes the $shell
variable (if your shell supports <A HREF="motion.html#it">it</A>).



internal variable			*<A NAME="expr-variable"></A><B>expr-variable</B>* *<A NAME="E1015"></A><B>E1015</B>* *<A NAME="E1089"></A><B>E1089</B>*
variable		internal variable
See below |<A HREF="#internal-variables">internal-variables</A>|.



function call		*<A NAME="expr-function"></A><B>expr-function</B>* *<A NAME="E116"></A><B>E116</B>* *<A NAME="E118"></A><B>E118</B>* *<A NAME="E119"></A><B>E119</B>* *<A NAME="E120"></A><B>E120</B>*
function(expr1, <A HREF="#...">...</A>)	function call
See below |<A HREF="#functions">functions</A>|.



<A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>				*<A NAME="expr-lambda"></A><B>expr-lambda</B>* *<A NAME="lambda"></A><B>lambda</B>*

{args <A HREF="#-&gt;">-&gt;</A> expr1}		legacy <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> 		*<A NAME="E451"></A><B>E451</B>*
(args) =&gt; <A HREF="#expr1">expr1</A>		|<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>

A <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> creates a new unnamed function which returns the result of
evaluating |<A HREF="#expr1">expr1</A>|.  Lambda expressions differ from |<A HREF="#user-functions">user-functions</A>| in
the following ways:

1. The body of the <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> is an |<A HREF="#expr1">expr1</A>| and not a sequence of |<A HREF="intro.html#Ex">Ex</A>|
   commands.
2. The prefix &quot;a:&quot; should not be used for arguments.  E.g.:
<B>	:let F = {arg1, arg2 -&gt; arg1 - arg2}</B>
<B>	:echo F(5, 2)</B>
 	3

The arguments are optional.  Example:
<B>	:let F = {-&gt; 'error function'}</B>
<B>	:echo F('ignored')</B>
 	error function

The |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="#lambda">lambda</A> does not only use a different <A HREF="syntax.html#syntax">syntax</A>, <A HREF="motion.html#it">it</A> also adds type
checking and can be split over multiple lines, see |<A HREF="vim9.html#vim9-lambda">vim9-lambda</A>|.


							*<A NAME="closure"></A><B>closure</B>*
Lambda expressions can access outer scope <A HREF="#variables">variables</A> and arguments.  This is
often called a <A HREF="#closure">closure</A>.  Example where &quot;<A HREF="insert.html#i">i</A>&quot; and &quot;a:arg&quot; are used in a <A HREF="#lambda">lambda</A>
while they already exist in the function scope.  They remain valid even after
the function returns:
<B>	:function Foo(arg)</B>
<B>	:  let i = 3</B>
<B>	:  return {x -&gt; x + i - a:arg}</B>
<B>	:endfunction</B>
<B>	:let Bar = Foo(4)</B>
<B>	:echo Bar(6)</B>
 	5

Note that the <A HREF="#variables">variables</A> must exist in the outer scope before the <A HREF="#lambda">lambda</A> is
defined for this to work.  See also |<A HREF="#:func-closure">:func-closure</A>|.

Lambda and <A HREF="#closure">closure</A> support can be checked with:
<B>	if has('lambda')</B>

Examples for using a <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> with |<A HREF="builtin.html#sort()">sort()</A>|, |<A HREF="builtin.html#map()">map()</A>| and |<A HREF="builtin.html#filter()">filter()</A>|:
<B>	:echo map([1, 2, 3], {idx, val -&gt; val + 1})</B>
 	[2, 3, 4]
<B>	:echo sort([3,7,2,1,4], {a, b -&gt; a - b})</B>
 	[1, 2, 3, 4, 7]

The <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> is also useful for <A HREF="#Channel">Channel</A>, <A HREF="#Job">Job</A> and <A HREF="builtin.html#timer">timer</A>:
<B>	:let timer = timer_start(500,</B>
<B>			\ {-&gt; execute("echo 'Handler called'", "")},</B>
<B>			\ {'repeat': 3})</B>
 	Handler called
	Handler called
	Handler called

Note that <A HREF="motion.html#it">it</A> is possible to cause memory to be used and not freed if the
<A HREF="#closure">closure</A> is referenced by the context <A HREF="motion.html#it">it</A> depends on:
<B>	function Function()</B>
<B>	   let x = 0</B>
<B>	   let F = {-&gt; x}</B>
<B>	 endfunction</B>
The <A HREF="#closure">closure</A> uses &quot;<A HREF="change.html#x">x</A>&quot; from the function scope, and &quot;<A HREF="motion.html#F">F</A>&quot; in that same scope
refers to the <A HREF="#closure">closure</A>.  This cycle results in the memory not being freed.
Recommendation: don't <A HREF="diff.html#do">do</A> this.

Notice how <A HREF="builtin.html#execute()">execute()</A> is used to execute an <A HREF="intro.html#Ex">Ex</A> command.  That's ugly though.
In <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> you can use a command block, see |<A HREF="vim9.html#inline-function">inline-function</A>|.

Lambda expressions have internal names like '&lt;lambda&gt;42'.  If you get an error
for a <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>, you can find what <A HREF="motion.html#it">it</A> is with the following command:
<B>	:function &lt;lambda&gt;42</B>
See also: |<A HREF="#numbered-function">numbered-function</A>|

==============================================================================

3. Internal variable			*<A NAME="internal-variables"></A><B>internal-variables</B>* *<A NAME="E461"></A><B>E461</B>* *<A NAME="E1001"></A><B>E1001</B>*

An internal variable name can be made up of letters, digits and '<A HREF="motion.html#_">_</A>'.  But <A HREF="motion.html#it">it</A>
cannot start with a digit.  In legacy <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> is also possible to use curly
braces, see |<A HREF="#curly-braces-names">curly-braces-names</A>|.

In legacy <A HREF="usr_41.html#script">script</A> an internal variable is created with the &quot;<A HREF="#:let">:let</A>&quot; command
|<A HREF="#:let">:let</A>|.  An internal variable is explicitly destroyed with the &quot;<A HREF="#:unlet">:unlet</A>&quot;
command |<A HREF="#:unlet">:unlet</A>|.
Using a name that is not an internal variable or refers to a variable that has
been destroyed results in an error.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:let` is not used and <A HREF="#variables">variables</A> work differently, see |<A HREF="vim9.html#:var">:var</A>|.


						*<A NAME="variable-scope"></A><B>variable-scope</B>*
There are several name spaces for <A HREF="#variables">variables</A>.  Which one is to be used is
specified by what is prepended:

		(nothing) In a function: local to the function;
			  in a legacy <A HREF="usr_41.html#script">script</A>: global;
			  in a |<A HREF="vim9.html#Vim9">Vim9</A>|  <A HREF="usr_41.html#script">script</A>: local to the <A HREF="usr_41.html#script">script</A>
|<A HREF="#buffer-variable">buffer-variable</A>|    <A HREF="#b:">b:</A>	  Local to the current buffer.
|<A HREF="#window-variable">window-variable</A>|    <A HREF="#w:">w:</A>	  Local to the current window.
|<A HREF="#tabpage-variable">tabpage-variable</A>|   <A HREF="#t:">t:</A>	  Local to the current tab page.
|<A HREF="#global-variable">global-variable</A>|    <A HREF="#g:">g:</A>	  Global.
|<A HREF="#local-variable">local-variable</A>|     <A HREF="#l:">l:</A>	  Local to a function (only in a legacy function)
|<A HREF="#script-variable">script-variable</A>|    s:	  Local to a |<A HREF="repeat.html#:source">:source</A>|'ed Vim script.
|<A HREF="#function-argument">function-argument</A>|  a:	  Function argument (only in a legacy function).
|<A HREF="#vim-variable">vim-variable</A>|       <A HREF="#v:">v:</A>	  Global, predefined by Vim.

The scope name by itself can be used <A HREF="motion.html#as">as</A> a |<A HREF="#Dictionary">Dictionary</A>|.  For example, to
delete all <A HREF="map.html#script-local">script-local</A> <A HREF="#variables">variables</A>:
<B>	:for k in keys(s:)</B>
<B>	:    unlet s:[k]</B>
<B>	:endfor</B>

Note: in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A> can also be local to a block of commands, see
|<A HREF="vim9.html#vim9-scopes">vim9-scopes</A>|.

						*<A NAME="buffer-variable"></A><B>buffer-variable</B>* *<A NAME="b:var"></A><B>b:var</B>* *<A NAME="b:"></A><B>b:</B>*
A variable name that is preceded with &quot;<A HREF="#b:">b:</A>&quot; is local to the current buffer.
Thus you can have several &quot;b:foo&quot; <A HREF="#variables">variables</A>, one for each buffer.
This kind of variable is deleted when the buffer is wiped out or deleted with
|<A HREF="windows.html#:bdelete">:bdelete</A>|.

One local buffer variable is predefined:

					*<A NAME="b:changedtick"></A><B>b:changedtick</B>* *<A NAME="changetick"></A><B>changetick</B>*
<A HREF="#b:changedtick">b:changedtick</A>	The total number of changes to the current buffer.  It is
		incremented for each change.  An <A HREF="undo.html#undo">undo</A> command is also a change
		in this <A HREF="change.html#case">case</A>.  Resetting <A HREF="options.html#'modified'">'modified'</A> when <A HREF="editing.html#writing">writing</A> the buffer is
		also counted.
		This can be used to perform an action only when the buffer has
		changed.  Example:
<B>		    :if my_changedtick != b:changedtick</B>
<B>		    :	let my_changedtick = b:changedtick</B>
<B>		    :	call My_Update()</B>
<B>		    :endif</B>
 		You cannot change or delete the <A HREF="#b:changedtick">b:changedtick</A> variable.


						*<A NAME="window-variable"></A><B>window-variable</B>* *<A NAME="w:var"></A><B>w:var</B>* *<A NAME="w:"></A><B>w:</B>*
A variable name that is preceded with &quot;<A HREF="#w:">w:</A>&quot; is local to the current <A HREF="windows.html#window">window</A>.  It
is deleted when the <A HREF="windows.html#window">window</A> is closed.


						*<A NAME="tabpage-variable"></A><B>tabpage-variable</B>* *<A NAME="t:var"></A><B>t:var</B>* *<A NAME="t:"></A><B>t:</B>*
A variable name that is preceded with &quot;<A HREF="#t:">t:</A>&quot; is local to the current <A HREF="intro.html#tab">tab</A> page,
It is deleted when the <A HREF="intro.html#tab">tab</A> page is closed. {not available when compiled
without the |<A HREF="various.html#+windows">+windows</A>| feature}


						*<A NAME="global-variable"></A><B>global-variable</B>* *<A NAME="g:var"></A><B>g:var</B>* *<A NAME="g:"></A><B>g:</B>*
Inside <A HREF="#functions">functions</A> and in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> global <A HREF="#variables">variables</A> are accessed with &quot;<A HREF="#g:">g:</A>&quot;.
Omitting this will access a variable local to a function or <A HREF="usr_41.html#script">script</A>.  &quot;<A HREF="#g:">g:</A>&quot;
can also be used in any other place if you like.


						*<A NAME="local-variable"></A><B>local-variable</B>* *<A NAME="l:var"></A><B>l:var</B>* *<A NAME="l:"></A><B>l:</B>*
Inside <A HREF="#functions">functions</A> local <A HREF="#variables">variables</A> are accessed without prepending anything.
But you can also prepend &quot;<A HREF="#l:">l:</A>&quot; if you like.  However, without prepending &quot;<A HREF="#l:">l:</A>&quot;
you may run into reserved variable names.  For example &quot;<A HREF="intro.html#count">count</A>&quot;.  By itself <A HREF="motion.html#it">it</A>
refers to &quot;<A HREF="#v:count">v:count</A>&quot;.  Using &quot;l:count&quot; you can have a local variable with the
same name.


						*<A NAME="script-variable"></A><B>script-variable</B>* *<A NAME="s:var"></A><B>s:var</B>*
In a legacy Vim <A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A> starting with &quot;s:&quot; can be used.  They cannot
be accessed from outside of the scripts, thus are local to the <A HREF="usr_41.html#script">script</A>.
In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the &quot;s:&quot; prefix can be omitted, <A HREF="#variables">variables</A> are <A HREF="map.html#script-local">script-local</A> by
default.

They can be used in:
- commands executed while the <A HREF="usr_41.html#script">script</A> is sourced
- <A HREF="#functions">functions</A> defined in the <A HREF="usr_41.html#script">script</A>
- <A HREF="autocmd.html#autocommands">autocommands</A> defined in the <A HREF="usr_41.html#script">script</A>
- <A HREF="#functions">functions</A> and <A HREF="autocmd.html#autocommands">autocommands</A> defined in <A HREF="#functions">functions</A> and <A HREF="autocmd.html#autocommands">autocommands</A> which were
  defined in the <A HREF="usr_41.html#script">script</A> (recursively)
- user defined commands defined in the <A HREF="usr_41.html#script">script</A>
Thus not in:
- other scripts sourced from this one
- mappings
- <A HREF="gui.html#menus">menus</A>
- etc.

Script <A HREF="#variables">variables</A> can be used to avoid conflicts with global variable names.
Take this example:

<B>	let s:counter = 0</B>
<B>	function MyCounter()</B>
<B>	  let s:counter = s:counter + 1</B>
<B>	  echo s:counter</B>
<B>	endfunction</B>
<B>	command Tick call MyCounter()</B>

You can now invoke &quot;Tick&quot; from any <A HREF="usr_41.html#script">script</A>, and the &quot;s:counter&quot; variable in
that <A HREF="usr_41.html#script">script</A> will not be changed, only the &quot;s:counter&quot; in the <A HREF="usr_41.html#script">script</A> where
&quot;Tick&quot; was defined is used.

Another example that does the same:

<B>	let s:counter = 0</B>
<B>	command Tick let s:counter = s:counter + 1 | echo s:counter</B>

When calling a function and invoking a user-defined command, the context for
<A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A> is set to the <A HREF="usr_41.html#script">script</A> where the function or command was
defined.

The <A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A> are also available when a function is defined inside a
function that is defined in a <A HREF="usr_41.html#script">script</A>.  Example:

<B>	let s:counter = 0</B>
<B>	function StartCounting(incr)</B>
<B>	  if a:incr</B>
<B>	    function MyCounter()</B>
<B>	      let s:counter = s:counter + 1</B>
<B>	    endfunction</B>
<B>	  else</B>
<B>	    function MyCounter()</B>
<B>	      let s:counter = s:counter - 1</B>
<B>	    endfunction</B>
<B>	  endif</B>
<B>	endfunction</B>

This defines the MyCounter() function either for counting up or counting down
when calling StartCounting().  It doesn't matter from where StartCounting() is
called, the s:counter variable will be accessible in MyCounter().

When the same <A HREF="usr_41.html#script">script</A> is sourced again <A HREF="motion.html#it">it</A> will use the same <A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A>.
They will remain valid <A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> Vim is running.  This can be used to
maintain a counter:

<B>	if !exists("s:counter")</B>
<B>	  let s:counter = 1</B>
<B>	  echo "script executed for the first time"</B>
<B>	else</B>
<B>	  let s:counter = s:counter + 1</B>
<B>	  echo "script executed " .. s:counter .. " times now"</B>
<B>	endif</B>

Note that this means that <A HREF="filetype.html#filetype">filetype</A> plugins don't get a different set of <A HREF="usr_41.html#script">script</A>
<A HREF="#variables">variables</A> for each buffer.  Use local buffer <A HREF="#variables">variables</A> instead |<A HREF="#b:var">b:var</A>|.



PREDEFINED VIM VARIABLES			*<A NAME="vim-variable"></A><B>vim-variable</B>* *<A NAME="v:var"></A><B>v:var</B>* *<A NAME="v:"></A><B>v:</B>*

							*<A NAME="E963"></A><B>E963</B>* *<A NAME="E1063"></A><B>E1063</B>*
Some <A HREF="#variables">variables</A> can be set by the user, but the type cannot be changed.


					*<A NAME="v:argv"></A><B>v:argv</B>* *<A NAME="argv-variable"></A><B>argv-variable</B>*
<A HREF="#v:argv">v:argv</A>		The command line arguments Vim was invoked with.  This is a
		<A HREF="#list">list</A> of strings.  The first item is the Vim command.
		See |<A HREF="#v:progpath">v:progpath</A>| for the command with full path.


					*<A NAME="v:beval_col"></A><B>v:beval_col</B>* *<A NAME="beval_col-variable"></A><B>beval_col-variable</B>*
<A HREF="#v:beval_col">v:beval_col</A>	The number of the column, over which the mouse pointer is.
		This is the byte index in the |<A HREF="#v:beval_lnum">v:beval_lnum</A>| line.
		Only valid while evaluating the <A HREF="options.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_bufnr"></A><B>v:beval_bufnr</B>* *<A NAME="beval_bufnr-variable"></A><B>beval_bufnr-variable</B>*
<A HREF="#v:beval_bufnr">v:beval_bufnr</A>	The number of the buffer, over which the mouse pointer is. Only
		valid while evaluating the <A HREF="options.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_lnum"></A><B>v:beval_lnum</B>* *<A NAME="beval_lnum-variable"></A><B>beval_lnum-variable</B>*
<A HREF="#v:beval_lnum">v:beval_lnum</A>	The number of the line, over which the mouse pointer is. Only
		valid while evaluating the <A HREF="options.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_text"></A><B>v:beval_text</B>* *<A NAME="beval_text-variable"></A><B>beval_text-variable</B>*
<A HREF="#v:beval_text">v:beval_text</A>	The text under or after the mouse pointer.  Usually a <A HREF="motion.html#word">word</A> <A HREF="motion.html#as">as</A>
		<A HREF="motion.html#it">it</A> is useful for debugging a C program.  <A HREF="options.html#'iskeyword'">'iskeyword'</A> applies,
		but a dot and &quot;<A HREF="#-&gt;">-&gt;</A>&quot; before the position is included.  When on a
		'<A HREF="index.html#]">]</A>' the text before <A HREF="motion.html#it">it</A> is used, including the matching '<A HREF="index.html#[">[</A>' and
		<A HREF="motion.html#word">word</A> before <A HREF="motion.html#it">it</A>.  When on a <A HREF="visual.html#Visual">Visual</A> area within one line the
		highlighted text is used.  Also see |<A HREF="cmdline.html#&lt;cexpr&gt;">&lt;cexpr&gt;</A>|.
		Only valid while evaluating the <A HREF="options.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_winnr"></A><B>v:beval_winnr</B>* *<A NAME="beval_winnr-variable"></A><B>beval_winnr-variable</B>*
<A HREF="#v:beval_winnr">v:beval_winnr</A>	The number of the <A HREF="windows.html#window">window</A>, over which the mouse pointer is. Only
		valid while evaluating the <A HREF="options.html#'balloonexpr'">'balloonexpr'</A> option.  The first
		<A HREF="windows.html#window">window</A> has number zero (unlike most other places where a
		<A HREF="windows.html#window">window</A> gets a number).


					*<A NAME="v:beval_winid"></A><B>v:beval_winid</B>* *<A NAME="beval_winid-variable"></A><B>beval_winid-variable</B>*
<A HREF="#v:beval_winid">v:beval_winid</A>	The |<A HREF="windows.html#window-ID">window-ID</A>| of the window, over which the mouse pointer
		is.  Otherwise like <A HREF="#v:beval_winnr">v:beval_winnr</A>.


					*<A NAME="v:char"></A><B>v:char</B>* *<A NAME="char-variable"></A><B>char-variable</B>*
<A HREF="#v:char">v:char</A>		Argument for evaluating <A HREF="options.html#'formatexpr'">'formatexpr'</A> and used for the typed
		character when using &lt;expr&gt; in an abbreviation |<A HREF="map.html#:map-&lt;expr&gt;">:map-&lt;expr&gt;</A>|.
		It is also used by the |<A HREF="autocmd.html#InsertCharPre">InsertCharPre</A>| and |<A HREF="autocmd.html#InsertEnter">InsertEnter</A>| events.


			*<A NAME="v:charconvert_from"></A><B>v:charconvert_from</B>* *<A NAME="charconvert_from-variable"></A><B>charconvert_from-variable</B>*
<A HREF="#v:charconvert_from">v:charconvert_from</A>
		The name of the character encoding of a file to be converted.
		Only valid while evaluating the <A HREF="options.html#'charconvert'">'charconvert'</A> option.


			*<A NAME="v:charconvert_to"></A><B>v:charconvert_to</B>* *<A NAME="charconvert_to-variable"></A><B>charconvert_to-variable</B>*
<A HREF="#v:charconvert_to">v:charconvert_to</A>
		The name of the character encoding of a file after conversion.
		Only valid while evaluating the <A HREF="options.html#'charconvert'">'charconvert'</A> option.


					*<A NAME="v:cmdarg"></A><B>v:cmdarg</B>* *<A NAME="cmdarg-variable"></A><B>cmdarg-variable</B>*
<A HREF="#v:cmdarg">v:cmdarg</A>	This variable is used for two purposes:
		1. The extra arguments given to a file read/write command.
		   Currently these are &quot;++enc=&quot; and &quot;++ff=&quot;.  This variable is
		   set before an <A HREF="autocmd.html#autocommand">autocommand</A> event for a file read/write
		   command is triggered.  There is a leading space to make <A HREF="motion.html#it">it</A>
		   possible to append this variable directly after the
		   read/write command.  Note: The &quot;<A HREF="editing.html#+cmd">+cmd</A>&quot; argument isn't
		   included here, because <A HREF="motion.html#it">it</A> will be executed anyway.
		2. When <A HREF="print.html#printing">printing</A> a PostScript file with &quot;<A HREF="print.html#:hardcopy">:hardcopy</A>&quot; this is
		   the argument for the &quot;<A HREF="print.html#:hardcopy">:hardcopy</A>&quot; command.  This can be used
		   in <A HREF="options.html#'printexpr'">'printexpr'</A>.


					*<A NAME="v:cmdbang"></A><B>v:cmdbang</B>* *<A NAME="cmdbang-variable"></A><B>cmdbang-variable</B>*
<A HREF="#v:cmdbang">v:cmdbang</A>	Set like <A HREF="#v:cmdarg">v:cmdarg</A> for a file read/write command.  When a &quot;<A HREF="change.html#!">!</A>&quot;
		was used the value is 1, otherwise <A HREF="motion.html#it">it</A> is 0.  Note that this
		can only be used in <A HREF="autocmd.html#autocommands">autocommands</A>.  For user commands |<A HREF="map.html#&lt;bang&gt;">&lt;bang&gt;</A>|
		can be used.

						*<A NAME="v:collate"></A><B>v:collate</B>* *<A NAME="collate-variable"></A><B>collate-variable</B>*
<A HREF="#v:collate">v:collate</A>	The current <A HREF="mbyte.html#locale">locale</A> setting for collation order of the runtime
		environment.  This allows Vim scripts to be aware of the
		current <A HREF="mbyte.html#locale">locale</A> encoding.  Technical: it's the value of
		LC_COLLATE.  When not using a <A HREF="mbyte.html#locale">locale</A> the value is &quot;<A HREF="change.html#C">C</A>&quot;.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.
		See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


                                                                *<A NAME="v:colornames"></A><B>v:colornames</B>*
<A HREF="#v:colornames">v:colornames</A>    A dictionary that maps color names to hex color strings. These
		color names can be used with the |<A HREF="syntax.html#highlight-guifg">highlight-guifg</A>|,
		|<A HREF="syntax.html#highlight-guibg">highlight-guibg</A>|, and |<A HREF="syntax.html#highlight-guisp">highlight-guisp</A>| parameters. Updating
		an entry in <A HREF="#v:colornames">v:colornames</A> has no immediate effect on the <A HREF="syntax.html#syntax">syntax</A>
		highlighting. The highlight commands (probably in a
		colorscheme <A HREF="usr_41.html#script">script</A>) need to be re-evaluated in order to use
		the updated color values. For example:

<B>		    :let v:colornames['fuscia'] = '#cf3ab4'</B>
<B>		    :let v:colornames['mauve'] = '#915f6d'</B>
<B>		    :highlight Normal guifg=fuscia guibg=mauve</B>
 
		This cannot be used to override the |<A HREF="syntax.html#cterm-colors">cterm-colors</A>| but <A HREF="motion.html#it">it</A> can
		be used to override other colors. For example, the <A HREF="options.html#X11">X11</A> colors
		defined in the `colors/lists/default.vim` (previously defined
		in |<A HREF="rgb.html">rgb.txt</A>|). When defining new color names in a <A HREF="usr_05.html#plugin">plugin</A>, the
		recommended practice is to set a color entry only when <A HREF="motion.html#it">it</A> does
		not already exist. For example:

<B>		    :call extend(v:colornames, {</B>
<B>			\ 'fuscia': '#cf3ab4',</B>
<B>			\ 'mauve': '#915f6d,</B>
<B>			\ }, 'keep')</B>
 
		Using |<A HREF="builtin.html#extend()">extend()</A>| with the 'keep' option updates each color only
		if <A HREF="motion.html#it">it</A> did not exist in |<A HREF="#v:colornames">v:colornames</A>|. Doing so allows the
		user to choose the precise color value for a common name
		by setting <A HREF="motion.html#it">it</A> in their |<A HREF="starting.html#.vimrc">.vimrc</A>|.

		It is possible to remove entries from this dictionary but
		doing so is NOT recommended, because <A HREF="motion.html#it">it</A> is disruptive to
		other scripts. It is also unlikely to achieve the desired
		result because the |<A HREF="syntax.html#:colorscheme">:colorscheme</A>| and |<A HREF="syntax.html#:highlight">:highlight</A>| commands will
		both automatically load all `colors/lists/default.vim` color
		scripts.


				*<A NAME="v:completed_item"></A><B>v:completed_item</B>* *<A NAME="completed_item-variable"></A><B>completed_item-variable</B>*
<A HREF="#v:completed_item">v:completed_item</A>
		|<A HREF="#Dictionary">Dictionary</A>| containing the |<A HREF="insert.html#complete-items">complete-items</A>| for the most
		recently completed <A HREF="motion.html#word">word</A> after |<A HREF="autocmd.html#CompleteDone">CompleteDone</A>|.  The
		|<A HREF="#Dictionary">Dictionary</A>| is empty if the completion failed.


					*<A NAME="v:count"></A><B>v:count</B>* *<A NAME="count-variable"></A><B>count-variable</B>*
<A HREF="#v:count">v:count</A>		The <A HREF="intro.html#count">count</A> given for the last <A HREF="intro.html#Normal">Normal</A> mode command.  Can be used
		to get the <A HREF="intro.html#count">count</A> before a <A HREF="map.html#mapping">mapping</A>.  Read-only.  Example:
<B>	:map _x :&lt;C-U&gt;echo "the count is " .. v:count&lt;CR&gt;</B>
 		Note: The &lt;C-U&gt; is required to remove the line range that you
		get when typing '<A HREF="cmdline.html#:">:</A>' after a <A HREF="intro.html#count">count</A>.
		When there are two counts, <A HREF="motion.html#as">as</A> in &quot;3d2w&quot;, they are multiplied,
		just like what happens in the command, &quot;d6w&quot; for the example.
		Also used for evaluating the <A HREF="options.html#'formatexpr'">'formatexpr'</A> option.
		&quot;<A HREF="intro.html#count">count</A>&quot; also works, for backwards compatibility, unless
		|<A HREF="#scriptversion">scriptversion</A>| is 3 or higher.


					*<A NAME="v:count1"></A><B>v:count1</B>* *<A NAME="count1-variable"></A><B>count1-variable</B>*
<A HREF="#v:count1">v:count1</A>	Just like &quot;<A HREF="#v:count">v:count</A>&quot;, but defaults to one when no <A HREF="intro.html#count">count</A> is
		used.


						*<A NAME="v:ctype"></A><B>v:ctype</B>* *<A NAME="ctype-variable"></A><B>ctype-variable</B>*
<A HREF="#v:ctype">v:ctype</A>		The current <A HREF="mbyte.html#locale">locale</A> setting for characters of the runtime
		environment.  This allows Vim scripts to be aware of the
		current <A HREF="mbyte.html#locale">locale</A> encoding.  Technical: it's the value of
		LC_CTYPE.  When not using a <A HREF="mbyte.html#locale">locale</A> the value is &quot;<A HREF="change.html#C">C</A>&quot;.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.
		See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


					*<A NAME="v:dying"></A><B>v:dying</B>* *<A NAME="dying-variable"></A><B>dying-variable</B>*
<A HREF="#v:dying">v:dying</A>		Normally zero.  When a deadly signal is caught it's set to
		one.  When multiple signals are caught the number increases.
		Can be used in an <A HREF="autocmd.html#autocommand">autocommand</A> to check if Vim didn't
		terminate normally. {only works on Unix}
		Example:
<B>	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif</B>
 		Note: if another deadly signal is caught when <A HREF="#v:dying">v:dying</A> is one,
		<A HREF="autocmd.html#VimLeave">VimLeave</A> <A HREF="autocmd.html#autocommands">autocommands</A> will not be executed.


					*<A NAME="v:exiting"></A><B>v:exiting</B>* *<A NAME="exiting-variable"></A><B>exiting-variable</B>*
<A HREF="#v:exiting">v:exiting</A>	Vim exit code.  Normally zero, non-zero when something went
		wrong.  The value is <A HREF="#v:null">v:null</A> before invoking the |<A HREF="autocmd.html#VimLeavePre">VimLeavePre</A>|
		and |<A HREF="autocmd.html#VimLeave">VimLeave</A>| autocmds.  See |<A HREF="editing.html#:q">:q</A>|, |<A HREF="editing.html#:x">:x</A>| and |<A HREF="quickfix.html#:cquit">:cquit</A>|.
		Example:
<B>			:au VimLeave * echo "Exit value is " .. v:exiting</B>
 

					*<A NAME="v:echospace"></A><B>v:echospace</B>* *<A NAME="echospace-variable"></A><B>echospace-variable</B>*
<A HREF="#v:echospace">v:echospace</A>	<A HREF="#Number">Number</A> of screen cells that can be used for an `:echo` message
		in the last screen line before causing the |<A HREF="message.html#hit-enter-prompt">hit-enter-prompt</A>|.
		Depends on <A HREF="options.html#'showcmd'">'showcmd'</A>, <A HREF="options.html#'ruler'">'ruler'</A> and <A HREF="options.html#'columns'">'columns'</A>.  You need to
		check <A HREF="options.html#'cmdheight'">'cmdheight'</A> for whether there are full-width lines
		available above the last line.


					*<A NAME="v:errmsg"></A><B>v:errmsg</B>* *<A NAME="errmsg-variable"></A><B>errmsg-variable</B>*
<A HREF="#v:errmsg">v:errmsg</A>	Last given error message.  It's allowed to set this variable.
		Example:
<B>	:let v:errmsg = ""</B>
<B>	:silent! next</B>
<B>	:if v:errmsg != ""</B>
<B>	:  ... handle error</B>
 		&quot;errmsg&quot; also works, for backwards compatibility, unless
		|<A HREF="#scriptversion">scriptversion</A>| is 3 or higher.


				*<A NAME="v:errors"></A><B>v:errors</B>* *<A NAME="errors-variable"></A><B>errors-variable</B>* *<A NAME="assert-return"></A><B>assert-return</B>*
<A HREF="#v:errors">v:errors</A>	Errors found by assert <A HREF="#functions">functions</A>, such as |<A HREF="testing.html#assert_true()">assert_true()</A>|.
		This is a <A HREF="#list">list</A> of strings.
		The assert <A HREF="#functions">functions</A> append an item when an assert fails.
		The return value indicates this: a one is returned if an item
		was added to <A HREF="#v:errors">v:errors</A>, otherwise zero is returned.
		To remove old results make <A HREF="motion.html#it">it</A> empty:
<B>	:let v:errors = []</B>
 		If <A HREF="#v:errors">v:errors</A> is set to anything but a <A HREF="#list">list</A> <A HREF="motion.html#it">it</A> is made an empty
		<A HREF="#list">list</A> by the assert function.


					*<A NAME="v:event"></A><B>v:event</B>* *<A NAME="event-variable"></A><B>event-variable</B>*
<A HREF="#v:event">v:event</A>		<A HREF="#Dictionary">Dictionary</A> containing information about the current
		|<A HREF="autocmd.html#autocommand">autocommand</A>|.  See the specific event for what <A HREF="motion.html#it">it</A> puts in
		this dictionary.
		The dictionary is emptied when the |<A HREF="autocmd.html#autocommand">autocommand</A>| finishes,
		please refer to |<A HREF="#dict-identity">dict-identity</A>| for how to get an independent
		copy of <A HREF="motion.html#it">it</A>.  Use |<A HREF="builtin.html#deepcopy()">deepcopy()</A>| if you want to keep the
		information after the event triggers.  Example:
<B>			au TextYankPost * let g:foo = deepcopy(v:event)</B>
 

					*<A NAME="v:exception"></A><B>v:exception</B>* *<A NAME="exception-variable"></A><B>exception-variable</B>*
<A HREF="#v:exception">v:exception</A>	The value of the exception most recently caught and not
		finished.  See also |<A HREF="#v:throwpoint">v:throwpoint</A>| and |<A HREF="#throw-variables">throw-variables</A>|.
		Example:
<B>	:try</B>
<B>	:  throw "oops"</B>
<B>	:catch /.*/</B>
<B>	:  echo "caught " .. v:exception</B>
<B>	:endtry</B>
 		Output: &quot;caught oops&quot;.


					*<A NAME="v:false"></A><B>v:false</B>* *<A NAME="false-variable"></A><B>false-variable</B>*
<A HREF="#v:false">v:false</A>		A <A HREF="#Number">Number</A> with value zero. Used to put &quot;<A HREF="vim9.html#false">false</A>&quot; in JSON.  See
		|<A HREF="builtin.html#json_encode()">json_encode()</A>|.
		When used <A HREF="motion.html#as">as</A> a <A HREF="#string">string</A> this evaluates to &quot;<A HREF="#v:false">v:false</A>&quot;.
<B>			echo v:false</B>
<B><FONT COLOR="PURPLE"> 			v:false </FONT></B>
		That is so that <A HREF="builtin.html#eval()">eval()</A> can parse the <A HREF="#string">string</A> back to the same
		value.  Read-only.
		In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> &quot;<A HREF="vim9.html#false">false</A>&quot; can be used which has a <A HREF="options.html#boolean">boolean</A> type.


					*<A NAME="v:fcs_reason"></A><B>v:fcs_reason</B>* *<A NAME="fcs_reason-variable"></A><B>fcs_reason-variable</B>*
<A HREF="#v:fcs_reason">v:fcs_reason</A>	The reason why the |<A HREF="autocmd.html#FileChangedShell">FileChangedShell</A>| event was triggered.
		Can be used in an <A HREF="autocmd.html#autocommand">autocommand</A> to decide what to <A HREF="diff.html#do">do</A> and/or what
		to set <A HREF="#v:fcs_choice">v:fcs_choice</A> to.  Possible values:
			deleted		file no longer exists
			conflict	file contents, mode or <A HREF="editing.html#timestamp">timestamp</A> was
					changed and buffer is modified
			changed		file contents has changed
			mode		mode of file changed
			time		only file <A HREF="editing.html#timestamp">timestamp</A> changed


					*<A NAME="v:fcs_choice"></A><B>v:fcs_choice</B>* *<A NAME="fcs_choice-variable"></A><B>fcs_choice-variable</B>*
<A HREF="#v:fcs_choice">v:fcs_choice</A>	What should happen after a |<A HREF="autocmd.html#FileChangedShell">FileChangedShell</A>| event was
		triggered.  Can be used in an <A HREF="autocmd.html#autocommand">autocommand</A> to tell Vim what to
		<A HREF="diff.html#do">do</A> with the affected buffer:
			<A HREF="editing.html#reload">reload</A>		Reload the buffer (does not work if
					the file was deleted).
			edit		Reload the buffer and detect the
					values for <A HREF="options.html#options">options</A> such <A HREF="motion.html#as">as</A>
					<A HREF="options.html#'fileformat'">'fileformat'</A>, <A HREF="options.html#'fileencoding'">'fileencoding'</A>, <A HREF="options.html#'binary'">'binary'</A>
					(does not work if the file was
					deleted).
			ask		Ask the user what to <A HREF="diff.html#do">do</A>, <A HREF="motion.html#as">as</A> if there
					was no <A HREF="autocmd.html#autocommand">autocommand</A>.  Except that when
					only the <A HREF="editing.html#timestamp">timestamp</A> changed nothing
					will happen.
			&lt;empty&gt;		Nothing, the <A HREF="autocmd.html#autocommand">autocommand</A> should <A HREF="diff.html#do">do</A>
					everything that needs to be done.
		The default is empty.  If another (invalid) value is used then
		Vim behaves like <A HREF="motion.html#it">it</A> is empty, there is no warning message.


					*<A NAME="v:fname"></A><B>v:fname</B>* *<A NAME="fname-variable"></A><B>fname-variable</B>*
<A HREF="#v:fname">v:fname</A>		When evaluating <A HREF="options.html#'includeexpr'">'includeexpr'</A>: the file name that was
		detected.  Empty otherwise.


					*<A NAME="v:fname_in"></A><B>v:fname_in</B>* *<A NAME="fname_in-variable"></A><B>fname_in-variable</B>*
<A HREF="#v:fname_in">v:fname_in</A>	The name of the input file.  Valid while evaluating:
<B><FONT COLOR="PURPLE">			option		used for </FONT></B>
			<A HREF="options.html#'charconvert'">'charconvert'</A>	file to be converted
			<A HREF="options.html#'diffexpr'">'diffexpr'</A>	original file
			<A HREF="options.html#'patchexpr'">'patchexpr'</A>	original file
			<A HREF="options.html#'printexpr'">'printexpr'</A>	file to be printed
		And set to the swap file name for |<A HREF="autocmd.html#SwapExists">SwapExists</A>|.


					*<A NAME="v:fname_out"></A><B>v:fname_out</B>* *<A NAME="fname_out-variable"></A><B>fname_out-variable</B>*
<A HREF="#v:fname_out">v:fname_out</A>	The name of the output file.  Only valid while
		evaluating:
<B><FONT COLOR="PURPLE">			option		used for </FONT></B>
			<A HREF="options.html#'charconvert'">'charconvert'</A>	resulting converted file (*)
			<A HREF="options.html#'diffexpr'">'diffexpr'</A>	output of <A HREF="diff.html#diff">diff</A>
			<A HREF="options.html#'patchexpr'">'patchexpr'</A>	resulting patched file
		(*) When doing conversion for a write command (e.g., &quot;<A HREF="editing.html#:w">:w</A>
		file&quot;) <A HREF="motion.html#it">it</A> will be equal to <A HREF="#v:fname_in">v:fname_in</A>.  When doing conversion
		for a read command (e.g., &quot;<A HREF="editing.html#:e">:e</A> file&quot;) <A HREF="motion.html#it">it</A> will be a temporary
		file and different from <A HREF="#v:fname_in">v:fname_in</A>.


					*<A NAME="v:fname_new"></A><B>v:fname_new</B>* *<A NAME="fname_new-variable"></A><B>fname_new-variable</B>*
<A HREF="#v:fname_new">v:fname_new</A>	The name of the new version of the file.  Only valid while
		evaluating <A HREF="options.html#'diffexpr'">'diffexpr'</A>.


					*<A NAME="v:fname_diff"></A><B>v:fname_diff</B>* *<A NAME="fname_diff-variable"></A><B>fname_diff-variable</B>*
<A HREF="#v:fname_diff">v:fname_diff</A>	The name of the <A HREF="diff.html#diff">diff</A> (patch) file.  Only valid while
		evaluating <A HREF="options.html#'patchexpr'">'patchexpr'</A>.


					*<A NAME="v:folddashes"></A><B>v:folddashes</B>* *<A NAME="folddashes-variable"></A><B>folddashes-variable</B>*
<A HREF="#v:folddashes">v:folddashes</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: dashes representing foldlevel of a closed
		fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:foldlevel"></A><B>v:foldlevel</B>* *<A NAME="foldlevel-variable"></A><B>foldlevel-variable</B>*
<A HREF="#v:foldlevel">v:foldlevel</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: foldlevel of closed fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:foldend"></A><B>v:foldend</B>* *<A NAME="foldend-variable"></A><B>foldend-variable</B>*
<A HREF="#v:foldend">v:foldend</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: last line of closed fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:foldstart"></A><B>v:foldstart</B>* *<A NAME="foldstart-variable"></A><B>foldstart-variable</B>*
<A HREF="#v:foldstart">v:foldstart</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: first line of closed fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:hlsearch"></A><B>v:hlsearch</B>* *<A NAME="hlsearch-variable"></A><B>hlsearch-variable</B>*
<A HREF="#v:hlsearch">v:hlsearch</A>	Variable that indicates whether search highlighting is on.
		Setting <A HREF="motion.html#it">it</A> makes sense only if <A HREF="options.html#'hlsearch'">'hlsearch'</A> is enabled which
		requires |<A HREF="various.html#+extra_search">+extra_search</A>|. Setting this variable to zero acts
		like the |<A HREF="pattern.html#:nohlsearch">:nohlsearch</A>| command, setting <A HREF="motion.html#it">it</A> to one acts like
<B>			let &amp;hlsearch = &amp;hlsearch</B>
 		Note that the value is restored when returning from a
		function. |<A HREF="#function-search-undo">function-search-undo</A>|.


					*<A NAME="v:insertmode"></A><B>v:insertmode</B>* *<A NAME="insertmode-variable"></A><B>insertmode-variable</B>*
<A HREF="#v:insertmode">v:insertmode</A>	Used for the |<A HREF="autocmd.html#InsertEnter">InsertEnter</A>| and |<A HREF="autocmd.html#InsertChange">InsertChange</A>| <A HREF="autocmd.html#autocommand">autocommand</A>
		events.  Values:
			<A HREF="insert.html#i">i</A>	<A HREF="insert.html#Insert">Insert</A> mode
			<A HREF="change.html#r">r</A>	<A HREF="insert.html#Replace">Replace</A> mode
			<A HREF="visual.html#v">v</A>	Virtual <A HREF="insert.html#Replace">Replace</A> mode


						*<A NAME="v:key"></A><B>v:key</B>* *<A NAME="key-variable"></A><B>key-variable</B>*
<A HREF="#v:key">v:key</A>		Key of the current item of a |<A HREF="#Dictionary">Dictionary</A>|.  Only valid while
		evaluating the <A HREF="#expression">expression</A> used with |<A HREF="builtin.html#map()">map()</A>| and |<A HREF="builtin.html#filter()">filter()</A>|.
		Read-only.


						*<A NAME="v:lang"></A><B>v:lang</B>* *<A NAME="lang-variable"></A><B>lang-variable</B>*
<A HREF="#v:lang">v:lang</A>		The current <A HREF="mbyte.html#locale">locale</A> setting for <A HREF="message.html#messages">messages</A> of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_MESSAGES.
		The value is system dependent.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.
		It can be different from |<A HREF="#v:ctype">v:ctype</A>| when <A HREF="message.html#messages">messages</A> are desired
		in a different language than what is used for character
		encoding.  See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


						*<A NAME="v:lc_time"></A><B>v:lc_time</B>* *<A NAME="lc_time-variable"></A><B>lc_time-variable</B>*
<A HREF="#v:lc_time">v:lc_time</A>	The current <A HREF="mbyte.html#locale">locale</A> setting for time <A HREF="message.html#messages">messages</A> of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_TIME.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.  See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


						*<A NAME="v:lnum"></A><B>v:lnum</B>* *<A NAME="lnum-variable"></A><B>lnum-variable</B>*
<A HREF="#v:lnum">v:lnum</A>		Line number for the <A HREF="options.html#'foldexpr'">'foldexpr'</A> |<A HREF="fold.html#fold-expr">fold-expr</A>|, <A HREF="options.html#'formatexpr'">'formatexpr'</A> and
		<A HREF="options.html#'indentexpr'">'indentexpr'</A> expressions, <A HREF="intro.html#tab">tab</A> page number for <A HREF="options.html#'guitablabel'">'guitablabel'</A>
		and <A HREF="options.html#'guitabtooltip'">'guitabtooltip'</A>.  Only valid while one of these
		expressions is being evaluated.  Read-only when in the
		|<A HREF="#sandbox">sandbox</A>|.


						*<A NAME="v:maxcol"></A><B>v:maxcol</B>* *<A NAME="maxcol-variable"></A><B>maxcol-variable</B>*
<A HREF="#v:maxcol">v:maxcol</A>	Maximum line length.  Depending on where <A HREF="motion.html#it">it</A> is used <A HREF="motion.html#it">it</A> can be
		screen columns, characters or bytes.  The value currently is
		2147483647 on all systems.


					*<A NAME="v:mouse_win"></A><B>v:mouse_win</B>* *<A NAME="mouse_win-variable"></A><B>mouse_win-variable</B>*
<A HREF="#v:mouse_win">v:mouse_win</A>	Window number for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		First <A HREF="windows.html#window">window</A> has number 1, like with |<A HREF="builtin.html#winnr()">winnr()</A>|.  The value is
		zero when there was no mouse button click.


					*<A NAME="v:mouse_winid"></A><B>v:mouse_winid</B>* *<A NAME="mouse_winid-variable"></A><B>mouse_winid-variable</B>*
<A HREF="#v:mouse_winid">v:mouse_winid</A>	Window ID for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		The value is zero when there was no mouse button click.


					*<A NAME="v:mouse_lnum"></A><B>v:mouse_lnum</B>* *<A NAME="mouse_lnum-variable"></A><B>mouse_lnum-variable</B>*
<A HREF="#v:mouse_lnum">v:mouse_lnum</A>	Line number for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		This is the text line number, not the screen line number.  The
		value is zero when there was no mouse button click.


					*<A NAME="v:mouse_col"></A><B>v:mouse_col</B>* *<A NAME="mouse_col-variable"></A><B>mouse_col-variable</B>*
<A HREF="#v:mouse_col">v:mouse_col</A>	Column number for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		This is the screen column number, like with |<A HREF="builtin.html#virtcol()">virtcol()</A>|.  The
		value is zero when there was no mouse button click.


					*<A NAME="v:none"></A><B>v:none</B>* *<A NAME="none-variable"></A><B>none-variable</B>* *<A NAME="None"></A><B>None</B>*
<A HREF="#v:none">v:none</A>		An empty <A HREF="#String">String</A>. Used to put an empty item in JSON.  See
		|<A HREF="builtin.html#json_encode()">json_encode()</A>|.
		This can also be used <A HREF="motion.html#as">as</A> a function argument to use the
		default value, see |<A HREF="#none-function_argument">none-function_argument</A>|.
		When used <A HREF="motion.html#as">as</A> a number this evaluates to zero.
		When used <A HREF="motion.html#as">as</A> a <A HREF="#string">string</A> this evaluates to &quot;<A HREF="#v:none">v:none</A>&quot;.
<B>			echo v:none</B>
<B><FONT COLOR="PURPLE"> 			v:none </FONT></B>
		That is so that <A HREF="builtin.html#eval()">eval()</A> can parse the <A HREF="#string">string</A> back to the same
		value.  Read-only.
		Note that using `== v:none` and `!= v:none`  will often give
		an error.  Instead, use `is v:none` and `isnot v:none` .


					*<A NAME="v:null"></A><B>v:null</B>* *<A NAME="null-variable"></A><B>null-variable</B>*
<A HREF="#v:null">v:null</A>		An empty <A HREF="#String">String</A>. Used to put &quot;<A HREF="vim9.html#null">null</A>&quot; in JSON.  See
		|<A HREF="builtin.html#json_encode()">json_encode()</A>|.
		When used <A HREF="motion.html#as">as</A> a number this evaluates to zero.
		When used <A HREF="motion.html#as">as</A> a <A HREF="#string">string</A> this evaluates to &quot;<A HREF="#v:null">v:null</A>&quot;.
<B>			echo v:null</B>
<B><FONT COLOR="PURPLE"> 			v:null </FONT></B>
		That is so that <A HREF="builtin.html#eval()">eval()</A> can parse the <A HREF="#string">string</A> back to the same
		value.  Read-only.
		In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `null` can be used without &quot;<A HREF="#v:">v:</A>&quot;.
		In some places `v:null` and `null` can be used for a <A HREF="#List">List</A>,
		<A HREF="#Dict">Dict</A>, <A HREF="#Job">Job</A>, etc. that is not set.  That is slightly different
		than an empty <A HREF="#List">List</A>, <A HREF="#Dict">Dict</A>, etc.


					*<A NAME="v:numbermax"></A><B>v:numbermax</B>* *<A NAME="numbermax-variable"></A><B>numbermax-variable</B>*
<A HREF="#v:numbermax">v:numbermax</A>	Maximum value of a number.


					*<A NAME="v:numbermin"></A><B>v:numbermin</B>* *<A NAME="numbermin-variable"></A><B>numbermin-variable</B>*
<A HREF="#v:numbermin">v:numbermin</A>	Minimum value of a number (negative).


					*<A NAME="v:numbersize"></A><B>v:numbersize</B>* *<A NAME="numbersize-variable"></A><B>numbersize-variable</B>*
<A HREF="#v:numbersize">v:numbersize</A>	<A HREF="#Number">Number</A> of bits in a <A HREF="#Number">Number</A>.  This is normally 64, but on some
		systems <A HREF="motion.html#it">it</A> may be 32.


					*<A NAME="v:oldfiles"></A><B>v:oldfiles</B>* *<A NAME="oldfiles-variable"></A><B>oldfiles-variable</B>*
<A HREF="#v:oldfiles">v:oldfiles</A>	<A HREF="#List">List</A> of file names that is loaded from the |<A HREF="starting.html#viminfo">viminfo</A>| file on
		<A HREF="starting.html#startup">startup</A>.  These are the files that Vim remembers marks for.
		The length of the <A HREF="#List">List</A> is limited by the '' argument of the
		<A HREF="options.html#'viminfo'">'viminfo'</A> option (default is 100).
		When the |<A HREF="starting.html#viminfo">viminfo</A>| file is not used the <A HREF="#List">List</A> is empty.
		Also see |<A HREF="starting.html#:oldfiles">:oldfiles</A>| and |<A HREF="cmdline.html#c_#&lt;">c_#&lt;</A>|.
		The <A HREF="#List">List</A> can be modified, but this has no effect on what is
		stored in the |<A HREF="starting.html#viminfo">viminfo</A>| file later.  If you use values other
		than <A HREF="#String">String</A> this will cause trouble.
		{only when compiled with the |<A HREF="various.html#+viminfo">+viminfo</A>| feature}


						    *<A NAME="v:option_new"></A><B>v:option_new</B>*
<A HREF="#v:option_new">v:option_new</A>    New value of the option. Valid while executing an |<A HREF="autocmd.html#OptionSet">OptionSet</A>|
		<A HREF="autocmd.html#autocommand">autocommand</A>.

						    *<A NAME="v:option_old"></A><B>v:option_old</B>*
<A HREF="#v:option_old">v:option_old</A>    Old value of the option. Valid while executing an |<A HREF="autocmd.html#OptionSet">OptionSet</A>|
		<A HREF="autocmd.html#autocommand">autocommand</A>. Depending on the command used for setting and the
		kind of option this is either the local old value or the
		global old value.

						    *<A NAME="v:option_oldlocal"></A><B>v:option_oldlocal</B>*
<A HREF="#v:option_oldlocal">v:option_oldlocal</A>
		Old local value of the option. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>.

						    *<A NAME="v:option_oldglobal"></A><B>v:option_oldglobal</B>*
<A HREF="#v:option_oldglobal">v:option_oldglobal</A>
		Old global value of the option. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>.

						    *<A NAME="v:option_type"></A><B>v:option_type</B>*
<A HREF="#v:option_type">v:option_type</A>   Scope of the set command. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>. Can be either &quot;global&quot; or &quot;local&quot;

						    *<A NAME="v:option_command"></A><B>v:option_command</B>*
<A HREF="#v:option_command">v:option_command</A>
		Command used to set the option. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>.
<B><FONT COLOR="PURPLE">			value		option was set via   </FONT></B>
			&quot;setlocal&quot;	|<A HREF="options.html#:setlocal">:setlocal</A>| or &quot;<A HREF="#:let">:let</A> l:xxx&quot;
			&quot;setglobal&quot;	|<A HREF="options.html#:setglobal">:setglobal</A>| or &quot;<A HREF="#:let">:let</A> g:xxx&quot;
			&quot;set&quot;		|<A HREF="options.html#:set">:set</A>| or |<A HREF="#:let">:let</A>|
			&quot;modeline&quot;	|<A HREF="options.html#modeline">modeline</A>|

					*<A NAME="v:operator"></A><B>v:operator</B>* *<A NAME="operator-variable"></A><B>operator-variable</B>*
<A HREF="#v:operator">v:operator</A>	The last <A HREF="motion.html#operator">operator</A> given in <A HREF="intro.html#Normal">Normal</A> mode.  This is a single
		character except for commands starting with &lt;g&gt; or &lt;z&gt;,
		in which <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> is two characters.  Best used alongside
		|<A HREF="#v:prevcount">v:prevcount</A>| and |<A HREF="#v:register">v:register</A>|.  Useful if you want to cancel
		<A HREF="intro.html#Operator-pending">Operator-pending</A> mode and then use the <A HREF="motion.html#operator">operator</A>, e.g.:
<B>			:omap O &lt;Esc&gt;:call MyMotion(v:operator)&lt;CR&gt;</B>
 		The value remains set until another <A HREF="motion.html#operator">operator</A> is entered, thus
		don't expect <A HREF="motion.html#it">it</A> to be empty.
		<A HREF="#v:operator">v:operator</A> is not set for |<A HREF="change.html#:delete">:delete</A>|, |<A HREF="change.html#:yank">:yank</A>| or other <A HREF="intro.html#Ex">Ex</A>
		commands.
		Read-only.


					*<A NAME="v:prevcount"></A><B>v:prevcount</B>* *<A NAME="prevcount-variable"></A><B>prevcount-variable</B>*
<A HREF="#v:prevcount">v:prevcount</A>	The <A HREF="intro.html#count">count</A> given for the last but one <A HREF="intro.html#Normal">Normal</A> mode command.
		This is the <A HREF="#v:count">v:count</A> value of the previous command.  Useful if
		you want to cancel <A HREF="visual.html#Visual">Visual</A> or <A HREF="intro.html#Operator-pending">Operator-pending</A> mode and then
		use the <A HREF="intro.html#count">count</A>, e.g.:
<B>			:vmap % &lt;Esc&gt;:call MyFilter(v:prevcount)&lt;CR&gt;</B>
 		Read-only.


					*<A NAME="v:profiling"></A><B>v:profiling</B>* *<A NAME="profiling-variable"></A><B>profiling-variable</B>*
<A HREF="#v:profiling">v:profiling</A>	Normally zero.  Set to one after using &quot;<A HREF="repeat.html#:profile">:profile</A> start&quot;.
		See |<A HREF="repeat.html#profiling">profiling</A>|.


					*<A NAME="v:progname"></A><B>v:progname</B>* *<A NAME="progname-variable"></A><B>progname-variable</B>*
<A HREF="#v:progname">v:progname</A>	Contains the name (with path removed) with which Vim was
		invoked.  Allows you to <A HREF="diff.html#do">do</A> special initialisations for |<A HREF="starting.html#view">view</A>|,
		|<A HREF="starting.html#evim">evim</A>| etc., or any other name you might symlink to Vim.
		Read-only.


					*<A NAME="v:progpath"></A><B>v:progpath</B>* *<A NAME="progpath-variable"></A><B>progpath-variable</B>*
<A HREF="#v:progpath">v:progpath</A>	Contains the command with which Vim was invoked, in a form
		that when passed to the shell will run the same Vim executable
		<A HREF="motion.html#as">as</A> the current one (if $PATH remains unchanged).
		Useful if you want to message a Vim server using a
		|<A HREF="remote.html#--remote-expr">--remote-expr</A>|.
		To get the full path use:
<B>			echo exepath(v:progpath)</B>
 		If the command has a relative path <A HREF="motion.html#it">it</A> will be expanded to the
		full path, so that <A HREF="motion.html#it">it</A> still works after `:cd`. Thus starting
		&quot;./vim&quot; results in &quot;/home/user/path/to/vim/src/vim&quot;.
		On Linux and other systems <A HREF="motion.html#it">it</A> will always be the full path.
		On <A HREF="os_mac.html#Mac">Mac</A> <A HREF="motion.html#it">it</A> may just be &quot;vim&quot; and using <A HREF="builtin.html#exepath()">exepath()</A> <A HREF="motion.html#as">as</A> mentioned
		above should be used to get the full path.
		On <A HREF="os_win32.html#MS-Windows">MS-Windows</A> the executable may be called &quot;vim.exe&quot;, but the
		&quot;.exe&quot; is not added to <A HREF="#v:progpath">v:progpath</A>.
		Read-only.


					*<A NAME="v:register"></A><B>v:register</B>* *<A NAME="register-variable"></A><B>register-variable</B>*
<A HREF="#v:register">v:register</A>	The name of the <A HREF="sponsor.html#register">register</A> in effect for the current normal mode
		command (regardless of whether that command actually used a
		<A HREF="sponsor.html#register">register</A>).  Or for the currently executing normal mode <A HREF="map.html#mapping">mapping</A>
		(use this in custom commands that take a <A HREF="sponsor.html#register">register</A>).
		If none is supplied <A HREF="motion.html#it">it</A> is the default <A HREF="sponsor.html#register">register</A> &#39;&#34;'', unless
		<A HREF="options.html#'clipboard'">'clipboard'</A> contains &quot;unnamed&quot; or &quot;unnamedplus&quot;, then <A HREF="motion.html#it">it</A> is
		'*' or '<A HREF="motion.html#+">+</A>'.
		Also see |<A HREF="builtin.html#getreg()">getreg()</A>| and |<A HREF="builtin.html#setreg()">setreg()</A>|


					*<A NAME="v:scrollstart"></A><B>v:scrollstart</B>* *<A NAME="scrollstart-variable"></A><B>scrollstart-variable</B>*
<A HREF="#v:scrollstart">v:scrollstart</A>	<A HREF="#String">String</A> describing the <A HREF="usr_41.html#script">script</A> or function that caused the
		screen to scroll up.  It's only set when <A HREF="motion.html#it">it</A> is empty, thus the
		first reason is remembered.  It is set to &quot;Unknown&quot; for a
		typed command.
		This can be used to find out why your <A HREF="usr_41.html#script">script</A> causes the
		<A HREF="message.html#hit-enter">hit-enter</A> prompt.


					*<A NAME="v:servername"></A><B>v:servername</B>* *<A NAME="servername-variable"></A><B>servername-variable</B>*
<A HREF="#v:servername">v:servername</A>	The resulting registered |<A HREF="remote.html#client-server-name">client-server-name</A>| if any.
		Read-only.



<A HREF="#v:searchforward">v:searchforward</A>			*<A NAME="v:searchforward"></A><B>v:searchforward</B>* *<A NAME="searchforward-variable"></A><B>searchforward-variable</B>*
		Search direction:  1 after a forward search, 0 after a
		backward search.  It is reset to forward when directly setting
		the last search <A HREF="pattern.html#pattern">pattern</A>, see |<A HREF="change.html#quote/">quote/</A>|.
		Note that the value is restored when returning from a
		function. |<A HREF="#function-search-undo">function-search-undo</A>|.
		Read-write.


					*<A NAME="v:shell_error"></A><B>v:shell_error</B>* *<A NAME="shell_error-variable"></A><B>shell_error-variable</B>*
<A HREF="#v:shell_error">v:shell_error</A>	Result of the last shell command.  When non-zero, the last
		shell command had an error.  When zero, there was no problem.
		This only works when the shell returns the error code to Vim.
		The value -1 is often used when the command could not be
		executed.  Read-only.
		Example:
<B>	:!mv foo bar</B>
<B>	:if v:shell_error</B>
<B>	:  echo 'could not rename "foo" to "bar"!'</B>
<B>	:endif</B>
 		&quot;shell_error&quot; also works, for backwards compatibility, unless
		|<A HREF="#scriptversion">scriptversion</A>| is 3 or higher.


					*<A NAME="v:sizeofint"></A><B>v:sizeofint</B>* *<A NAME="sizeofint-variable"></A><B>sizeofint-variable</B>*
<A HREF="#v:sizeofint">v:sizeofint</A>	<A HREF="#Number">Number</A> of bytes in an int.  Depends on how Vim was compiled.
		This is only useful for deciding whether a test will give the
		expected result.


					*<A NAME="v:sizeoflong"></A><B>v:sizeoflong</B>* *<A NAME="sizeoflong-variable"></A><B>sizeoflong-variable</B>*
<A HREF="#v:sizeoflong">v:sizeoflong</A>	<A HREF="#Number">Number</A> of bytes in a long.  Depends on how Vim was compiled.
		This is only useful for deciding whether a test will give the
		expected result.


				*<A NAME="v:sizeofpointer"></A><B>v:sizeofpointer</B>* *<A NAME="sizeofpointer-variable"></A><B>sizeofpointer-variable</B>*
<A HREF="#v:sizeofpointer">v:sizeofpointer</A>	<A HREF="#Number">Number</A> of bytes in a pointer.  Depends on how Vim was compiled.
		This is only useful for deciding whether a test will give the
		expected result.


					*<A NAME="v:statusmsg"></A><B>v:statusmsg</B>* *<A NAME="statusmsg-variable"></A><B>statusmsg-variable</B>*
<A HREF="#v:statusmsg">v:statusmsg</A>	Last given status message.  It's allowed to set this variable.


					*<A NAME="v:swapname"></A><B>v:swapname</B>* *<A NAME="swapname-variable"></A><B>swapname-variable</B>*
<A HREF="#v:swapname">v:swapname</A>	Only valid when executing |<A HREF="autocmd.html#SwapExists">SwapExists</A>| <A HREF="autocmd.html#autocommands">autocommands</A>: Name of
		the swap file found.  Read-only.


					*<A NAME="v:swapchoice"></A><B>v:swapchoice</B>* *<A NAME="swapchoice-variable"></A><B>swapchoice-variable</B>*
<A HREF="#v:swapchoice">v:swapchoice</A>	|<A HREF="autocmd.html#SwapExists">SwapExists</A>| <A HREF="autocmd.html#autocommands">autocommands</A> can set this to the selected choice
		for handling an existing swap file:
			'<A HREF="insert.html#o">o</A>'	Open read-only
			'<A HREF="motion.html#e">e</A>'	Edit anyway
			'<A HREF="change.html#r">r</A>'	Recover
			'<A HREF="change.html#d">d</A>'	Delete swapfile
			'<A HREF="repeat.html#q">q</A>'	Quit
			'<A HREF="insert.html#a">a</A>'	Abort
		The value should be a single-character <A HREF="#string">string</A>.  An empty value
		results in the user being asked, <A HREF="motion.html#as">as</A> would happen when there is
		no <A HREF="autocmd.html#SwapExists">SwapExists</A> <A HREF="autocmd.html#autocommand">autocommand</A>.  The default is empty.


					*<A NAME="v:swapcommand"></A><B>v:swapcommand</B>* *<A NAME="swapcommand-variable"></A><B>swapcommand-variable</B>*
<A HREF="#v:swapcommand">v:swapcommand</A>	<A HREF="intro.html#Normal">Normal</A> mode command to be executed after a file has been
		opened.  Can be used for a |<A HREF="autocmd.html#SwapExists">SwapExists</A>| <A HREF="autocmd.html#autocommand">autocommand</A> to have
		another Vim open the file and jump to the right place.  For
		example, when jumping to a <A HREF="tagsrch.html#tag">tag</A> the value is &quot;<A HREF="tagsrch.html#:tag">:tag</A> tagname\r&quot;.
		For &quot;<A HREF="editing.html#:edit">:edit</A> <A HREF="editing.html#+cmd">+cmd</A> file&quot; the value is &quot;:cmd\r&quot;.


				*<A NAME="v:t_TYPE"></A><B>v:t_TYPE</B>* *<A NAME="v:t_bool"></A><B>v:t_bool</B>* *<A NAME="t_bool-variable"></A><B>t_bool-variable</B>*
<A HREF="#v:t_bool">v:t_bool</A>	Value of |<A HREF="#Boolean">Boolean</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_channel"></A><B>v:t_channel</B>* *<A NAME="t_channel-variable"></A><B>t_channel-variable</B>*
<A HREF="#v:t_channel">v:t_channel</A>	Value of |<A HREF="#Channel">Channel</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_dict"></A><B>v:t_dict</B>* *<A NAME="t_dict-variable"></A><B>t_dict-variable</B>*
<A HREF="#v:t_dict">v:t_dict</A>	Value of |<A HREF="#Dictionary">Dictionary</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_float"></A><B>v:t_float</B>* *<A NAME="t_float-variable"></A><B>t_float-variable</B>*
<A HREF="#v:t_float">v:t_float</A>	Value of |<A HREF="#Float">Float</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_func"></A><B>v:t_func</B>* *<A NAME="t_func-variable"></A><B>t_func-variable</B>*
<A HREF="#v:t_func">v:t_func</A>	Value of |<A HREF="#Funcref">Funcref</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_job"></A><B>v:t_job</B>* *<A NAME="t_job-variable"></A><B>t_job-variable</B>*
<A HREF="#v:t_job">v:t_job</A>		Value of |<A HREF="#Job">Job</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_list"></A><B>v:t_list</B>* *<A NAME="t_list-variable"></A><B>t_list-variable</B>*
<A HREF="#v:t_list">v:t_list</A>	Value of |<A HREF="#List">List</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_none"></A><B>v:t_none</B>* *<A NAME="t_none-variable"></A><B>t_none-variable</B>*
<A HREF="#v:t_none">v:t_none</A>	Value of |<A HREF="#None">None</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_number"></A><B>v:t_number</B>* *<A NAME="t_number-variable"></A><B>t_number-variable</B>*
<A HREF="#v:t_number">v:t_number</A>	Value of |<A HREF="#Number">Number</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_string"></A><B>v:t_string</B>* *<A NAME="t_string-variable"></A><B>t_string-variable</B>*
<A HREF="#v:t_string">v:t_string</A>	Value of |<A HREF="#String">String</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_blob"></A><B>v:t_blob</B>* *<A NAME="t_blob-variable"></A><B>t_blob-variable</B>*
<A HREF="#v:t_blob">v:t_blob</A>	Value of |<A HREF="#Blob">Blob</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|


				*<A NAME="v:termresponse"></A><B>v:termresponse</B>* *<A NAME="termresponse-variable"></A><B>termresponse-variable</B>*
<A HREF="#v:termresponse">v:termresponse</A>	The <A HREF="intro.html#escape">escape</A> sequence returned by the <A HREF="terminal.html#terminal">terminal</A> for the |<A HREF="term.html#t_RV">t_RV</A>|
		<A HREF="term.html#termcap">termcap</A> entry.  It is set when Vim receives an <A HREF="intro.html#escape">escape</A> sequence
		that starts with ESC [ or CSI, then '<A HREF="change.html#&gt;">&gt;</A>' or '<A HREF="pattern.html#?">?</A>' and ends in a
		'<A HREF="change.html#c">c</A>', with only digits and '<A HREF="motion.html#;">;</A>' in between.
		When this option is set, the <A HREF="autocmd.html#TermResponse">TermResponse</A> <A HREF="autocmd.html#autocommand">autocommand</A> event is
		fired, so that you can react to the response from the
		terminal.  You can use |<A HREF="builtin.html#terminalprops()">terminalprops()</A>| to see what Vim
		figured out about the <A HREF="terminal.html#terminal">terminal</A>.
		The response from a new xterm is: &quot;&lt;Esc&gt;[&gt; Pp ; Pv ; Pc c&quot;.  Pp
		is the <A HREF="terminal.html#terminal">terminal</A> type: 0 for vt100 and 1 for vt220.  Pv is the
		patch level (since this was introduced in patch 95, it's
		always 95 or higher).  Pc is always zero.
		If Pv is 141 or higher then Vim will try to request <A HREF="terminal.html#terminal">terminal</A>
		codes.  This only works with xterm |<A HREF="term.html#xterm-codes">xterm-codes</A>|.
		{only when compiled with |<A HREF="various.html#+termresponse">+termresponse</A>| feature}


						*<A NAME="v:termblinkresp"></A><B>v:termblinkresp</B>*
<A HREF="#v:termblinkresp">v:termblinkresp</A>	The <A HREF="intro.html#escape">escape</A> sequence returned by the <A HREF="terminal.html#terminal">terminal</A> for the |<A HREF="term.html#t_RC">t_RC</A>|
		<A HREF="term.html#termcap">termcap</A> entry.  This is used to find out whether the <A HREF="terminal.html#terminal">terminal</A>
		cursor is blinking. This is used by |<A HREF="terminal.html#term_getcursor()">term_getcursor()</A>|.


						*<A NAME="v:termstyleresp"></A><B>v:termstyleresp</B>*
<A HREF="#v:termstyleresp">v:termstyleresp</A>	The <A HREF="intro.html#escape">escape</A> sequence returned by the <A HREF="terminal.html#terminal">terminal</A> for the |<A HREF="term.html#t_RS">t_RS</A>|
		<A HREF="term.html#termcap">termcap</A> entry.  This is used to find out what the shape of the
		cursor is.  This is used by |<A HREF="terminal.html#term_getcursor()">term_getcursor()</A>|.


						*<A NAME="v:termrbgresp"></A><B>v:termrbgresp</B>*
<A HREF="#v:termrbgresp">v:termrbgresp</A>	The <A HREF="intro.html#escape">escape</A> sequence returned by the <A HREF="terminal.html#terminal">terminal</A> for the |<A HREF="term.html#t_RB">t_RB</A>|
		<A HREF="term.html#termcap">termcap</A> entry.  This is used to find out what the <A HREF="terminal.html#terminal">terminal</A>
		background color is, see <A HREF="options.html#'background'">'background'</A>.


						*<A NAME="v:termrfgresp"></A><B>v:termrfgresp</B>*
<A HREF="#v:termrfgresp">v:termrfgresp</A>	The <A HREF="intro.html#escape">escape</A> sequence returned by the <A HREF="terminal.html#terminal">terminal</A> for the |<A HREF="term.html#t_RF">t_RF</A>|
		<A HREF="term.html#termcap">termcap</A> entry.  This is used to find out what the <A HREF="terminal.html#terminal">terminal</A>
		foreground color is.


						*<A NAME="v:termu7resp"></A><B>v:termu7resp</B>*
<A HREF="#v:termu7resp">v:termu7resp</A>	The <A HREF="intro.html#escape">escape</A> sequence returned by the <A HREF="terminal.html#terminal">terminal</A> for the |<A HREF="term.html#t_u7">t_u7</A>|
		<A HREF="term.html#termcap">termcap</A> entry.  This is used to find out what the <A HREF="terminal.html#terminal">terminal</A>
		does with ambiguous width characters, see <A HREF="options.html#'ambiwidth'">'ambiwidth'</A>.


					*<A NAME="v:testing"></A><B>v:testing</B>* *<A NAME="testing-variable"></A><B>testing-variable</B>*
<A HREF="#v:testing">v:testing</A>	Must be set before using `test_garbagecollect_now()`.
		Also, when set certain error <A HREF="message.html#messages">messages</A> won't be shown for 2
		seconds. (e.g. &quot;<A HREF="options.html#'dictionary'">'dictionary'</A> option is empty&quot;)


				*<A NAME="v:this_session"></A><B>v:this_session</B>* *<A NAME="this_session-variable"></A><B>this_session-variable</B>*
<A HREF="#v:this_session">v:this_session</A>	Full filename of the last loaded or saved session file.  See
		|<A HREF="starting.html#:mksession">:mksession</A>|.  It is allowed to set this variable.  When no
		session file has been saved, this variable is empty.
		&quot;this_session&quot; also works, for backwards compatibility, unless
		|<A HREF="#scriptversion">scriptversion</A>| is 3 or higher


					*<A NAME="v:throwpoint"></A><B>v:throwpoint</B>* *<A NAME="throwpoint-variable"></A><B>throwpoint-variable</B>*
<A HREF="#v:throwpoint">v:throwpoint</A>	The point where the exception most recently caught and not
		finished was thrown.  Not set when commands are typed.  See
		also |<A HREF="#v:exception">v:exception</A>| and |<A HREF="#throw-variables">throw-variables</A>|.
		Example:
<B>	:try</B>
<B>	:  throw "oops"</B>
<B>	:catch /.*/</B>
<B>	:  echo "Exception from" v:throwpoint</B>
<B>	:endtry</B>
 		Output: &quot;Exception from test.vim, line 2&quot;


						*<A NAME="v:true"></A><B>v:true</B>* *<A NAME="true-variable"></A><B>true-variable</B>*
<A HREF="#v:true">v:true</A>		A <A HREF="#Number">Number</A> with value one. Used to put &quot;<A HREF="vim9.html#true">true</A>&quot; in JSON.  See
		|<A HREF="builtin.html#json_encode()">json_encode()</A>|.
		When used <A HREF="motion.html#as">as</A> a <A HREF="#string">string</A> this evaluates to &quot;<A HREF="#v:true">v:true</A>&quot;.
<B>			echo v:true</B>
<B><FONT COLOR="PURPLE"> 			v:true </FONT></B>
		That is so that <A HREF="builtin.html#eval()">eval()</A> can parse the <A HREF="#string">string</A> back to the same
		value.  Read-only.
		In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> &quot;<A HREF="vim9.html#true">true</A>&quot; can be used which has a <A HREF="options.html#boolean">boolean</A> type.

						*<A NAME="v:val"></A><B>v:val</B>* *<A NAME="val-variable"></A><B>val-variable</B>*
<A HREF="#v:val">v:val</A>		Value of the current item of a |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>|.  Only
		valid while evaluating the <A HREF="#expression">expression</A> used with |<A HREF="builtin.html#map()">map()</A>| and
		|<A HREF="builtin.html#filter()">filter()</A>|.  Read-only.


					*<A NAME="v:version"></A><B>v:version</B>* *<A NAME="version-variable"></A><B>version-variable</B>*
<A HREF="#v:version">v:version</A>	Version number of Vim: Major version number times 100 plus
		minor version number.  Version 5.0 is 500.  Version 5.1
		is 501.  Read-only.  &quot;version&quot; also works, for backwards
		compatibility, unless |<A HREF="#scriptversion">scriptversion</A>| is 3 or higher.
		Use |<A HREF="builtin.html#has()">has()</A>| to check if a certain patch was included, e.g.:
<B>			if has("patch-7.4.123")</B>
 		Note that patch numbers are specific to the version, thus both
		version 5.0 and 5.1 may have a patch 123, but these are
		completely different.


					*<A NAME="v:versionlong"></A><B>v:versionlong</B>* *<A NAME="versionlong-variable"></A><B>versionlong-variable</B>*
<A HREF="#v:versionlong">v:versionlong</A>	Like <A HREF="#v:version">v:version</A>, but also including the patchlevel in the last
		four digits.  Version 8.1 with patch 123 has value 8010123.
		This can be used like this:
<B>			if v:versionlong &gt;= 8010123</B>
 		However, if there are gaps in the <A HREF="#list">list</A> of patches included
		this will not work well.  This can happen if a recent patch
		was included into an older version, e.g. for a security fix.
		Use the <A HREF="builtin.html#has()">has()</A> function to make sure the patch is actually
		included.


				*<A NAME="v:vim_did_enter"></A><B>v:vim_did_enter</B>* *<A NAME="vim_did_enter-variable"></A><B>vim_did_enter-variable</B>*
<A HREF="#v:vim_did_enter">v:vim_did_enter</A>	Zero until most of <A HREF="starting.html#startup">startup</A> is done.  It is set to one just
		before |<A HREF="autocmd.html#VimEnter">VimEnter</A>| <A HREF="autocmd.html#autocommands">autocommands</A> are triggered.


					*<A NAME="v:warningmsg"></A><B>v:warningmsg</B>* *<A NAME="warningmsg-variable"></A><B>warningmsg-variable</B>*
<A HREF="#v:warningmsg">v:warningmsg</A>	Last given warning message.  It's allowed to set this variable.


					*<A NAME="v:windowid"></A><B>v:windowid</B>* *<A NAME="windowid-variable"></A><B>windowid-variable</B>*
<A HREF="#v:windowid">v:windowid</A>	When any <A HREF="options.html#X11">X11</A> based <A HREF="gui.html#GUI">GUI</A> is running or when running in a
		<A HREF="terminal.html#terminal">terminal</A> and Vim connects to the X server (|<A HREF="starting.html#-X">-X</A>|) this will be
		set to the <A HREF="windows.html#window">window</A> ID.
		When an <A HREF="os_win32.html#MS-Windows">MS-Windows</A> <A HREF="gui.html#GUI">GUI</A> is running this will be set to the
		<A HREF="windows.html#window">window</A> handle.
		Otherwise the value is zero.
		Note: for <A HREF="windows.html#windows">windows</A> inside Vim use |<A HREF="builtin.html#winnr()">winnr()</A>| or |<A HREF="builtin.html#win_getid()">win_getid()</A>|,
		see |<A HREF="windows.html#window-ID">window-ID</A>|.

==============================================================================

4. Builtin Functions					*<A NAME="functions"></A><B>functions</B>*

See |<A HREF="usr_41.html#function-list">function-list</A>| for a list grouped by what the function is used for.

The alphabetic <A HREF="#list">list</A> of all builtin <A HREF="#functions">functions</A> and details are in a separate
help file: |<A HREF="builtin.html#builtin-functions">builtin-functions</A>|.

==============================================================================

5. Defining <A HREF="#functions">functions</A>					*<A NAME="user-functions"></A><B>user-functions</B>*

New <A HREF="#functions">functions</A> can be defined.  These can be called just like builtin
<A HREF="#functions">functions</A>.  The function executes a sequence of <A HREF="intro.html#Ex">Ex</A> commands.  <A HREF="intro.html#Normal">Normal</A> mode
commands can be executed with the |<A HREF="various.html#:normal">:normal</A>| command.

This section is about the legacy <A HREF="#functions">functions</A>. For the <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="#functions">functions</A>, which
execute much faster, support type checking and more, see |<A HREF="vim9.html">vim9.txt</A>|.

The function name must start with an <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A>, to avoid confusion with
builtin <A HREF="#functions">functions</A>.  To prevent from using the same name in different scripts
avoid obvious, short names.  A good habit is to start the function name with
the name of the <A HREF="usr_41.html#script">script</A>, e.g., &quot;HTMLcolor()&quot;.

In legacy <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> is also possible to use curly braces, see
|<A HREF="#curly-braces-names">curly-braces-names</A>|.
The |<A HREF="#autoload">autoload</A>| facility is useful to define a function only when it's called.


							*<A NAME="local-function"></A><B>local-function</B>*
A function local to a legacy <A HREF="usr_41.html#script">script</A> must start with &quot;s:&quot;.  A local <A HREF="usr_41.html#script">script</A>
function can only be called from within the <A HREF="usr_41.html#script">script</A> and from <A HREF="#functions">functions</A>, user
commands and <A HREF="autocmd.html#autocommands">autocommands</A> defined in the <A HREF="usr_41.html#script">script</A>.  It is also possible to call
the function from a <A HREF="map.html#mapping">mapping</A> defined in the <A HREF="usr_41.html#script">script</A>, but then |<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>| must be
used instead of &quot;s:&quot; when the <A HREF="map.html#mapping">mapping</A> is expanded outside of the <A HREF="usr_41.html#script">script</A>.
There are only <A HREF="map.html#script-local">script-local</A> <A HREF="#functions">functions</A>, no buffer-local or window-local
<A HREF="#functions">functions</A>.

In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> <A HREF="#functions">functions</A> are local to the <A HREF="usr_41.html#script">script</A> by default, prefix &quot;<A HREF="#g:">g:</A>&quot; to
define a global function.


				*<A NAME=":fu"></A><B>:fu</B>* *<A NAME=":function"></A><B>:function</B>* *<A NAME="E128"></A><B>E128</B>* *<A NAME="E129"></A><B>E129</B>* *<A NAME="E123"></A><B>E123</B>* *<A NAME="E454"></A><B>E454</B>*
:fu[nction]		<A HREF="#List">List</A> all <A HREF="#functions">functions</A> and their arguments.

:fu[nction] {name}	<A HREF="#List">List</A> function {name}.
			{name} can also be a |<A HREF="#Dictionary">Dictionary</A>| entry that is a
			YXXYFuncref|:
<B>				:function dict.init</B>

:fu[nction] /{pattern}	<A HREF="#List">List</A> <A HREF="#functions">functions</A> with a name matching {pattern}.
			Example that lists all <A HREF="#functions">functions</A> ending with &quot;File&quot;:
<B>				:function /File$</B>
 

							*<A NAME=":function-verbose"></A><B>:function-verbose</B>*
When <A HREF="options.html#'verbose'">'verbose'</A> is non-zero, listing a function will also display where <A HREF="motion.html#it">it</A> was
last defined. Example:

<B>    :verbose function SetFileTypeSH</B>
<B>	function SetFileTypeSH(name)</B>
<B>	    Last set from /usr/share/vim/vim-7.0/filetype.vim</B>
 
See |<A HREF="various.html#:verbose-cmd">:verbose-cmd</A>| for more information.


						*<A NAME="E124"></A><B>E124</B>* *<A NAME="E125"></A><B>E125</B>* *<A NAME="E853"></A><B>E853</B>* *<A NAME="E884"></A><B>E884</B>*
:fu[nction][!] {name}([arguments]) <A HREF="cmdline.html#[range]">[range]</A> [abort] [dict] [closure]
			Define a new function by the name {name}.  The body of
			the function follows in the next lines, until the
			matching |<A HREF="#:endfunction">:endfunction</A>|.

			The name must be made of alphanumeric characters and
			'<A HREF="motion.html#_">_</A>', and must start with a capital or &quot;s:&quot; (see
			above).  Note that using &quot;<A HREF="#b:">b:</A>&quot; or &quot;<A HREF="#g:">g:</A>&quot; is not allowed.
			(since patch 7.4.260 <A HREF="#E884">E884</A> is given if the function
			name has a colon in the name, e.g. for &quot;foo:bar()&quot;.
			Before that patch no error was given).

			{name} can also be a |<A HREF="#Dictionary">Dictionary</A>| entry that is a
			YXXYFuncref|:
<B>				:function dict.init(arg)</B>
 			&quot;<A HREF="#dict">dict</A>&quot; must be an existing dictionary.  The entry
			&quot;init&quot; is added if <A HREF="motion.html#it">it</A> didn't exist yet.  Otherwise [!]
			is required to overwrite an existing function.  The
			result is a |<A HREF="#Funcref">Funcref</A>| to a numbered function.  The
			function can only be used with a |<A HREF="#Funcref">Funcref</A>| and will be
			deleted if there are no more references to <A HREF="motion.html#it">it</A>.

								*<A NAME="E127"></A><B>E127</B>* *<A NAME="E122"></A><B>E122</B>*
			When a function by this name already exists and [!] is
			not used an error message is given.  There is one
			exception: When sourcing a <A HREF="usr_41.html#script">script</A> again, a function
			that was previously defined in that <A HREF="usr_41.html#script">script</A> will be
			silently replaced.
			When [!] is used, an existing function is silently
			replaced.  Unless <A HREF="motion.html#it">it</A> is currently being executed, that
			is an error.
			NOTE: Use ! wisely.  If used without care <A HREF="motion.html#it">it</A> can cause
			an existing function to be replaced unexpectedly,
			which is hard to debug.
			NOTE: In <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> <A HREF="map.html#script-local">script-local</A> <A HREF="#functions">functions</A> cannot be
			deleted or redefined.

			For the {arguments} see |<A HREF="#function-argument">function-argument</A>|.


					*<A NAME=":func-range"></A><B>:func-range</B>* *<A NAME="a:firstline"></A><B>a:firstline</B>* *<A NAME="a:lastline"></A><B>a:lastline</B>*
			When the <A HREF="cmdline.html#[range]">[range]</A> argument is added, the function is
			expected to take care of a range itself.  The range is
			passed <A HREF="motion.html#as">as</A> &quot;<A HREF="#a:firstline">a:firstline</A>&quot; and &quot;<A HREF="#a:lastline">a:lastline</A>&quot;.  If <A HREF="cmdline.html#[range]">[range]</A>
			is excluded, &quot;:{range}call&quot; will call the function for
			each line in the range, with the cursor on the start
			of each line.  See |<A HREF="#function-range-example">function-range-example</A>|.
			The cursor is still moved to the first line of the
			range, <A HREF="motion.html#as">as</A> is the <A HREF="change.html#case">case</A> with all <A HREF="intro.html#Ex">Ex</A> commands.

								*<A NAME=":func-abort"></A><B>:func-abort</B>*
			When the [abort] argument is added, the function will
			abort <A HREF="motion.html#as">as</A> soon <A HREF="motion.html#as">as</A> an error is detected.

								*<A NAME=":func-dict"></A><B>:func-dict</B>*
			When the [dict] argument is added, the function must
			be invoked through an entry in a |<A HREF="#Dictionary">Dictionary</A>|.  The
			local variable &quot;<A HREF="#self">self</A>&quot; will then be set to the
			dictionary.  See |<A HREF="#Dictionary-function">Dictionary-function</A>|.

						*<A NAME=":func-closure"></A><B>:func-closure</B>* *<A NAME="E932"></A><B>E932</B>*
			When the [closure] argument is added, the function
			can access <A HREF="#variables">variables</A> and arguments from the outer
			scope.  This is usually called a <A HREF="#closure">closure</A>.  In this
			example Bar() uses &quot;<A HREF="change.html#x">x</A>&quot; from the scope of Foo().  It
			remains referenced even after Foo() returns:
<B>				:function! Foo()</B>
<B>				:  let x = 0</B>
<B>				:  function! Bar() closure</B>
<B>				:    let x += 1</B>
<B>				:    return x</B>
<B>				:  endfunction</B>
<B>				:  return funcref('Bar')</B>
<B>				:endfunction</B>

<B>				:let F = Foo()</B>
<B>				:echo F()</B>
 				1
<B>				:echo F()</B>
 				2
<B>				:echo F()</B>
 				3


						*<A NAME="function-search-undo"></A><B>function-search-undo</B>*
			The last used search <A HREF="pattern.html#pattern">pattern</A> and the <A HREF="undo.html#redo">redo</A> command &quot;<A HREF="repeat.html#.">.</A>&quot;
			will not be changed by the function.  This also
			implies that the effect of |<A HREF="pattern.html#:nohlsearch">:nohlsearch</A>| is undone
			when the function returns.


			*<A NAME=":endf"></A><B>:endf</B>* *<A NAME=":endfunction"></A><B>:endfunction</B>* *<A NAME="E126"></A><B>E126</B>* *<A NAME="E193"></A><B>E193</B>* *<A NAME="W22"></A><B>W22</B>* *<A NAME="E1151"></A><B>E1151</B>*
:endf[unction] [argument]
			The end of a function definition.  Best is to put <A HREF="motion.html#it">it</A>
			on a line by its own, without [argument].

			[argument] can be:
				&#124; command	command to execute next
				\n command	command to execute next
				&quot; comment	always ignored
				anything else	ignored, warning given when
						<A HREF="options.html#'verbose'">'verbose'</A> is non-zero
			The support for a following command was added in Vim
			8.0.0654, before that any argument was silently
			ignored.

			To be able to define a function inside an `:execute`
			command, use line breaks instead of YXXY:bar|:
<B>				:exe "func Foo()\necho 'foo'\nendfunc"</B>
 

				*<A NAME=":delf"></A><B>:delf</B>* *<A NAME=":delfunction"></A><B>:delfunction</B>* *<A NAME="E131"></A><B>E131</B>* *<A NAME="E933"></A><B>E933</B>* *<A NAME="E1084"></A><B>E1084</B>*
:delf[unction][!] {name}
			Delete function {name}.
			{name} can also be a |<A HREF="#Dictionary">Dictionary</A>| entry that is a
			YXXYFuncref|:
<B>				:delfunc dict.init</B>
 			This will remove the &quot;init&quot; entry from &quot;<A HREF="#dict">dict</A>&quot;.  The
			function is deleted if there are no more references to
			<A HREF="motion.html#it">it</A>.
			With the ! there is no error if the function does not
			exist.

							*<A NAME=":retu"></A><B>:retu</B>* *<A NAME=":return"></A><B>:return</B>* *<A NAME="E133"></A><B>E133</B>*
:retu[rn] [expr]	Return from a function.  When &quot;[expr]&quot; is given, <A HREF="motion.html#it">it</A> is
			evaluated and returned <A HREF="motion.html#as">as</A> the result of the function.
			If &quot;[expr]&quot; is not given, the number 0 is returned.
			When a function ends without an explicit &quot;<A HREF="#:return">:return</A>&quot;,
			the number 0 is returned.

			In a <A HREF="vim9.html#:def">:def</A> function *<A NAME="E1095"></A><B>E1095</B>* is given if unreachable
			code follows after the `:return`.
			In legacy <A HREF="usr_41.html#script">script</A> there is no check for unreachable
			lines, thus there is no warning if commands follow
			`:return`.

			If the &quot;<A HREF="#:return">:return</A>&quot; is used after a |<A HREF="#:try">:try</A>| but before the
			matching |<A HREF="#:finally">:finally</A>| (if present), the commands
			following the &quot;<A HREF="#:finally">:finally</A>&quot; up to the matching |<A HREF="#:endtry">:endtry</A>|
			are executed first.  This process applies to all
			nested &quot;<A HREF="#:try">:try</A>&quot;s inside the function.  The function
			returns at the outermost &quot;<A HREF="#:endtry">:endtry</A>&quot;.


						*<A NAME="function-argument"></A><B>function-argument</B>* *<A NAME="a:var"></A><B>a:var</B>*
An argument can be defined by giving its name.  In the function this can then
be used <A HREF="motion.html#as">as</A> &quot;a:name&quot; (&quot;a:&quot; for argument).

					*<A NAME="a:0"></A><B>a:0</B>* *<A NAME="a:1"></A><B>a:1</B>* *<A NAME="a:000"></A><B>a:000</B>* *<A NAME="E740"></A><B>E740</B>* *<A NAME="..."></A><B>...</B>*
Up to 20 arguments can be given, separated by commas.  After the named
arguments an argument &quot;<A HREF="#...">...</A>&quot; can be specified, which means that more arguments
may optionally be following.  In the function the extra arguments can be used
<A HREF="motion.html#as">as</A> &quot;<A HREF="#a:1">a:1</A>&quot;, &quot;a:2&quot;, etc.  &quot;<A HREF="#a:0">a:0</A>&quot; is set to the number of extra arguments (which
can be 0).  &quot;<A HREF="#a:000">a:000</A>&quot; is set to a |<A HREF="#List">List</A>| that contains these arguments.  Note
that &quot;<A HREF="#a:1">a:1</A>&quot; is the same <A HREF="motion.html#as">as</A> &quot;a:000[0]&quot;.

							*<A NAME="E742"></A><B>E742</B>* *<A NAME="E1090"></A><B>E1090</B>*
The a: scope and the <A HREF="#variables">variables</A> in <A HREF="motion.html#it">it</A> cannot be changed, they are fixed.
However, if a composite type is used, such <A HREF="motion.html#as">as</A> |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>| , you can
change their contents.  Thus you can pass a |<A HREF="#List">List</A>| to a function and have the
function add an item to <A HREF="motion.html#it">it</A>.  If you want to make sure the function cannot
change a |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>| use |<A HREF="#:lockvar">:lockvar</A>|.

It is also possible to define a function without any arguments.  You must
still supply the () then.

It is allowed to define another function inside a function body.


						*<A NAME="optional-function-argument"></A><B>optional-function-argument</B>*
You can provide default values for positional named arguments.  This makes
them optional for function calls.  When a positional argument is not
specified at a call, the default <A HREF="#expression">expression</A> is used to initialize <A HREF="motion.html#it">it</A>.
This only works for <A HREF="#functions">functions</A> declared with `:function` or `:def`, not for
lambda expressions |<A HREF="#expr-lambda">expr-lambda</A>|.

Example:
<B>  function Something(key, value = 10)</B>
<B>     echo a:key .. ": " .. a:value</B>
<B>  endfunction</B>
<B>  call Something('empty')	"empty: 10"</B>
<B>  call Something('key', 20)	"key: 20"</B>

The argument default expressions are evaluated at the time of the function
call, not definition.  Thus <A HREF="motion.html#it">it</A> is possible to use an <A HREF="#expression">expression</A> which is
invalid the moment the function is defined.  The expressions are also only
evaluated when arguments are not specified during a call.

						*<A NAME="none-function_argument"></A><B>none-function_argument</B>*
You can pass |<A HREF="#v:none">v:none</A>| to use the default <A HREF="#expression">expression</A>.  Note that this means you
cannot pass <A HREF="#v:none">v:none</A> <A HREF="motion.html#as">as</A> an ordinary value when an argument has a default
<A HREF="#expression">expression</A>.

Example:
<B>  function Something(a = 10, b = 20, c = 30)</B>
<B>  endfunction</B>
<B>  call Something(1, v:none, 3)	    " b = 20</B>
 

								*<A NAME="E989"></A><B>E989</B>*
Optional arguments with default expressions must occur after any mandatory
arguments.  You can use &quot;<A HREF="#...">...</A>&quot; after all optional named arguments.

It is possible for later argument defaults to refer to prior arguments,
but not the other way around.  They must be prefixed with &quot;a:&quot;, <A HREF="motion.html#as">as</A> with all
arguments.

Example that works:
<B>  :function Okay(mandatory, optional = a:mandatory)</B>
<B>  :endfunction</B>
Example that does NOT work:
<B>  :function NoGood(first = a:second, second = 10)</B>
<B>  :endfunction</B>
 
When not using &quot;<A HREF="#...">...</A>&quot;, the number of arguments in a function call must be at
least equal to the number of mandatory named arguments.  When using &quot;<A HREF="#...">...</A>&quot;, the
number of arguments may be larger than the total of mandatory and optional
arguments.


							*<A NAME="local-variables"></A><B>local-variables</B>*
Inside a function local <A HREF="#variables">variables</A> can be used.  These will disappear when the
function returns.  Global <A HREF="#variables">variables</A> need to be accessed with &quot;<A HREF="#g:">g:</A>&quot;.

Example:
<B>  :function Table(title, ...)</B>
<B>  :  echohl Title</B>
<B>  :  echo a:title</B>
<B>  :  echohl None</B>
<B>  :  echo a:0 .. " items:"</B>
<B>  :  for s in a:000</B>
<B>  :    echon ' ' .. s</B>
<B>  :  endfor</B>
<B>  :endfunction</B>

This function can then be called with:
<B>  call Table("Table", "line1", "line2")</B>
<B>  call Table("Empty Table")</B>

To return more than one value, return a YXXYList|:
<B>  :function Compute(n1, n2)</B>
<B>  :  if a:n2 == 0</B>
<B>  :    return ["fail", 0]</B>
<B>  :  endif</B>
<B>  :  return ["ok", a:n1 / a:n2]</B>
<B>  :endfunction</B>

This function can then be called with:
<B>  :let [success, div] = Compute(102, 6)</B>
<B>  :if success == "ok"</B>
<B>  :  echo div</B>
<B>  :endif</B>
 

						*<A NAME=":cal"></A><B>:cal</B>* *<A NAME=":call"></A><B>:call</B>* *<A NAME="E107"></A><B>E107</B>*
:[range]cal[l] {name}([arguments])
		Call a function.  The name of the function and its arguments
		are <A HREF="motion.html#as">as</A> specified with `:function`.  Up to 20 arguments can be
		used.  The returned value is discarded.
		In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> using `:call` is optional, these two lines <A HREF="diff.html#do">do</A>
		the same thing:
<B>			call SomeFunc(arg)</B>
<B>			SomeFunc(arg)</B>
 		Without a range and for <A HREF="#functions">functions</A> that accept a range, the
		function is called once.  When a range is given the cursor is
		positioned at the start of the first line before executing the
		function.
		When a range is given and the function doesn't handle <A HREF="motion.html#it">it</A>
		itself, the function is executed for each line in the range,
		with the cursor in the first column of that line.  The cursor
		is left at the last line (possibly moved by the last function
		call).  The arguments are re-evaluated for each line.  Thus
		this works:

						*<A NAME="function-range-example"></A><B>function-range-example</B>* 
<B>	:function Mynumber(arg)</B>
<B>	:  echo line(".") .. " " .. a:arg</B>
<B>	:endfunction</B>
<B>	:1,5call Mynumber(getline("."))</B>
 
		The &quot;<A HREF="#a:firstline">a:firstline</A>&quot; and &quot;<A HREF="#a:lastline">a:lastline</A>&quot; are defined anyway, they
		can be used to <A HREF="diff.html#do">do</A> something different at the start or end of
		the range.

		Example of a function that handles the range itself:

<B>	:function Cont() range</B>
<B>	:  execute (a:firstline + 1) .. "," .. a:lastline .. 's/^/\t\\ '</B>
<B>	:endfunction</B>
<B>	:4,8call Cont()</B>
 
		This function inserts the continuation character &quot;\&quot; in front
		of all the lines in the range, except the first one.

		When the function returns a composite value <A HREF="motion.html#it">it</A> can be further
		dereferenced, but the range will not be used then.  Example:
<B>	:4,8call GetDict().method()</B>
 		Here GetDict() gets the range but method() does not.


								*<A NAME="E117"></A><B>E117</B>*
When a function cannot be found the error &quot;E117: Unknown function&quot; will be
given.  If the function was using an <A HREF="#autoload">autoload</A> path or an <A HREF="#autoload">autoload</A> import and
the <A HREF="usr_41.html#script">script</A> is a |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A>, this may also be caused by the function not
being exported.


								*<A NAME="E132"></A><B>E132</B>*
The recursiveness of user <A HREF="#functions">functions</A> is restricted with the |<A HREF="options.html#'maxfuncdepth'">'maxfuncdepth'</A>|
option.

It is also possible to use `:eval`.  It does not support a range, but does
allow for <A HREF="#method">method</A> chaining, e.g.:
<B>	eval GetList()-&gt;Filter()-&gt;append('$')</B>

A function can also be called <A HREF="motion.html#as">as</A> part of evaluating an <A HREF="#expression">expression</A> or when <A HREF="motion.html#it">it</A>
is used <A HREF="motion.html#as">as</A> a <A HREF="#method">method</A>:
<B>	let x = GetList()</B>
<B>	let y = GetList()-&gt;Filter()</B>


<B><FONT COLOR="PURPLE">AUTOMATICALLY LOADING FUNCTIONS </FONT></B>

							*<A NAME="autoload-functions"></A><B>autoload-functions</B>*
When using many or large <A HREF="#functions">functions</A>, it's possible to automatically define them
only when they are used.  There are two methods: with an <A HREF="autocmd.html#autocommand">autocommand</A> and with
the &quot;<A HREF="#autoload">autoload</A>&quot; directory in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.


<B><FONT COLOR="PURPLE">Using an autocommand </FONT></B>

This is introduced in the user manual, section |<A HREF="usr_51.html#51.4">51.4</A>|.

The <A HREF="autocmd.html#autocommand">autocommand</A> is useful if you have a <A HREF="usr_05.html#plugin">plugin</A> that is a long Vim <A HREF="usr_41.html#script">script</A> file.
You can define the <A HREF="autocmd.html#autocommand">autocommand</A> and quickly quit the <A HREF="usr_41.html#script">script</A> with `:finish`.
That makes Vim <A HREF="starting.html#startup">startup</A> faster.  The <A HREF="autocmd.html#autocommand">autocommand</A> should then load the same file
again, setting a variable to skip the `:finish` command.

Use the <A HREF="autocmd.html#FuncUndefined">FuncUndefined</A> <A HREF="autocmd.html#autocommand">autocommand</A> event with a <A HREF="pattern.html#pattern">pattern</A> that matches the
function(s) to be defined.  Example:

<B>	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim</B>

The file &quot;~/vim/bufnetfuncs.vim&quot; should then define <A HREF="#functions">functions</A> that start with
&quot;BufNet&quot;.  Also see |<A HREF="autocmd.html#FuncUndefined">FuncUndefined</A>|.


<B><FONT COLOR="PURPLE">Using an autoload script </FONT></B>

							*<A NAME="autoload"></A><B>autoload</B>* *<A NAME="E746"></A><B>E746</B>*
This is introduced in the user manual, section |<A HREF="usr_52.html#52.2">52.2</A>|.

Using a <A HREF="usr_41.html#script">script</A> in the &quot;<A HREF="#autoload">autoload</A>&quot; directory is simpler, but requires using
exactly the right file name.  A function that can be autoloaded has a name
like this:

<B>	:call filename#funcname()</B>

These <A HREF="#functions">functions</A> are always global, in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> &quot;<A HREF="#g:">g:</A>&quot; needs to be used:
<B>	:call g:filename#funcname()</B>

When such a function is called, and <A HREF="motion.html#it">it</A> is not defined yet, Vim will search the
&quot;<A HREF="#autoload">autoload</A>&quot; directories in <A HREF="options.html#'runtimepath'">'runtimepath'</A> for a <A HREF="usr_41.html#script">script</A> file called
&quot;filename.vim&quot;.  For example &quot;~/.vim/autoload/filename.vim&quot;.  That file should
then define the function like this:

<B>	function filename#funcname()</B>
<B>	   echo "Done!"</B>
<B>	endfunction</B>

The file name and the name used before the # in the function must match
exactly, and the defined function must have the name exactly <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> will be
called.  In <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> the &quot;<A HREF="#g:">g:</A>&quot; prefix must be used:
<B>	function g:filename#funcname()</B>

or for a compiled function:
<B>	def g:filename#funcname()</B>

It is possible to use subdirectories.  Every # in the function name works like
a path separator.  Thus when calling a function:

<B>	:call foo#bar#func()</B>

Vim will look for the file &quot;autoload/foo/bar.vim&quot; in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

This also works when reading a variable that has not been set yet:

<B>	:let l = foo#bar#lvar</B>

However, when the <A HREF="#autoload">autoload</A> <A HREF="usr_41.html#script">script</A> was already loaded <A HREF="motion.html#it">it</A> won't be loaded again
for an unknown variable.

When assigning a value to such a variable nothing special happens.  This can
be used to pass settings to the <A HREF="#autoload">autoload</A> <A HREF="usr_41.html#script">script</A> before it's loaded:

<B>	:let foo#bar#toggle = 1</B>
<B>	:call foo#bar#func()</B>

Note that when you make a mistake and call a function that is supposed to be
defined in an <A HREF="#autoload">autoload</A> <A HREF="usr_41.html#script">script</A>, but the <A HREF="usr_41.html#script">script</A> doesn't actually define the
function, you will get an error message for the missing function.  If you fix
the <A HREF="#autoload">autoload</A> <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> won't be automatically loaded again.  Either restart
Vim or manually source the <A HREF="usr_41.html#script">script</A>.

Also note that if you have two <A HREF="usr_41.html#script">script</A> files, and one calls a function in the
other and vice versa, before the used function is defined, <A HREF="motion.html#it">it</A> won't work.
Avoid using the <A HREF="#autoload">autoload</A> functionality at the toplevel.


In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> you will get error *<A NAME="E1263"></A><B>E1263</B>* if you define a function with
a &quot;<A HREF="pattern.html##">#</A>&quot; character in the name.  You should use a name without &quot;<A HREF="pattern.html##">#</A>&quot; and use
`:export`.

Hint: If you distribute a bunch of scripts you can pack them together with the
|<A HREF="pi_vimball.html#vimball">vimball</A>| utility.  Also read the user manual |<A HREF="usr_51.html#distribute-script">distribute-script</A>|.

==============================================================================

6. Curly braces names					*<A NAME="curly-braces-names"></A><B>curly-braces-names</B>*

In most places where you can use a variable, you can use a &quot;curly braces name&quot;
variable.  This is a regular variable name with one or more expressions
wrapped in braces <A HREF="intro.html#{}">{}</A> like this:
<B>	my_{adjective}_variable</B>

This only works in legacy Vim <A HREF="usr_41.html#script">script</A>, not in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A>.

When Vim encounters this, <A HREF="motion.html#it">it</A> evaluates the <A HREF="#expression">expression</A> inside the braces, puts
that in place of the <A HREF="#expression">expression</A>, and re-interprets the whole <A HREF="motion.html#as">as</A> a variable
name.  So in the above example, if the variable &quot;adjective&quot; was set to
&quot;noisy&quot;, then the reference would be to &quot;my_noisy_variable&quot;, whereas if
&quot;adjective&quot; was set to &quot;quiet&quot;, then <A HREF="motion.html#it">it</A> would be to &quot;my_quiet_variable&quot;.

One application for this is to create a set of <A HREF="#variables">variables</A> governed by an option
value.  For example, the statement
<B>	echo my_{&amp;background}_message</B>

would output the contents of &quot;my_dark_message&quot; or &quot;my_light_message&quot; depending
on the current value of <A HREF="options.html#'background'">'background'</A>.

You can use multiple brace pairs:
<B>	echo my_{adverb}_{adjective}_message</B>
..or even nest them:
<B>	echo my_{ad{end_of_word}}_message</B>
where &quot;end_of_word&quot; is either &quot;verb&quot; or &quot;jective&quot;.

However, the <A HREF="#expression">expression</A> inside the braces must evaluate to a valid single
variable name, e.g. this is invalid:
<B>	:let foo='a + b'</B>
<B>	:echo c{foo}d</B>
.. since the result of expansion is &quot;ca + bd&quot;, which is not a variable name.


						*<A NAME="curly-braces-function-names"></A><B>curly-braces-function-names</B>*
You can call and define <A HREF="#functions">functions</A> by an evaluated name in a similar way.
Example:
<B>	:let func_end='whizz'</B>
<B>	:call my_func_{func_end}(parameter)</B>

This would call the function &quot;my_func_whizz(parameter)&quot;.

This does NOT work:
<B>  :let i = 3</B>
<B>  :let @{i} = ''  " error</B>
<B>  :echo @{i}      " error</B>

==============================================================================

7. Commands						*<A NAME="expression-commands"></A><B>expression-commands</B>*

Note: in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:let` is not used.  `:var` is used for variable
declarations and assignments <A HREF="diff.html#do">do</A> not use a command.  |<A HREF="vim9.html#vim9-declaration">vim9-declaration</A>|


<A HREF="#:let">:let</A> {var-name} = {expr1}				*<A NAME=":let"></A><B>:let</B>* *<A NAME="E18"></A><B>E18</B>*
			Set internal variable {var-name} to the result of the
			<A HREF="#expression">expression</A> {expr1}.  The variable will get the type
			from the {expr}.  If {var-name} didn't exist yet, <A HREF="motion.html#it">it</A>
			is created.


<A HREF="#:let">:let</A> {var-name}[{idx}] = {expr1}			*<A NAME="E689"></A><B>E689</B>* *<A NAME="E1141"></A><B>E1141</B>*
			Set a <A HREF="#list">list</A> item to the result of the <A HREF="#expression">expression</A>
			{expr1}.  {var-name} must refer to a <A HREF="#list">list</A> and {idx}
			must be a valid index in that <A HREF="#list">list</A>.  For nested <A HREF="#list">list</A>
			the index can be repeated.
			This cannot be used to add an item to a |<A HREF="#List">List</A>|.
			This cannot be used to set a byte in a <A HREF="#String">String</A>.  You
			can <A HREF="diff.html#do">do</A> that like this:
<B>				:let var = var[0:2] .. 'X' .. var[4:]</B>
 			When {var-name} is a |<A HREF="#Blob">Blob</A>| then {idx} can be the
			length of the <A HREF="#blob">blob</A>, in which <A HREF="change.html#case">case</A> one byte is
			appended.


					*<A NAME="E711"></A><B>E711</B>* *<A NAME="E719"></A><B>E719</B>* *<A NAME="E1165"></A><B>E1165</B>* *<A NAME="E1166"></A><B>E1166</B>* *<A NAME="E1183"></A><B>E1183</B>*

<A HREF="#:let">:let</A> {var-name}[{idx1}:{idx2}] = {expr1}		*<A NAME="E708"></A><B>E708</B>* *<A NAME="E709"></A><B>E709</B>* *<A NAME="E710"></A><B>E710</B>*
			Set a sequence of items in a |<A HREF="#List">List</A>| to the result of
			the <A HREF="#expression">expression</A> {expr1}, which must be a <A HREF="#list">list</A> with the
			correct number of items.
			{idx1} can be omitted, zero is used instead.
			{idx2} can be omitted, meaning the end of the <A HREF="#list">list</A>.
			When the selected range of items is partly past the
			end of the <A HREF="#list">list</A>, items will be added.


			*<A NAME=":let+="></A><B>:let+=</B>* *<A NAME=":let-="></A><B>:let-=</B>* *<A NAME=":letstar="></A><B>:letstar=</B>* *<A NAME=":let/="></A><B>:let/=</B>*  *<A NAME=":let&#37;="></A><B>:let&#37;=</B>*

			*<A NAME=":let.="></A><B>:let.=</B>* *<A NAME=":let..="></A><B>:let..=</B>* *<A NAME="E734"></A><B>E734</B>* *<A NAME="E985"></A><B>E985</B>* *<A NAME="E1019"></A><B>E1019</B>*
<A HREF="#:let">:let</A> {var} += {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} + {expr1}&quot;.
<A HREF="#:let">:let</A> {var} -= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} - {expr1}&quot;.
<A HREF="#:let">:let</A> {var} *= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} &#42; {expr1}&quot;.
<A HREF="#:let">:let</A> {var} /= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} / {expr1}&quot;.
<A HREF="#:let">:let</A> {var} &#37;= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} <A HREF="motion.html#&#37;">&#37;</A> {expr1}&quot;.
<A HREF="#:let">:let</A> {var} .= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} . {expr1}&quot;.
<A HREF="#:let">:let</A> {var} ..= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} .. {expr1}&quot;.
			These fail if {var} was not set yet and when the type
			of {var} and {expr1} don't fit the <A HREF="motion.html#operator">operator</A>.
			`.=` is not supported with Vim <A HREF="usr_41.html#script">script</A> version 2 and
			later, see |<A HREF="#vimscript-version">vimscript-version</A>|.



<A HREF="#:let">:let</A> ${env-name} = {expr1}			*<A NAME=":let-environment"></A><B>:let-environment</B>* *<A NAME=":let-$"></A><B>:let-$</B>*
			Set environment variable {env-name} to the result of
			the <A HREF="#expression">expression</A> {expr1}.  The type is always <A HREF="#String">String</A>.

			On some systems making an environment variable empty
			causes <A HREF="motion.html#it">it</A> to be deleted.  Many systems <A HREF="diff.html#do">do</A> not make a
			difference between an environment variable that is not
			set and an environment variable that is empty.

<A HREF="#:let">:let</A> ${env-name} .= {expr1}
			Append {expr1} to the environment variable {env-name}.
			If the environment variable didn't exist yet this
			works like &quot;<A HREF="change.html#=">=</A>&quot;.


<A HREF="#:let">:let</A> @{reg-name} = {expr1}			*<A NAME=":let-register"></A><B>:let-register</B>* *<A NAME=":let-@"></A><B>:let-@</B>*
			Write the result of the <A HREF="#expression">expression</A> {expr1} in <A HREF="sponsor.html#register">register</A>
			{reg-name}.  {reg-name} must be a single <A HREF="print.html#letter">letter</A>, and
			must be the name of a writable <A HREF="sponsor.html#register">register</A> (see
			|<A HREF="change.html#registers">registers</A>|).  &quot;<A HREF="repeat.html#@@">@@</A>&quot; can be used for the unnamed
			<A HREF="sponsor.html#register">register</A>, &quot;<A HREF="change.html#@/">@/</A>&quot; for the search <A HREF="pattern.html#pattern">pattern</A>.
			If the result of {expr1} ends in a <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> or <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A>, the
			<A HREF="sponsor.html#register">register</A> will be <A HREF="motion.html#linewise">linewise</A>, otherwise <A HREF="motion.html#it">it</A> will be set to
			<A HREF="motion.html#characterwise">characterwise</A>.
			This can be used to clear the last search <A HREF="pattern.html#pattern">pattern</A>:
<B>				:let @/ = ""</B>
 			This is different from searching for an empty <A HREF="#string">string</A>,
			that would match everywhere.

<A HREF="#:let">:let</A> @{reg-name} .= {expr1}
			Append {expr1} to <A HREF="sponsor.html#register">register</A> {reg-name}.  If the
			<A HREF="sponsor.html#register">register</A> was empty it's like setting <A HREF="motion.html#it">it</A> to {expr1}.


<A HREF="#:let">:let</A> &amp;{option-name} = {expr1}			*<A NAME=":let-option"></A><B>:let-option</B>* *<A NAME=":let-&amp;"></A><B>:let-&amp;</B>*
			Set option {option-name} to the result of the
			<A HREF="#expression">expression</A> {expr1}.  A <A HREF="#String">String</A> or <A HREF="#Number">Number</A> value is
			always converted to the type of the option.
			For an option local to a <A HREF="windows.html#window">window</A> or buffer the effect
			is just like using the |<A HREF="options.html#:set">:set</A>| command: both the local
			value and the global value are changed.
			Example:
<B>				:let &amp;path = &amp;path .. ',/usr/local/include'</B>
 			This also works for <A HREF="terminal.html#terminal">terminal</A> codes in the form t_xx.
			But only for alphanumerical names.  Example:
<B>				:let &amp;t_k1 = "\&lt;Esc&gt;[234;"</B>
 			When the code does not exist yet <A HREF="motion.html#it">it</A> will be created <A HREF="motion.html#as">as</A>
			a <A HREF="terminal.html#terminal">terminal</A> key code, there is no error.

<A HREF="#:let">:let</A> &amp;{option-name} .= {expr1}
			For a <A HREF="#string">string</A> option: Append {expr1} to the value.
			Does not insert a comma like |<A HREF="options.html#:set+=">:set+=</A>|.

<A HREF="#:let">:let</A> &amp;{option-name} += {expr1}
<A HREF="#:let">:let</A> &amp;{option-name} -= {expr1}
			For a number or <A HREF="options.html#boolean">boolean</A> option: Add or subtract
			{expr1}.

<A HREF="#:let">:let</A> &amp;l:{option-name} = {expr1}
<A HREF="#:let">:let</A> &amp;l:{option-name} .= {expr1}
<A HREF="#:let">:let</A> &amp;l:{option-name} += {expr1}
<A HREF="#:let">:let</A> &amp;l:{option-name} -= {expr1}
			Like above, but only set the local value of an option
			(if there is one).  Works like |<A HREF="options.html#:setlocal">:setlocal</A>|.

<A HREF="#:let">:let</A> &amp;g:{option-name} = {expr1}
<A HREF="#:let">:let</A> &amp;g:{option-name} .= {expr1}
<A HREF="#:let">:let</A> &amp;g:{option-name} += {expr1}
<A HREF="#:let">:let</A> &amp;g:{option-name} -= {expr1}
			Like above, but only set the global value of an option
			(if there is one).  Works like |<A HREF="options.html#:setglobal">:setglobal</A>|.

								*<A NAME="E1093"></A><B>E1093</B>*

<A HREF="#:let">:let</A> [{name1}, {name2}, ...] = {expr1}		*<A NAME=":let-unpack"></A><B>:let-unpack</B>* *<A NAME="E687"></A><B>E687</B>* *<A NAME="E688"></A><B>E688</B>*
			{expr1} must evaluate to a |<A HREF="#List">List</A>|.  The first item in
			the <A HREF="#list">list</A> is assigned to {name1}, the second item to
			{name2}, etc.
			The number of names must match the number of items in
			the |<A HREF="#List">List</A>|.
			Each name can be one of the items of the &quot;<A HREF="#:let">:let</A>&quot;
			command <A HREF="motion.html#as">as</A> mentioned above.
			Example:
<B>				:let [s, item] = GetItem(s)</B>
 			Detail: {expr1} is evaluated first, then the
			assignments are done in sequence.  This matters if
			{name2} depends on {name1}.  Example:
<B>				:let x = [0, 1]</B>
<B>				:let i = 0</B>
<B>				:let [i, x[i]] = [1, 2]</B>
<B>				:echo x</B>
 			The result is [0, 2].

<A HREF="#:let">:let</A> [{name1}, {name2}, ...] .= {expr1}
<A HREF="#:let">:let</A> [{name1}, {name2}, ...] += {expr1}
<A HREF="#:let">:let</A> [{name1}, {name2}, ...] -= {expr1}
			Like above, but append/add/subtract the value for each
			|<A HREF="#List">List</A>| item.


<A HREF="#:let">:let</A> [{name}, <A HREF="#...">...</A>, ; {lastname}] = {expr1}				*<A NAME="E452"></A><B>E452</B>*
			Like |<A HREF="#:let-unpack">:let-unpack</A>| above, but the |<A HREF="#List">List</A>| may have more
			items than there are names.  A <A HREF="#list">list</A> of the remaining
			items is assigned to {lastname}.  If there are no
			remaining items {lastname} is set to an empty <A HREF="#list">list</A>.
			Example:
<B>				:let [a, b; rest] = ["aval", "bval", 3, 4]</B>
 
<A HREF="#:let">:let</A> [{name}, <A HREF="#...">...</A>, ; {lastname}] .= {expr1}
<A HREF="#:let">:let</A> [{name}, <A HREF="#...">...</A>, ; {lastname}] += {expr1}
<A HREF="#:let">:let</A> [{name}, <A HREF="#...">...</A>, ; {lastname}] -= {expr1}
			Like above, but append/add/subtract the value for each
			|<A HREF="#List">List</A>| item.


						*<A NAME=":let=&lt;&lt;"></A><B>:let=&lt;&lt;</B>* *<A NAME=":let-heredoc"></A><B>:let-heredoc</B>*

					*<A NAME="E990"></A><B>E990</B>* *<A NAME="E991"></A><B>E991</B>* *<A NAME="E172"></A><B>E172</B>* *<A NAME="E221"></A><B>E221</B>* *<A NAME="E1145"></A><B>E1145</B>*
<A HREF="#:let">:let</A> {var-name} =&lt;&lt; [trim] [eval] {endmarker}
text...
text...
{endmarker}
			Set internal variable {var-name} to a |<A HREF="#List">List</A>|
			containing the lines of text bounded by the <A HREF="#string">string</A>
			{endmarker}.

			If &quot;<A HREF="#eval">eval</A>&quot; is not specified, then each line of text is
			used <A HREF="motion.html#as">as</A> a |<A HREF="#literal-string">literal-string</A>|, except that single <A HREF="quotes.html#quotes">quotes</A>
			does not need to be doubled.
			If &quot;<A HREF="#eval">eval</A>&quot; is specified, then any Vim <A HREF="#expression">expression</A> in the
			form {expr} is evaluated and the result replaces the
			<A HREF="#expression">expression</A>, like with |<A HREF="#interp-string">interp-string</A>|.
			Example where <A HREF="options.html#$HOME">$HOME</A> is expanded:
<B>				let lines =&lt;&lt; trim eval END</B>
<B>				  some text</B>
<B>				  See the file {$HOME}/.vimrc</B>
<B>				  more text</B>
<B>				END</B>
 			There can be multiple Vim expressions in a single line
			but an <A HREF="#expression">expression</A> cannot span multiple lines.  If any
			<A HREF="#expression">expression</A> evaluation fails, then the assignment fails.

			{endmarker} must not contain white space.
			{endmarker} cannot start with a lower <A HREF="change.html#case">case</A> character.
			The last line should end only with the {endmarker}
			<A HREF="#string">string</A> without any other character.  Watch out for
			white space after {endmarker}!

			Without &quot;trim&quot; any white space characters in the lines
			of text are preserved.  If &quot;trim&quot; is specified before
			{endmarker}, then indentation is stripped so you can
			<A HREF="diff.html#do">do</A>:
<B>				let text =&lt;&lt; trim END</B>
<B>				   if ok</B>
<B>				     echo 'done'</B>
<B>				   endif</B>
<B>				END</B>
 			Results in: [&quot;if ok&quot;, &quot;  echo 'done&#39;&#34;', &quot;endif&quot;]
			The marker must line up with &quot;let&quot; and the indentation
			of the first line is removed from all the text lines.
			Specifically: all the leading indentation exactly
			matching the leading indentation of the first
			non-empty text line is stripped from the input lines.
			All leading indentation exactly matching the leading
			indentation before `let` is stripped from the line
			containing {endmarker}.  Note that the difference
			between space and <A HREF="intro.html#tab">tab</A> matters here.

			If {var-name} didn't exist yet, <A HREF="motion.html#it">it</A> is created.
			Cannot be followed by another command, but can be
			followed by a comment.

			To avoid line continuation to be applied, consider
			adding '<A HREF="change.html#C">C</A>' to <A HREF="options.html#'cpoptions'">'cpoptions'</A>:
<B>				set cpo+=C</B>
<B>				let var =&lt;&lt; END</B>
<B>				   \ leading backslash</B>
<B>				END</B>
<B>				set cpo-=C</B>
 
			Examples:
<B>				let var1 =&lt;&lt; END</B>
<B>				Sample text 1</B>
<B>				    Sample text 2</B>
<B>				Sample text 3</B>
<B>				END</B>

<B>				let data =&lt;&lt; trim DATA</B>
<B>					1 2 3 4</B>
<B>					5 6 7 8</B>
<B>				DATA</B>

<B>				let code =&lt;&lt; trim eval CODE</B>
<B>				   let v = {10 + 20}</B>
<B>				   let h = "{$HOME}"</B>
<B>				   let s = "{Str1()} abc {Str2()}"</B>
<B>				   let n = {MyFunc(3, 4)}</B>
<B>				CODE</B>
 

								*<A NAME="E121"></A><B>E121</B>*
<A HREF="#:let">:let</A> {var-name}	..	<A HREF="#List">List</A> the value of variable {var-name}.  Multiple
			variable names may be given.  <A HREF="#Special">Special</A> names recognized

			here:				*<A NAME="E738"></A><B>E738</B>*
			  <A HREF="#g:">g:</A>	global <A HREF="#variables">variables</A>
			  <A HREF="#b:">b:</A>	local buffer <A HREF="#variables">variables</A>
			  <A HREF="#w:">w:</A>	local <A HREF="windows.html#window">window</A> <A HREF="#variables">variables</A>
			  <A HREF="#t:">t:</A>	local <A HREF="intro.html#tab">tab</A> page <A HREF="#variables">variables</A>
			  <A HREF="change.html#s">s</A>:	<A HREF="map.html#script-local">script-local</A> <A HREF="#variables">variables</A>
			  <A HREF="#l:">l:</A>	local function <A HREF="#variables">variables</A>
			  <A HREF="#v:">v:</A>	Vim <A HREF="#variables">variables</A>.
			This does not work in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A>. |<A HREF="vim9.html#vim9-declaration">vim9-declaration</A>|

<A HREF="#:let">:let</A>			<A HREF="#List">List</A> the values of all <A HREF="#variables">variables</A>.  The type of the
			variable is indicated before the value:
			    &lt;nothing&gt;	<A HREF="#String">String</A>
				#	<A HREF="#Number">Number</A>
				&#42;	<A HREF="#Funcref">Funcref</A>
			This does not work in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A>. |<A HREF="vim9.html#vim9-declaration">vim9-declaration</A>|


:unl[et][!] {name} <A HREF="#...">...</A>			*<A NAME=":unlet"></A><B>:unlet</B>* *<A NAME=":unl"></A><B>:unl</B>* *<A NAME="E108"></A><B>E108</B>* *<A NAME="E795"></A><B>E795</B>* *<A NAME="E1081"></A><B>E1081</B>*
			Remove the internal variable {name}.  Several variable
			names can be given, they are all removed.  The name
			may also be a |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>| item.
			With [!] no error message is given for non-existing
			<A HREF="#variables">variables</A>.
			One or more items from a |<A HREF="#List">List</A>| can be removed:
<B>				:unlet list[3]	  " remove fourth item</B>
<B>				:unlet list[3:]   " remove fourth item to last</B>
 			One item from a |<A HREF="#Dictionary">Dictionary</A>| can be removed at a time:
<B>				:unlet dict['two']</B>
<B>				:unlet dict.two</B>
 			This is especially useful to clean up used global
			<A HREF="#variables">variables</A> and <A HREF="map.html#script-local">script-local</A> <A HREF="#variables">variables</A> (these are not
			deleted when the <A HREF="usr_41.html#script">script</A> ends).  Function-local
			<A HREF="#variables">variables</A> are automatically deleted when the function
			ends.


:unl[et] ${env-name} <A HREF="#...">...</A>			*<A NAME=":unlet-environment"></A><B>:unlet-environment</B>* *<A NAME=":unlet-$"></A><B>:unlet-$</B>*
			Remove environment variable {env-name}.
			Can mix {name} and ${env-name} in one <A HREF="#:unlet">:unlet</A> command.
			No error message is given for a non-existing
			variable, also without !.
			If the system does not support <A HREF="change.html#deleting">deleting</A> an environment
			variable, <A HREF="motion.html#it">it</A> is made empty.


						*<A NAME=":cons"></A><B>:cons</B>* *<A NAME=":const"></A><B>:const</B>* *<A NAME="E1018"></A><B>E1018</B>*
:cons[t] {var-name} = {expr1}
:cons[t] [{name1}, {name2}, ...] = {expr1}
:cons[t] [{name}, <A HREF="#...">...</A>, ; {lastname}] = {expr1}
:cons[t] {var-name} =&lt;&lt; [trim] {marker}
text...
text...
{marker}
			Similar to |<A HREF="#:let">:let</A>|, but additionally lock the variable
			after setting the value.  This is the same <A HREF="motion.html#as">as</A> locking
			the variable with |<A HREF="#:lockvar">:lockvar</A>| just after |<A HREF="#:let">:let</A>|, thus:
<B>				:const x = 1</B>
 			is equivalent to:
<B>				:let x = 1</B>
<B>				:lockvar! x</B>
 			NOTE: in <A HREF="vim9.html#Vim9">Vim9</A> <A HREF="usr_41.html#script">script</A> `:const` works differently, see
			|<A HREF="vim9.html#vim9-const">vim9-const</A>|
			This is useful if you want to make sure the variable
			is not modified.  If the value is a <A HREF="#List">List</A> or <A HREF="#Dictionary">Dictionary</A>
			literal then the items also cannot be changed:
<B>				const ll = [1, 2, 3]</B>
<B>				let ll[1] = 5  " Error!</B>
 			Nested references are not locked:
<B>				let lvar = ['a']</B>
<B>				const lconst = [0, lvar]</B>
<B>				let lconst[0] = 2  " Error!</B>
<B>				let lconst[1][0] = 'b'  " OK</B>

 							*<A NAME="E995"></A><B>E995</B>*
			|<A HREF="#:const">:const</A>| does not allow to for <A HREF="change.html#changing">changing</A> a variable:
<B>				:let x = 1</B>
<B>				:const x = 2  " Error!</B>

 							*<A NAME="E996"></A><B>E996</B>*
			Note that environment <A HREF="#variables">variables</A>, option values and
			<A HREF="sponsor.html#register">register</A> values cannot be used here, since they cannot
			be locked.

:cons[t]
:cons[t] {var-name}
			If no argument is given or only {var-name} is given,
			the behavior is the same <A HREF="motion.html#as">as</A> |<A HREF="#:let">:let</A>|.


:lockv[ar][!] [depth] {name} <A HREF="#...">...</A>			*<A NAME=":lockvar"></A><B>:lockvar</B>* *<A NAME=":lockv"></A><B>:lockv</B>*
			Lock the internal variable {name}.  Locking means that
			<A HREF="motion.html#it">it</A> can no longer be changed (until <A HREF="motion.html#it">it</A> is unlocked).
			A locked variable can be deleted:
<B>				:lockvar v</B>
<B>				:let v = 'asdf'	  " fails!</B>
<B>				:unlet v	  " works</B>

 			*<A NAME="E741"></A><B>E741</B>* *<A NAME="E940"></A><B>E940</B>* *<A NAME="E1118"></A><B>E1118</B>* *<A NAME="E1119"></A><B>E1119</B>* *<A NAME="E1120"></A><B>E1120</B>* *<A NAME="E1121"></A><B>E1121</B>* *<A NAME="E1122"></A><B>E1122</B>*
			If you try to change a locked variable you get an
			error message: &quot;E741: Value is locked: {name}&quot;.
			If you try to lock or unlock a built-in variable you
			get an error message: &quot;E940: Cannot lock or unlock
			variable {name}&quot;.

			[depth] is relevant when locking a |<A HREF="#List">List</A>| or
			|<A HREF="#Dictionary">Dictionary</A>|.  It specifies how deep the locking goes:
				0	Lock the variable {name} but not its
					value.
				1	Lock the |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>| itself,
					cannot add or remove items, but can
					still change their values.
				2	Also lock the values, cannot change
					the items.  If an item is a |<A HREF="#List">List</A>| or
					|<A HREF="#Dictionary">Dictionary</A>|, cannot add or remove
					items, but can still change the
					values.
				3	Like 2 but for the |<A HREF="#List">List</A>| /
					|<A HREF="#Dictionary">Dictionary</A>| in the |<A HREF="#List">List</A>| /
					|<A HREF="#Dictionary">Dictionary</A>|, one level deeper.
			The default [depth] is 2, thus when {name} is a |<A HREF="#List">List</A>|
			or |<A HREF="#Dictionary">Dictionary</A>| the values cannot be changed.

			Example with [depth] 0:
<B>				let mylist = [1, 2, 3]</B>
<B>				lockvar 0 mylist</B>
<B>				let mylist[0] = 77	" OK</B>
<B>				call add(mylist, 4]	" OK</B>
<B>				let mylist = [7, 8, 9]  " Error!</B>

 								*<A NAME="E743"></A><B>E743</B>*
			For unlimited depth use [!] and omit [depth].
			However, there is a maximum depth of 100 to catch
			loops.

			Note that when two <A HREF="#variables">variables</A> refer to the same |<A HREF="#List">List</A>|
			and you lock one of them, the |<A HREF="#List">List</A>| will also be
			locked when used through the other variable.
			Example:
<B>				:let l = [0, 1, 2, 3]</B>
<B>				:let cl = l</B>
<B>				:lockvar l</B>
<B>				:let cl[1] = 99		" won't work!</B>
 			You may want to make a copy of a <A HREF="#list">list</A> to avoid this.
			See |<A HREF="builtin.html#deepcopy()">deepcopy()</A>|.



:unlo[ckvar][!] [depth] {name} <A HREF="#...">...</A>		*<A NAME=":unlockvar"></A><B>:unlockvar</B>* *<A NAME=":unlo"></A><B>:unlo</B>* *<A NAME="E1246"></A><B>E1246</B>*
			Unlock the internal variable {name}.  Does the
			opposite of |<A HREF="#:lockvar">:lockvar</A>|.


<A HREF="#:if">:if</A> {expr1}			*<A NAME=":if"></A><B>:if</B>* *<A NAME=":end"></A><B>:end</B>* *<A NAME=":endif"></A><B>:endif</B>* *<A NAME=":en"></A><B>:en</B>* *<A NAME="E171"></A><B>E171</B>* *<A NAME="E579"></A><B>E579</B>* *<A NAME="E580"></A><B>E580</B>*
:en[dif]		Execute the commands until the next matching `:else`
			or `:endif` if {expr1} evaluates to non-zero.
			Although the short forms work, <A HREF="motion.html#it">it</A> is recommended to
			always use `:endif` to avoid confusion and to make
			auto-indenting work properly.

			From Vim version 4.5 until 5.0, every <A HREF="intro.html#Ex">Ex</A> command in
			between the `:if` and `:endif` is ignored.  These two
			commands were just to allow for future expansions in a
			backward compatible way.  Nesting was allowed.  Note
			that any `:else` or `:elseif` was ignored, the `else`
			part was not executed either.

			You can use this to remain compatible with older
			versions:
<B>				:if version &gt;= 500</B>
<B>				:  version-5-specific-commands</B>
<B>				:endif</B>
 			The commands still need to be parsed to find the
			`endif`.  Sometimes an older Vim has a problem with a
			new command.  For example, `:silent` is recognized <A HREF="motion.html#as">as</A>
			a `:substitute` command.  In that <A HREF="change.html#case">case</A> `:execute` can
			avoid problems:
<B>				:if version &gt;= 600</B>
<B>				:  execute "silent 1,$delete"</B>
<B>				:endif</B>
 
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:endif` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.
			NOTE: The `:append` and `:insert` commands don't work
			properly in between `:if` and `:endif`.


						*<A NAME=":else"></A><B>:else</B>* *<A NAME=":el"></A><B>:el</B>* *<A NAME="E581"></A><B>E581</B>* *<A NAME="E583"></A><B>E583</B>*
:el[se]			Execute the commands until the next matching `:else`
			or `:endif` if they previously were not being
			executed.
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:else` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.


					*<A NAME=":elseif"></A><B>:elseif</B>* *<A NAME=":elsei"></A><B>:elsei</B>* *<A NAME="E582"></A><B>E582</B>* *<A NAME="E584"></A><B>E584</B>*
:elsei[f] {expr1}	Short for `:else` `:if`, with the addition that there
			is no extra `:endif`.
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:elseif` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.


:wh[ile] {expr1}			*<A NAME=":while"></A><B>:while</B>* *<A NAME=":endwhile"></A><B>:endwhile</B>* *<A NAME=":wh"></A><B>:wh</B>* *<A NAME=":endw"></A><B>:endw</B>*

						*<A NAME="E170"></A><B>E170</B>* *<A NAME="E585"></A><B>E585</B>* *<A NAME="E588"></A><B>E588</B>* *<A NAME="E733"></A><B>E733</B>*
:endw[hile]		Repeat the commands between `:while` and `:endwhile`,
			<A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> {expr1} evaluates to non-zero.
			When an error is detected from a command inside the
			loop, execution continues after the `endwhile`.
			Example:
<B>				:let lnum = 1</B>
<B>				:while lnum &lt;= line("$")</B>
<B>				   :call FixLine(lnum)</B>
<B>				   :let lnum = lnum + 1</B>
<B>				:endwhile</B>
 
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:while`  and `:endwhile` cannot be
			shortened, to improve <A HREF="usr_41.html#script">script</A> readability.
			NOTE: The `:append` and `:insert` commands don't work
			properly inside a `:while` and `:for` loop.


<A HREF="#:for">:for</A> {var} in {object}					*<A NAME=":for"></A><B>:for</B>* *<A NAME="E690"></A><B>E690</B>* *<A NAME="E732"></A><B>E732</B>*

:endfo[r]						*<A NAME=":endfo"></A><B>:endfo</B>* *<A NAME=":endfor"></A><B>:endfor</B>*
			Repeat the commands between `:for` and `:endfor` for
			each item in {object}.  {object} can be a |<A HREF="#List">List</A>|,

			a |<A HREF="#Blob">Blob</A>| or a |<A HREF="#String">String</A>|. *<A NAME="E1177"></A><B>E1177</B>*

			Variable {var} is set to the value of each item.
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the loop variable must not have been
			declared yet, unless when <A HREF="motion.html#it">it</A> is a
			global/window/tab/buffer variable.

			When an error is detected for a command inside the
			loop, execution continues after the `endfor`.
			Changing {object} inside the loop affects what items
			are used.  Make a copy if this is unwanted:
<B>				:for item in copy(mylist)</B>
 
			When {object} is a |<A HREF="#List">List</A>| and not making a copy, in
			legacy <A HREF="usr_41.html#script">script</A> Vim stores a reference to the next item
			in the |<A HREF="#List">List</A>| before executing the commands with the
			current item.  Thus the current item can be removed
			without effect.  Removing any later item means <A HREF="motion.html#it">it</A> will
			not be found.  Thus the following example works (an
			inefficient way to make a |<A HREF="#List">List</A>| empty):
<B>				for item in mylist</B>
<B>				   call remove(mylist, 0)</B>
<B>				endfor</B>
 			Note that reordering the |<A HREF="#List">List</A>| (e.g., with <A HREF="builtin.html#sort()">sort()</A> or
			<A HREF="builtin.html#reverse()">reverse()</A>) may have unexpected effects.
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> the index is used.  If an item before
			the current one is deleted the next item will be
			skipped.

			When {object} is a |<A HREF="#Blob">Blob</A>|, Vim always makes a copy to
			iterate over.  Unlike with |<A HREF="#List">List</A>|, modifying the
			|<A HREF="#Blob">Blob</A>| does not affect the iteration.

			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:endfor` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.

<A HREF="#:for">:for</A> [{var1}, {var2}, ...] in {listlist}

:endfo[r]							*<A NAME="E1140"></A><B>E1140</B>*
			Like `:for` above, but each item in {listlist} must be
			a <A HREF="#list">list</A>, of which each item is assigned to {var1},
			{var2}, etc.  Example:
<B>				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]</B>
<B>				   :echo getline(lnum)[col]</B>
<B>				:endfor</B>
 

						*<A NAME=":continue"></A><B>:continue</B>* *<A NAME=":con"></A><B>:con</B>* *<A NAME="E586"></A><B>E586</B>*
:con[tinue]		When used inside a `:while` or `:for` loop, jumps back
			to the start of the loop.
			If <A HREF="motion.html#it">it</A> is used after a `:try` inside the loop but
			before the matching `:finally` (if present), the
			commands following the `:finally` up to the matching
			`:endtry` are executed first.  This process applies to
			all nested `:try`s inside the loop.  The outermost
			`:endtry` then jumps back to the start of the loop.

			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:cont` is the shortest form, to
			improve <A HREF="usr_41.html#script">script</A> readability.

						*<A NAME=":break"></A><B>:break</B>* *<A NAME=":brea"></A><B>:brea</B>* *<A NAME="E587"></A><B>E587</B>*
:brea[k]		When used inside a `:while` or `:for` loop, skips to
			the command after the matching `:endwhile` or
			`:endfor`.
			If <A HREF="motion.html#it">it</A> is used after a `:try` inside the loop but
			before the matching `:finally` (if present), the
			commands following the `:finally` up to the matching
			`:endtry` are executed first.  This process applies to
			all nested `:try`s inside the loop.  The outermost
			`:endtry` then jumps to the command after the loop.

			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:break` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.


<A HREF="#:try">:try</A>						*<A NAME=":try"></A><B>:try</B>* *<A NAME=":endt"></A><B>:endt</B>* *<A NAME=":endtry"></A><B>:endtry</B>*

						*<A NAME="E600"></A><B>E600</B>* *<A NAME="E601"></A><B>E601</B>* *<A NAME="E602"></A><B>E602</B>* *<A NAME="E1032"></A><B>E1032</B>*
:endt[ry]		Change the error handling for the commands between
			`:try` and `:endtry` including everything being
			executed across `:source` commands, function calls,
			or <A HREF="autocmd.html#autocommand">autocommand</A> invocations.

			When an error or interrupt is detected and there is
			a `:finally` command following, execution continues
			after the `:finally`.  Otherwise, or when the
			`:endtry` is reached thereafter, the next
			(dynamically) surrounding `:try` is checked for
			a corresponding `:finally` etc.  Then the <A HREF="usr_41.html#script">script</A>
			processing is terminated.  Whether a function
			definition has an &quot;abort&quot; argument does not matter.
			Example:
<B>		try | call Unknown() | finally | echomsg "cleanup" | endtry</B>
<B>		echomsg "not reached"</B>
 
			Moreover, an error or interrupt (dynamically) inside
			`:try` and `:endtry` is converted to an exception.  It
			can be caught <A HREF="motion.html#as">as</A> if <A HREF="motion.html#it">it</A> were thrown by a `:throw`
			command (see `:catch`).  In this <A HREF="change.html#case">case</A>, the <A HREF="usr_41.html#script">script</A>
			processing is not terminated.

			The value &quot;Vim:Interrupt&quot; is used for an interrupt
			exception.  An error in a Vim command is converted
			to a value of the form &quot;Vim({command}):{errmsg}&quot;,
			other <A HREF="message.html#errors">errors</A> are converted to a value of the form
			&quot;Vim:{errmsg}&quot;.  {command} is the full command name,
			and {errmsg} is the message that is displayed if the
			error exception is not caught, always beginning with
			the error number.
			Examples:
<B>		try | sleep 100 | catch /^Vim:Interrupt$/ | endtry</B>
<B>		try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry</B>
 
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:endtry` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.


					*<A NAME=":cat"></A><B>:cat</B>* *<A NAME=":catch"></A><B>:catch</B>*

					*<A NAME="E603"></A><B>E603</B>* *<A NAME="E604"></A><B>E604</B>* *<A NAME="E605"></A><B>E605</B>* *<A NAME="E654"></A><B>E654</B>* *<A NAME="E1033"></A><B>E1033</B>*
:cat[ch] /{pattern}/	The following commands until the next `:catch`,
			`:finally`, or `:endtry` that belongs to the same
			`:try` <A HREF="motion.html#as">as</A> the `:catch` are executed when an exception
			matching {pattern} is being thrown and has not yet
			been caught by a previous `:catch`.  Otherwise, these
			commands are skipped.
			When {pattern} is omitted all <A HREF="message.html#errors">errors</A> are caught.
			Examples:
<B>		:catch /^Vim:Interrupt$/	 " catch interrupts (CTRL-C)</B>
<B>		:catch /^Vim\%((\a\+)\)\=:E/	 " catch all Vim errors</B>
<B>		:catch /^Vim\%((\a\+)\)\=:/	 " catch errors and interrupts</B>
<B>		:catch /^Vim(write):/		 " catch all errors in :write</B>
<B>		:catch /^Vim\%((\a\+)\)\=:E123:/ " catch error E123</B>
<B>		:catch /my-exception/		 " catch user exception</B>
<B>		:catch /.*/			 " catch everything</B>
<B>		:catch				 " same as /.*/</B>
 
			Another character can be used instead of / around the
			{pattern}, so long <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> does not have a special
			meaning (e.g., '&#124;' or &#39;&#34;'') and doesn't occur inside

			{pattern}. *<A NAME="E1067"></A><B>E1067</B>*
			Information about the exception is available in
			|<A HREF="#v:exception">v:exception</A>|.  Also see |<A HREF="#throw-variables">throw-variables</A>|.
			NOTE: It is not reliable to &quot;<A HREF="#:catch">:catch</A>&quot; the TEXT of
			an error message because <A HREF="motion.html#it">it</A> may vary in different
			locales.
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:catch` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.


					*<A NAME=":fina"></A><B>:fina</B>* *<A NAME=":finally"></A><B>:finally</B>* *<A NAME="E606"></A><B>E606</B>* *<A NAME="E607"></A><B>E607</B>*
:fina[lly]		The following commands until the matching `:endtry`
			are executed whenever the part between the matching
			`:try` and the `:finally` is left:  either by falling
			through to the `:finally` or by a `:continue`,
			`:break`, `:finish`, or `:return`, or by an error or
			interrupt or exception (see `:throw`).

			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:finally` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability and avoid confusion with
			`:final`.


						*<A NAME=":th"></A><B>:th</B>* *<A NAME=":throw"></A><B>:throw</B>* *<A NAME="E608"></A><B>E608</B>* *<A NAME="E1129"></A><B>E1129</B>*
:th[row] {expr1}	The {expr1} is evaluated and thrown <A HREF="motion.html#as">as</A> an exception.
			If the &quot;<A HREF="#:throw">:throw</A>&quot; is used after a `:try` but before the
			first corresponding `:catch`, commands are skipped
			until the first `:catch` matching {expr1} is reached.
			If there is no such `:catch` or if the &quot;<A HREF="#:throw">:throw</A>&quot; is
			used after a `:catch` but before the `:finally`, the
			commands following the `:finally` (if present) up to
			the matching `:endtry` are executed.  If the `:throw`
			is after the `:finally`, commands up to the `:endtry`
			are skipped.  At the &quot;<A HREF="#:endtry">:endtry</A>&quot;, this process applies
			again for the next dynamically surrounding `:try`
			(which may be found in a calling function or sourcing
			script), until a matching `:catch` has been found.
			If the exception is not caught, the command processing
			is terminated.
			Example:
<B>		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry</B>
 			Note that &quot;catch&quot; may need to be on a separate line
			for when an error causes the parsing to skip the whole
			line and not see the &quot;|&quot; that separates the commands.

			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> `:throw` cannot be shortened, to
			improve <A HREF="usr_41.html#script">script</A> readability.


							*<A NAME=":ec"></A><B>:ec</B>* *<A NAME=":echo"></A><B>:echo</B>*
:ec[ho] {expr1} ..	Echoes each {expr1}, with a space in between.  The
			first {expr1} starts on a new line.
			Also see |<A HREF="cmdline.html#:comment">:comment</A>|.
			Use &quot;\n&quot; to start a new line.  Use &quot;\r&quot; to move the
			cursor to the first column.
			Uses the highlighting set by the `:echohl` command.
			Cannot be followed by a comment.
			Example:
<B>		:echo "the value of 'shell' is" &amp;shell</B>

 							*<A NAME=":echo-redraw"></A><B>:echo-redraw</B>*
			A later redraw may make the message disappear again.
			And since Vim mostly postpones redrawing until it's
			finished with a sequence of commands this happens
			quite often.  To avoid that a command from before the
			`:echo` causes a redraw afterwards (redraws are often
			postponed until you type something), force a redraw
			with the `:redraw` command.  Example:
<B>		:new | redraw | echo "there is a new window"</B>
 

							*<A NAME=":echon"></A><B>:echon</B>*
<A HREF="#:echon">:echon</A> {expr1} ..	Echoes each {expr1}, without anything added.  Also see
			|<A HREF="cmdline.html#:comment">:comment</A>|.
			Uses the highlighting set by the `:echohl` command.
			Cannot be followed by a comment.
			Example:
<B>				:echon "the value of 'shell' is " &amp;shell</B>
 
			Note the difference between using `:echo`, which is a
			Vim command, and `:!echo`, which is an external shell
			command:
<B>		:!echo %		--&gt; filename</B>
 			The arguments of &quot;<A HREF="various.html#:!">:!</A>&quot; are expanded, see |<A HREF="cmdline.html#:_&#37;">:_&#37;</A>|.
<B>		:!echo "%"		--&gt; filename or "filename"</B>
 			Like the previous example.  Whether you see the double
			<A HREF="quotes.html#quotes">quotes</A> or not depends on your <A HREF="options.html#'shell'">'shell'</A>.
<B>		:echo %			--&gt; nothing</B>
 			The '<A HREF="motion.html#&#37;">&#37;</A>' is an illegal character in an <A HREF="#expression">expression</A>.
<B>		:echo "%"		--&gt; %</B>
 			This just echoes the '<A HREF="motion.html#&#37;">&#37;</A>' character.
<B>		:echo expand("%")	--&gt; filename</B>
 			This calls the <A HREF="builtin.html#expand()">expand()</A> function to expand the '<A HREF="motion.html#&#37;">&#37;</A>'.


							*<A NAME=":echoh"></A><B>:echoh</B>* *<A NAME=":echohl"></A><B>:echohl</B>*
:echoh[l] {name}	Use the highlight group {name} for the following
			`:echo`, `:echon` and `:echomsg` commands.  Also used
			for the `input()` prompt.  Example:
<B>		:echohl WarningMsg | echo "Don't panic!" | echohl None</B>
 			Don't forget to set the group back to &quot;<A HREF="#None">None</A>&quot;,
			otherwise all following echo's will be highlighted.


							*<A NAME=":echom"></A><B>:echom</B>* *<A NAME=":echomsg"></A><B>:echomsg</B>*
:echom[sg] {expr1} ..	Echo the expression(s) <A HREF="motion.html#as">as</A> a <A HREF="vim9.html#true">true</A> message, saving the
			message in the |<A HREF="message.html#message-history">message-history</A>|.
			Spaces are placed between the arguments <A HREF="motion.html#as">as</A> with the
			`:echo` command.  But unprintable characters are
			displayed, not interpreted.
			The parsing works slightly different from `:echo`,
			more like `:execute`.  All the expressions are first
			evaluated and concatenated before echoing anything.
			If expressions does not evaluate to a <A HREF="#Number">Number</A> or
			<A HREF="#String">String</A>, <A HREF="builtin.html#string()">string()</A> is used to turn <A HREF="motion.html#it">it</A> into a <A HREF="#string">string</A>.
			Uses the highlighting set by the `:echohl` command.
			Example:
<B>		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."</B>
 			See |<A HREF="#:echo-redraw">:echo-redraw</A>| to avoid the message disappearing
			when the screen is redrawn.

							*<A NAME=":echoe"></A><B>:echoe</B>* *<A NAME=":echoerr"></A><B>:echoerr</B>*
:echoe[rr] {expr1} ..	Echo the expression(s) <A HREF="motion.html#as">as</A> an error message, saving the
			message in the |<A HREF="message.html#message-history">message-history</A>|.  When used in a
			<A HREF="usr_41.html#script">script</A> or function the line number will be added.
			Spaces are placed between the arguments <A HREF="motion.html#as">as</A> with the
			`:echomsg` command.  When used inside a try conditional,
			the message is raised <A HREF="motion.html#as">as</A> an error exception instead
			(see |<A HREF="#try-echoerr">try-echoerr</A>|).
			Example:
<B>		:echoerr "This script just failed!"</B>
 			If you just want a highlighted message use `:echohl`.
			And to get a beep:
<B>		:exe "normal \&lt;Esc&gt;"</B>


:echoc[onsole] {expr1} ..				*<A NAME=":echoc"></A><B>:echoc</B>* *<A NAME=":echoconsole"></A><B>:echoconsole</B>*
			Intended for <A HREF="testing.html#testing">testing</A>: works like `:echomsg` but when
			running in the <A HREF="gui.html#GUI">GUI</A> and started from a <A HREF="terminal.html#terminal">terminal</A> write
			the text to stdout.


							*<A NAME=":eval"></A><B>:eval</B>*
<A HREF="#:eval">:eval</A> {expr}		Evaluate {expr} and <A HREF="editing.html#discard">discard</A> the result.  Example:
<B>				:eval Getlist()-&gt;Filter()-&gt;append('$')</B>

 			The <A HREF="#expression">expression</A> is supposed to have a side effect,
			since the resulting value is not used.  In the example
			the `append()` call appends the <A HREF="#List">List</A> with text to the
			buffer.  This is similar to `:call` but works with any
			<A HREF="#expression">expression</A>.
			In |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> an <A HREF="#expression">expression</A> without an effect will

			result in error *<A NAME="E1207"></A><B>E1207</B>* .  This should help noticing
			mistakes.

			The command can be shortened to `:ev` or `:eva`, but
			these are hard to recognize and therefore not to be
			used.

			The command cannot be followed by &quot;|&quot; and another
			command, since &quot;|&quot; is seen <A HREF="motion.html#as">as</A> part of the <A HREF="#expression">expression</A>.



							*<A NAME=":exe"></A><B>:exe</B>* *<A NAME=":execute"></A><B>:execute</B>*
:exe[cute] {expr1} ..	Executes the <A HREF="#string">string</A> that results from the evaluation
			of {expr1} <A HREF="motion.html#as">as</A> an <A HREF="intro.html#Ex">Ex</A> command.
			Multiple arguments are concatenated, with a space in
			between.  To avoid the extra space use the &quot;..&quot;
			<A HREF="motion.html#operator">operator</A> to concatenate strings into one argument.
			{expr1} is used <A HREF="motion.html#as">as</A> the processed command, command line
			editing keys are not recognized.
			Cannot be followed by a comment.
			Examples:
<B>		:execute "buffer" nextbuf</B>
<B>		:execute "normal" count .. "w"</B>
 
			&quot;<A HREF="#:execute">:execute</A>&quot; can be used to append a command to commands
			that don't accept a '&#124;'.  Example:
<B>		:execute '!ls' | echo "theend"</B>

 			&quot;<A HREF="#:execute">:execute</A>&quot; is also a nice way to avoid having to type
			<A HREF="intro.html#control">control</A> characters in a Vim <A HREF="usr_41.html#script">script</A> for a &quot;<A HREF="various.html#:normal">:normal</A>&quot;
			command:
<B>		:execute "normal ixxx\&lt;Esc&gt;"</B>
 			This has an <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> character, see |<A HREF="#expr-string">expr-string</A>|.

			Be careful to correctly <A HREF="intro.html#escape">escape</A> special characters in
			file names.  The |<A HREF="builtin.html#fnameescape()">fnameescape()</A>| function can be used
			for Vim commands, |<A HREF="builtin.html#shellescape()">shellescape()</A>| for |<A HREF="various.html#:!">:!</A>| commands.
			Examples:
<B>		:execute "e " .. fnameescape(filename)</B>
<B>		:execute "!ls " .. shellescape(filename, 1)</B>
 
			Note: The executed <A HREF="#string">string</A> may be any command-line, but
			starting or ending &quot;if&quot;, &quot;while&quot; and &quot;for&quot; does not
			always work, because when commands are skipped the
			&quot;<A HREF="#:execute">:execute</A>&quot; is not evaluated and Vim loses track of
			where blocks start and end.  Also &quot;break&quot; and
			&quot;continue&quot; should not be inside &quot;<A HREF="#:execute">:execute</A>&quot;.
			This example does not work, because the &quot;<A HREF="#:execute">:execute</A>&quot; is
			not evaluated and Vim does not see the &quot;while&quot;, and
			gives an error for finding an &quot;<A HREF="#:endwhile">:endwhile</A>&quot;:
<B>		:if 0</B>
<B>		: execute 'while i &gt; 5'</B>
<B>		:  echo "test"</B>
<B>		: endwhile</B>
<B>		:endif</B>
 
			It is allowed to have a &quot;while&quot; or &quot;if&quot; command
			completely in the executed <A HREF="#string">string</A>:
<B>		:execute 'while i &lt; 5 | echo i | let i = i + 1 | endwhile'</B>
 


							*<A NAME=":exe-comment"></A><B>:exe-comment</B>*
			&quot;<A HREF="#:execute">:execute</A>&quot;, &quot;<A HREF="#:echo">:echo</A>&quot; and &quot;<A HREF="#:echon">:echon</A>&quot; cannot be followed by
			a comment directly, because they see the &#39;&#34;'' <A HREF="motion.html#as">as</A> the
			start of a <A HREF="#string">string</A>.  But, you can use '&#124;' followed by a
			comment.  Example:
<B>		:echo "foo" | "this is a comment</B>

==============================================================================

8. Exception handling					*<A NAME="exception-handling"></A><B>exception-handling</B>*

The Vim <A HREF="usr_41.html#script">script</A> language comprises an exception handling feature.  This section
explains how <A HREF="motion.html#it">it</A> can be used in a Vim <A HREF="usr_41.html#script">script</A>.

Exceptions may be raised by Vim on an error or on interrupt, see
|<A HREF="#catch-errors">catch-errors</A>| and |<A HREF="#catch-interrupt">catch-interrupt</A>|.  You can also explicitly throw an
exception by using the &quot;<A HREF="#:throw">:throw</A>&quot; command, see |<A HREF="#throw-catch">throw-catch</A>|.



TRY CONDITIONALS					*<A NAME="try-conditionals"></A><B>try-conditionals</B>*

Exceptions can be caught or can cause cleanup code to be executed.  You can
use a try conditional to specify catch clauses (that catch exceptions) and/or
a finally clause (to be executed for cleanup).
   A try conditional begins with a |<A HREF="#:try">:try</A>| command and ends at the matching
|<A HREF="#:endtry">:endtry</A>| command.  In between, you can use a |<A HREF="#:catch">:catch</A>| command to start
a catch clause, or a |<A HREF="#:finally">:finally</A>| command to start a finally clause.  There may
be none or multiple catch clauses, but there is at most one finally clause,
which must not be followed by any catch clauses.  The lines before the catch
clauses and the finally clause is called a try block.

<B>     :try</B>
<B>     :	...</B>
<B>     :	...				TRY BLOCK</B>
<B>     :	...</B>
<B>     :catch /{pattern}/</B>
<B>     :	...</B>
<B>     :	...				CATCH CLAUSE</B>
<B>     :	...</B>
<B>     :catch /{pattern}/</B>
<B>     :	...</B>
<B>     :	...				CATCH CLAUSE</B>
<B>     :	...</B>
<B>     :finally</B>
<B>     :	...</B>
<B>     :	...				FINALLY CLAUSE</B>
<B>     :	...</B>
<B>     :endtry</B>

The try conditional allows to watch code for exceptions and to take the
appropriate actions.  Exceptions from the try block may be caught.  Exceptions
from the try block and also the catch clauses may cause cleanup actions.
   When no exception is thrown during execution of the try block, the <A HREF="intro.html#control">control</A>
is transferred to the finally clause, if present.  After its execution, the
<A HREF="usr_41.html#script">script</A> continues with the line following the &quot;<A HREF="#:endtry">:endtry</A>&quot;.
   When an exception occurs during execution of the try block, the remaining
lines in the try block are skipped.  The exception is matched against the
patterns specified <A HREF="motion.html#as">as</A> arguments to the &quot;<A HREF="#:catch">:catch</A>&quot; commands.  The catch clause
after the first matching &quot;<A HREF="#:catch">:catch</A>&quot; is taken, other catch clauses are not
executed.  The catch clause ends when the next &quot;<A HREF="#:catch">:catch</A>&quot;, &quot;<A HREF="#:finally">:finally</A>&quot;, or
&quot;<A HREF="#:endtry">:endtry</A>&quot; command is reached - whatever is first.  Then, the finally clause
(if present) is executed.  When the &quot;<A HREF="#:endtry">:endtry</A>&quot; is reached, the <A HREF="usr_41.html#script">script</A> execution
continues in the following line <A HREF="motion.html#as">as</A> usual.
   When an exception that does not match any of the patterns specified by the
&quot;<A HREF="#:catch">:catch</A>&quot; commands is thrown in the try block, the exception is not caught by
that try conditional and none of the catch clauses is executed.  Only the
finally clause, if present, is taken.  The exception pends during execution of
the finally clause.  It is resumed at the &quot;<A HREF="#:endtry">:endtry</A>&quot;, so that commands after
the &quot;<A HREF="#:endtry">:endtry</A>&quot; are not executed and the exception might be caught elsewhere,
see |<A HREF="#try-nesting">try-nesting</A>|.
   When during execution of a catch clause another exception is thrown, the
remaining lines in that catch clause are not executed.  The new exception is
not matched against the patterns in any of the &quot;<A HREF="#:catch">:catch</A>&quot; commands of the same
try conditional and none of its catch clauses is taken.  If there is, however,
a finally clause, <A HREF="motion.html#it">it</A> is executed, and the exception pends during its
execution.  The commands following the &quot;<A HREF="#:endtry">:endtry</A>&quot; are not executed.  The new
exception might, however, be caught elsewhere, see |<A HREF="#try-nesting">try-nesting</A>|.
   When during execution of the finally clause (if present) an exception is
thrown, the remaining lines in the finally clause are skipped.  If the finally
clause has been taken because of an exception from the try block or one of the
catch clauses, the original (pending) exception is discarded.  The commands
following the &quot;<A HREF="#:endtry">:endtry</A>&quot; are not executed, and the exception from the finally
clause is propagated and can be caught elsewhere, see |<A HREF="#try-nesting">try-nesting</A>|.

The finally clause is also executed, when a &quot;<A HREF="#:break">:break</A>&quot; or &quot;<A HREF="#:continue">:continue</A>&quot; for
a &quot;<A HREF="#:while">:while</A>&quot; loop enclosing the complete try conditional is executed from the
try block or a catch clause.  Or when a &quot;<A HREF="#:return">:return</A>&quot; or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; is executed
from the try block or a catch clause of a try conditional in a function or
sourced <A HREF="usr_41.html#script">script</A>, respectively.  The &quot;<A HREF="#:break">:break</A>&quot;, &quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="#:return">:return</A>&quot;, or
&quot;<A HREF="repeat.html#:finish">:finish</A>&quot; pends during execution of the finally clause and is resumed when the
&quot;<A HREF="#:endtry">:endtry</A>&quot; is reached.  It is, however, discarded when an exception is thrown
from the finally clause.
   When a &quot;<A HREF="#:break">:break</A>&quot; or &quot;<A HREF="#:continue">:continue</A>&quot; for a &quot;<A HREF="#:while">:while</A>&quot; loop enclosing the complete
try conditional or when a &quot;<A HREF="#:return">:return</A>&quot; or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; is encountered in the finally
clause, the rest of the finally clause is skipped, and the &quot;<A HREF="#:break">:break</A>&quot;,
&quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="#:return">:return</A>&quot; or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; is executed <A HREF="motion.html#as">as</A> usual.  If the finally
clause has been taken because of an exception or an earlier &quot;<A HREF="#:break">:break</A>&quot;,
&quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="#:return">:return</A>&quot;, or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; from the try block or a catch clause,
this pending exception or command is discarded.

For examples see |<A HREF="#throw-catch">throw-catch</A>| and |<A HREF="#try-finally">try-finally</A>|.



NESTING	OF TRY CONDITIONALS				*<A NAME="try-nesting"></A><B>try-nesting</B>*

Try conditionals can be nested arbitrarily.  That is, a complete try
conditional can be put into the try block, a catch clause, or the finally
clause of another try conditional.  If the inner try conditional does not
catch an exception thrown in its try block or throws a new exception from one
of its catch clauses or its finally clause, the outer try conditional is
checked according to the rules above.  If the inner try conditional is in the
try block of the outer try conditional, its catch clauses are checked, but
otherwise only the finally clause is executed.  It does not matter for
nesting, whether the inner try conditional is directly contained in the outer
one, or whether the outer one sources a <A HREF="usr_41.html#script">script</A> or calls a function containing
the inner try conditional.

When none of the active try conditionals catches an exception, just their
finally clauses are executed.  Thereafter, the <A HREF="usr_41.html#script">script</A> processing terminates.
An error message is displayed in <A HREF="change.html#case">case</A> of an uncaught exception explicitly
thrown by a &quot;<A HREF="#:throw">:throw</A>&quot; command.  For uncaught error and interrupt exceptions
implicitly raised by Vim, the error message(s) or interrupt message are shown
<A HREF="motion.html#as">as</A> usual.

For examples see |<A HREF="#throw-catch">throw-catch</A>|.



EXAMINING EXCEPTION HANDLING CODE			*<A NAME="except-examine"></A><B>except-examine</B>*

Exception handling code can get tricky.  If you are in doubt what happens, set
<A HREF="options.html#'verbose'">'verbose'</A> to 13 or use the &quot;:13verbose&quot; command modifier when sourcing your
<A HREF="usr_41.html#script">script</A> file.  Then you see when an exception is thrown, discarded, caught, or
finished.  When using a verbosity level of at least 14, things pending in
a finally clause are also shown.  This information is also given in debug mode
(see |<A HREF="repeat.html#debug-scripts">debug-scripts</A>|).



THROWING AND CATCHING EXCEPTIONS			*<A NAME="throw-catch"></A><B>throw-catch</B>*

You can throw any number or <A HREF="#string">string</A> <A HREF="motion.html#as">as</A> an exception.  Use the |<A HREF="#:throw">:throw</A>| command
and pass the value to be thrown <A HREF="motion.html#as">as</A> argument:
<B>	:throw 4711</B>
<B>	:throw "string"</B>

 							*<A NAME="throw-expression"></A><B>throw-expression</B>*
You can also specify an <A HREF="#expression">expression</A> argument.  The <A HREF="#expression">expression</A> is then evaluated
first, and the result is thrown:
<B>	:throw 4705 + strlen("string")</B>
<B>	:throw strpart("strings", 0, 6)</B>

An exception might be thrown during evaluation of the argument of the &quot;<A HREF="#:throw">:throw</A>&quot;
command.  Unless <A HREF="motion.html#it">it</A> is caught there, the <A HREF="#expression">expression</A> evaluation is abandoned.
The &quot;<A HREF="#:throw">:throw</A>&quot; command then does not throw a new exception.
   Example:

<B>	:function! Foo(arg)</B>
<B>	:  try</B>
<B>	:    throw a:arg</B>
<B>	:  catch /foo/</B>
<B>	:  endtry</B>
<B>	:  return 1</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Bar()</B>
<B>	:  echo "in Bar"</B>
<B>	:  return 4710</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:throw Foo("arrgh") + Bar()</B>

This throws &quot;arrgh&quot;, and &quot;in Bar&quot; is not displayed since Bar() is not
executed.
<B>	:throw Foo("foo") + Bar()</B>
however displays &quot;in Bar&quot; and throws 4711.

Any other command that takes an <A HREF="#expression">expression</A> <A HREF="motion.html#as">as</A> argument might also be
abandoned by an (uncaught) exception during the <A HREF="#expression">expression</A> evaluation.  The
exception is then propagated to the caller of the command.
   Example:

<B>	:if Foo("arrgh")</B>
<B>	:  echo "then"</B>
<B>	:else</B>
<B>	:  echo "else"</B>
<B>	:endif</B>

Here neither of &quot;then&quot; or &quot;else&quot; is displayed.


							*<A NAME="catch-order"></A><B>catch-order</B>*
Exceptions can be caught by a try conditional with one or more |<A HREF="#:catch">:catch</A>|
commands, see |<A HREF="#try-conditionals">try-conditionals</A>|.   The values to be caught by each &quot;<A HREF="#:catch">:catch</A>&quot;
command can be specified <A HREF="motion.html#as">as</A> a <A HREF="pattern.html#pattern">pattern</A> argument.  The subsequent catch clause
gets executed when a matching exception is caught.
   Example:

<B>	:function! Foo(value)</B>
<B>	:  try</B>
<B>	:    throw a:value</B>
<B>	:  catch /^\d\+$/</B>
<B>	:    echo "Number thrown"</B>
<B>	:  catch /.*/</B>
<B>	:    echo "String thrown"</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:call Foo(0x1267)</B>
<B>	:call Foo('string')</B>

The first call to Foo() displays &quot;<A HREF="#Number">Number</A> thrown&quot;, the second &quot;<A HREF="#String">String</A> thrown&quot;.
An exception is matched against the &quot;<A HREF="#:catch">:catch</A>&quot; commands in the order they are
specified.  Only the first match counts.  So you should place the more
specific &quot;<A HREF="#:catch">:catch</A>&quot; first.  The following order does not make sense:

<B>	:  catch /.*/</B>
<B>	:    echo "String thrown"</B>
<B>	:  catch /^\d\+$/</B>
<B>	:    echo "Number thrown"</B>

The first &quot;<A HREF="#:catch">:catch</A>&quot; here matches always, so that the second catch clause is
never taken.


							*<A NAME="throw-variables"></A><B>throw-variables</B>*
If you catch an exception by a general <A HREF="pattern.html#pattern">pattern</A>, you may access the exact value
in the variable YXXYv:exception|:

<B>	:  catch /^\d\+$/</B>
<B>	:    echo "Number thrown.  Value is" v:exception</B>

You may also be interested where an exception was thrown.  This is stored in
|<A HREF="#v:throwpoint">v:throwpoint</A>|.  Note that &quot;<A HREF="#v:exception">v:exception</A>&quot; and &quot;v:throwpoint&quot; are valid for the
exception most recently caught <A HREF="motion.html#as">as</A> long <A HREF="motion.html#it">it</A> is not finished.
   Example:

<B>	:function! Caught()</B>
<B>	:  if v:exception != ""</B>
<B>	:    echo 'Caught "' . v:exception .. '" in ' .. v:throwpoint</B>
<B>	:  else</B>
<B>	:    echo 'Nothing caught'</B>
<B>	:  endif</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Foo()</B>
<B>	:  try</B>
<B>	:    try</B>
<B>	:      try</B>
<B>	:	 throw 4711</B>
<B>	:      finally</B>
<B>	:	 call Caught()</B>
<B>	:      endtry</B>
<B>	:    catch /.*/</B>
<B>	:      call Caught()</B>
<B>	:      throw "oops"</B>
<B>	:    endtry</B>
<B>	:  catch /.*/</B>
<B>	:    call Caught()</B>
<B>	:  finally</B>
<B>	:    call Caught()</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:call Foo()</B>

This displays

<B>	Nothing caught</B>
<B>	Caught "4711" in function Foo, line 4</B>
<B>	Caught "oops" in function Foo, line 10</B>
<B>	Nothing caught</B>

A practical example:  The following command &quot;:LineNumber&quot; displays the line
number in the <A HREF="usr_41.html#script">script</A> or function where <A HREF="motion.html#it">it</A> has been used:

<B>	:function! LineNumber()</B>
<B>	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")</B>
<B>	:endfunction</B>
<B>	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry</B>
 

							*<A NAME="try-nested"></A><B>try-nested</B>*
An exception that is not caught by a try conditional can be caught by
a surrounding try conditional:

<B>	:try</B>
<B>	:  try</B>
<B>	:    throw "foo"</B>
<B>	:  catch /foobar/</B>
<B>	:    echo "foobar"</B>
<B>	:  finally</B>
<B>	:    echo "inner finally"</B>
<B>	:  endtry</B>
<B>	:catch /foo/</B>
<B>	:  echo "foo"</B>
<B>	:endtry</B>

The inner try conditional does not catch the exception, just its finally
clause is executed.  The exception is then caught by the outer try
conditional.  The example displays &quot;inner finally&quot; and then &quot;foo&quot;.


							*<A NAME="throw-from-catch"></A><B>throw-from-catch</B>*
You can catch an exception and throw a new one to be caught elsewhere from the
catch clause:

<B>	:function! Foo()</B>
<B>	:  throw "foo"</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Bar()</B>
<B>	:  try</B>
<B>	:    call Foo()</B>
<B>	:  catch /foo/</B>
<B>	:    echo "Caught foo, throw bar"</B>
<B>	:    throw "bar"</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:try</B>
<B>	:  call Bar()</B>
<B>	:catch /.*/</B>
<B>	:  echo "Caught" v:exception</B>
<B>	:endtry</B>

This displays &quot;Caught foo, throw bar&quot; and then &quot;Caught bar&quot;.


							*<A NAME="rethrow"></A><B>rethrow</B>*
There is no real <A HREF="#rethrow">rethrow</A> in the Vim <A HREF="usr_41.html#script">script</A> language, but you may throw
&quot;<A HREF="#v:exception">v:exception</A>&quot; instead:

<B>	:function! Bar()</B>
<B>	:  try</B>
<B>	:    call Foo()</B>
<B>	:  catch /.*/</B>
<B>	:    echo "Rethrow" v:exception</B>
<B>	:    throw v:exception</B>
<B>	:  endtry</B>
<B>	:endfunction</B>

 							*<A NAME="try-echoerr"></A><B>try-echoerr</B>*
Note that this <A HREF="#method">method</A> cannot be used to &quot;<A HREF="#rethrow">rethrow</A>&quot; Vim error or interrupt
exceptions, because <A HREF="motion.html#it">it</A> is not possible to fake Vim internal exceptions.
Trying so causes an error exception.  You should throw your own exception
denoting the situation.  If you want to cause a Vim error exception containing
the original error exception value, you can use the |<A HREF="#:echoerr">:echoerr</A>| command:

<B>	:try</B>
<B>	:  try</B>
<B>	:    asdf</B>
<B>	:  catch /.*/</B>
<B>	:    echoerr v:exception</B>
<B>	:  endtry</B>
<B>	:catch /.*/</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>

This code displays

<B><FONT COLOR="PURPLE">	Vim(echoerr):Vim:E492: Not an editor command:	asdf </FONT></B>



CLEANUP CODE						*<A NAME="try-finally"></A><B>try-finally</B>*

Scripts often change global settings and restore them at their end.  If the
user however interrupts the <A HREF="usr_41.html#script">script</A> by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>, the settings remain in
an inconsistent state.  The same may happen to you in the <A HREF="develop.html#development">development</A> phase of
a <A HREF="usr_41.html#script">script</A> when an error occurs or you explicitly throw an exception without
catching <A HREF="motion.html#it">it</A>.  You can solve these problems by using a try conditional with
a finally clause for restoring the settings.  Its execution is guaranteed on
normal <A HREF="intro.html#control">control</A> flow, on error, on an explicit &quot;<A HREF="#:throw">:throw</A>&quot;, and on interrupt.
(Note that <A HREF="message.html#errors">errors</A> and interrupts from inside the try conditional are converted
to exceptions.  When not caught, they terminate the <A HREF="usr_41.html#script">script</A> after the finally
clause has been executed.)
Example:

<B>	:try</B>
<B>	:  let s:saved_ts = &amp;ts</B>
<B>	:  set ts=17</B>
<B>	:</B>
<B>	:  " Do the hard work here.</B>
<B>	:</B>
<B>	:finally</B>
<B>	:  let &amp;ts = s:saved_ts</B>
<B>	:  unlet s:saved_ts</B>
<B>	:endtry</B>

This <A HREF="#method">method</A> should be used locally whenever a function or part of a <A HREF="usr_41.html#script">script</A>
changes global settings which need to be restored on failure or normal exit of
that function or <A HREF="usr_41.html#script">script</A> part.


							*<A NAME="break-finally"></A><B>break-finally</B>*
Cleanup code works also when the try block or a catch clause is left by
a &quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="#:break">:break</A>&quot;, &quot;<A HREF="#:return">:return</A>&quot;, or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot;.
   Example:

<B>	:let first = 1</B>
<B>	:while 1</B>
<B>	:  try</B>
<B>	:    if first</B>
<B>	:      echo "first"</B>
<B>	:      let first = 0</B>
<B>	:      continue</B>
<B>	:    else</B>
<B>	:      throw "second"</B>
<B>	:    endif</B>
<B>	:  catch /.*/</B>
<B>	:    echo v:exception</B>
<B>	:    break</B>
<B>	:  finally</B>
<B>	:    echo "cleanup"</B>
<B>	:  endtry</B>
<B>	:  echo "still in while"</B>
<B>	:endwhile</B>
<B>	:echo "end"</B>

This displays &quot;first&quot;, &quot;cleanup&quot;, &quot;second&quot;, &quot;cleanup&quot;, and &quot;end&quot;.

<B>	:function! Foo()</B>
<B>	:  try</B>
<B>	:    return 4711</B>
<B>	:  finally</B>
<B>	:    echo "cleanup\n"</B>
<B>	:  endtry</B>
<B>	:  echo "Foo still active"</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:echo Foo() "returned by Foo"</B>

This displays &quot;cleanup&quot; and &quot;4711 returned by Foo&quot;.  You don't need to add an
extra &quot;<A HREF="#:return">:return</A>&quot; in the finally clause.  (Above all, this would override the
return value.)


							*<A NAME="except-from-finally"></A><B>except-from-finally</B>*
Using either of &quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="#:break">:break</A>&quot;, &quot;<A HREF="#:return">:return</A>&quot;, &quot;<A HREF="repeat.html#:finish">:finish</A>&quot;, or &quot;<A HREF="#:throw">:throw</A>&quot; in
a finally clause is possible, but not recommended since <A HREF="motion.html#it">it</A> abandons the
cleanup actions for the try conditional.  But, of course, interrupt and error
exceptions might get raised from a finally clause.
   Example where an error in the finally clause stops an interrupt from
working correctly:

<B>	:try</B>
<B>	:  try</B>
<B>	:    echo "Press CTRL-C for interrupt"</B>
<B>	:    while 1</B>
<B>	:    endwhile</B>
<B>	:  finally</B>
<B>	:    unlet novar</B>
<B>	:  endtry</B>
<B>	:catch /novar/</B>
<B>	:endtry</B>
<B>	:echo "Script still running"</B>
<B>	:sleep 1</B>

If you need to put commands that could fail into a finally clause, you should
think about catching or ignoring the <A HREF="message.html#errors">errors</A> in these commands, see
|<A HREF="#catch-errors">catch-errors</A>| and |<A HREF="#ignore-errors">ignore-errors</A>|.



CATCHING ERRORS						*<A NAME="catch-errors"></A><B>catch-errors</B>*

If you want to catch specific <A HREF="message.html#errors">errors</A>, you just have to put the code to be
watched in a try block and add a catch clause for the error message.  The
presence of the try conditional causes all <A HREF="message.html#errors">errors</A> to be converted to an
exception.  No message is displayed and |<A HREF="#v:errmsg">v:errmsg</A>| is not set then.  To find
the right <A HREF="pattern.html#pattern">pattern</A> for the &quot;<A HREF="#:catch">:catch</A>&quot; command, you have to know how the format of
the error exception is.
   Error exceptions have the following format:

<B>	Vim({cmdname}):{errmsg}</B>
or
<B>	Vim:{errmsg}</B>

{cmdname} is the name of the command that failed; the second form is used when
the command name is not known.  {errmsg} is the error message usually produced
when the error occurs outside try conditionals.  It always begins with
a capital &quot;<A HREF="motion.html#E">E</A>&quot;, followed by a two or three-digit error number, a colon, and
a space.

Examples:

The command
<B>	:unlet novar</B>
normally produces the error message
<B>	E108: No such variable: "novar"</B>
which is converted inside try conditionals to an exception
<B>	Vim(unlet):E108: No such variable: "novar"</B>

The command
<B>	:dwim</B>
normally produces the error message
<B>	E492: Not an editor command: dwim</B>
which is converted inside try conditionals to an exception
<B>	Vim:E492: Not an editor command: dwim</B>

You can catch all &quot;<A HREF="#:unlet">:unlet</A>&quot; <A HREF="message.html#errors">errors</A> by a
<B>	:catch /^Vim(unlet):/</B>
or all <A HREF="message.html#errors">errors</A> for misspelled command names by a
<B>	:catch /^Vim:E492:/</B>

Some error <A HREF="message.html#messages">messages</A> may be produced by different commands:
<B>	:function nofunc</B>
and
<B>	:delfunction nofunc</B>
both produce the error message
<B>	E128: Function name must start with a capital: nofunc</B>
which is converted inside try conditionals to an exception
<B>	Vim(function):E128: Function name must start with a capital: nofunc</B>
or
<B>	Vim(delfunction):E128: Function name must start with a capital: nofunc</B>
respectively.  You can catch the error by its number independently on the
command that caused <A HREF="motion.html#it">it</A> if you use the following <A HREF="pattern.html#pattern">pattern</A>:
<B>	:catch /^Vim(\a\+):E128:/</B>

Some commands like
<B>	:let x = novar</B>
produce multiple error <A HREF="message.html#messages">messages</A>, here:
<B>	E121: Undefined variable: novar</B>
<B>	E15: Invalid expression:  novar</B>
Only the first is used for the exception value, since <A HREF="motion.html#it">it</A> is the most specific
one (see |<A HREF="#except-several-errors">except-several-errors</A>|).  So you can catch <A HREF="motion.html#it">it</A> by
<B>	:catch /^Vim(\a\+):E121:/</B>

You can catch all <A HREF="message.html#errors">errors</A> related to the name &quot;nofunc&quot; by
<B>	:catch /\&lt;nofunc\&gt;/</B>

You can catch all Vim <A HREF="message.html#errors">errors</A> in the &quot;<A HREF="editing.html#:write">:write</A>&quot; and &quot;<A HREF="insert.html#:read">:read</A>&quot; commands by
<B>	:catch /^Vim(\(write\|read\)):E\d\+:/</B>

You can catch all Vim <A HREF="message.html#errors">errors</A> by the <A HREF="pattern.html#pattern">pattern</A>
<B>	:catch /^Vim\((\a\+)\)\=:E\d\+:/</B>
 

							*<A NAME="catch-text"></A><B>catch-text</B>*
NOTE: You should never catch the error message text itself:
<B>	:catch /No such variable/</B>
only works in the English <A HREF="mbyte.html#locale">locale</A>, but not when the user has selected
a different language by the |<A HREF="mlang.html#:language">:language</A>| command.  It is however helpful to
cite the message text in a comment:
<B>	:catch /^Vim(\a\+):E108:/   " No such variable</B>



IGNORING ERRORS						*<A NAME="ignore-errors"></A><B>ignore-errors</B>*

You can ignore <A HREF="message.html#errors">errors</A> in a specific Vim command by catching them locally:

<B>	:try</B>
<B>	:  write</B>
<B>	:catch</B>
<B>	:endtry</B>

But you are strongly recommended NOT to use this simple form, since <A HREF="motion.html#it">it</A> could
catch more than you want.  With the &quot;<A HREF="editing.html#:write">:write</A>&quot; command, some <A HREF="autocmd.html#autocommands">autocommands</A> could
be executed and cause <A HREF="message.html#errors">errors</A> not related to <A HREF="editing.html#writing">writing</A>, for instance:

<B>	:au BufWritePre * unlet novar</B>

There could even be such <A HREF="message.html#errors">errors</A> you are not responsible for <A HREF="motion.html#as">as</A> a <A HREF="usr_41.html#script">script</A>
writer: a user of your <A HREF="usr_41.html#script">script</A> might have defined such <A HREF="autocmd.html#autocommands">autocommands</A>.  You would
then hide the error from the user.
   It is much better to use

<B>	:try</B>
<B>	:  write</B>
<B>	:catch /^Vim(write):/</B>
<B>	:endtry</B>

which only catches real write <A HREF="message.html#errors">errors</A>.  So catch only what you'd like to ignore
intentionally.

For a single command that does not cause execution of <A HREF="autocmd.html#autocommands">autocommands</A>, you could
even suppress the conversion of <A HREF="message.html#errors">errors</A> to exceptions by the &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;
command:
<B>	:silent! nunmap k</B>
This works also when a try conditional is active.



CATCHING INTERRUPTS					*<A NAME="catch-interrupt"></A><B>catch-interrupt</B>*

When there are active try conditionals, an interrupt (CTRL-C) is converted to
the exception &quot;Vim:Interrupt&quot;.  You can catch <A HREF="motion.html#it">it</A> like every exception.  The
<A HREF="usr_41.html#script">script</A> is not terminated, then.
   Example:

<B>	:function! TASK1()</B>
<B>	:  sleep 10</B>
<B>	:endfunction</B>

<B>	:function! TASK2()</B>
<B>	:  sleep 20</B>
<B>	:endfunction</B>

<B>	:while 1</B>
<B>	:  let command = input("Type a command: ")</B>
<B>	:  try</B>
<B>	:    if command == ""</B>
<B>	:      continue</B>
<B>	:    elseif command == "END"</B>
<B>	:      break</B>
<B>	:    elseif command == "TASK1"</B>
<B>	:      call TASK1()</B>
<B>	:    elseif command == "TASK2"</B>
<B>	:      call TASK2()</B>
<B>	:    else</B>
<B>	:      echo "\nIllegal command:" command</B>
<B>	:      continue</B>
<B>	:    endif</B>
<B>	:  catch /^Vim:Interrupt$/</B>
<B>	:    echo "\nCommand interrupted"</B>
<B>	:    " Caught the interrupt.  Continue with next prompt.</B>
<B>	:  endtry</B>
<B>	:endwhile</B>

You can interrupt a task here by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>; the <A HREF="usr_41.html#script">script</A> then asks for
a new command.  If you press <A HREF="pattern.html#CTRL-C">CTRL-C</A> at the prompt, the <A HREF="usr_41.html#script">script</A> is terminated.

For <A HREF="testing.html#testing">testing</A> what happens when <A HREF="pattern.html#CTRL-C">CTRL-C</A> would be pressed on a specific line in
your <A HREF="usr_41.html#script">script</A>, use the debug mode and execute the |<A HREF="repeat.html#&gt;quit">&gt;quit</A>| or |<A HREF="repeat.html#&gt;interrupt">&gt;interrupt</A>|
command on that line.  See |<A HREF="repeat.html#debug-scripts">debug-scripts</A>|.



CATCHING ALL						*<A NAME="catch-all"></A><B>catch-all</B>*

The commands

<B>	:catch /.*/</B>
<B>	:catch //</B>
<B>	:catch</B>

catch everything, error exceptions, interrupt exceptions and exceptions
explicitly thrown by the |<A HREF="#:throw">:throw</A>| command.  This is useful at the top level of
a <A HREF="usr_41.html#script">script</A> in order to catch unexpected things.
   Example:

<B>	:try</B>
<B>	:</B>
<B>	:  " do the hard work here</B>
<B>	:</B>
<B>	:catch /MyException/</B>
<B>	:</B>
<B>	:  " handle known problem</B>
<B>	:</B>
<B>	:catch /^Vim:Interrupt$/</B>
<B>	:    echo "Script interrupted"</B>
<B>	:catch /.*/</B>
<B>	:  echo "Internal error (" .. v:exception .. ")"</B>
<B>	:  echo " - occurred at " .. v:throwpoint</B>
<B>	:endtry</B>
<B>	:" end of script</B>

Note: Catching all might catch more things than you want.  Thus, you are
strongly encouraged to catch only for problems that you can really handle by
specifying a <A HREF="pattern.html#pattern">pattern</A> argument to the &quot;<A HREF="#:catch">:catch</A>&quot;.
   Example: Catching all could make <A HREF="motion.html#it">it</A> nearly impossible to interrupt a <A HREF="usr_41.html#script">script</A>
by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>:

<B>	:while 1</B>
<B>	:  try</B>
<B>	:    sleep 1</B>
<B>	:  catch</B>
<B>	:  endtry</B>
<B>	:endwhile</B>



EXCEPTIONS AND AUTOCOMMANDS				*<A NAME="except-autocmd"></A><B>except-autocmd</B>*

Exceptions may be used during execution of <A HREF="autocmd.html#autocommands">autocommands</A>.  Example:

<B>	:autocmd User x try</B>
<B>	:autocmd User x   throw "Oops!"</B>
<B>	:autocmd User x catch</B>
<B>	:autocmd User x   echo v:exception</B>
<B>	:autocmd User x endtry</B>
<B>	:autocmd User x throw "Arrgh!"</B>
<B>	:autocmd User x echo "Should not be displayed"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  doautocmd User x</B>
<B>	:catch</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>

This displays &quot;Oops!&quot; and &quot;Arrgh!&quot;.


							*<A NAME="except-autocmd-Pre"></A><B>except-autocmd-Pre</B>*
For some commands, <A HREF="autocmd.html#autocommands">autocommands</A> get executed before the main action of the
command takes place.  If an exception is thrown and not caught in the sequence
of <A HREF="autocmd.html#autocommands">autocommands</A>, the sequence and the command that caused its execution are
abandoned and the exception is propagated to the caller of the command.
   Example:

<B>	:autocmd BufWritePre * throw "FAIL"</B>
<B>	:autocmd BufWritePre * echo "Should not be displayed"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write</B>
<B>	:catch</B>
<B>	:  echo "Caught:" v:exception "from" v:throwpoint</B>
<B>	:endtry</B>

Here, the &quot;<A HREF="editing.html#:write">:write</A>&quot; command does not write the file currently being edited (as
you can see by checking 'modified'), since the exception from the <A HREF="autocmd.html#BufWritePre">BufWritePre</A>
<A HREF="autocmd.html#autocommand">autocommand</A> abandons the &quot;<A HREF="editing.html#:write">:write</A>&quot;.  The exception is then caught and the
<A HREF="usr_41.html#script">script</A> displays:

<B>	Caught: FAIL from BufWrite Auto commands for "*"</B>
 

							*<A NAME="except-autocmd-Post"></A><B>except-autocmd-Post</B>*
For some commands, <A HREF="autocmd.html#autocommands">autocommands</A> get executed after the main action of the
command has taken place.  If this main action fails and the command is inside
an active try conditional, the <A HREF="autocmd.html#autocommands">autocommands</A> are skipped and an error exception
is thrown that can be caught by the caller of the command.
   Example:

<B>	:autocmd BufWritePost * echo "File successfully written!"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write /i/m/p/o/s/s/i/b/l/e</B>
<B>	:catch</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>

This just displays:

<B>	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)</B>

If you really need to execute the <A HREF="autocmd.html#autocommands">autocommands</A> even when the main action
fails, trigger the event from the catch clause.
   Example:

<B>	:autocmd BufWritePre  * set noreadonly</B>
<B>	:autocmd BufWritePost * set readonly</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write /i/m/p/o/s/s/i/b/l/e</B>
<B>	:catch</B>
<B>	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e</B>
<B>	:endtry</B>
 
You can also use &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;:

<B>	:let x = "ok"</B>
<B>	:let v:errmsg = ""</B>
<B>	:autocmd BufWritePost * if v:errmsg != ""</B>
<B>	:autocmd BufWritePost *   let x = "after fail"</B>
<B>	:autocmd BufWritePost * endif</B>
<B>	:try</B>
<B>	:  silent! write /i/m/p/o/s/s/i/b/l/e</B>
<B>	:catch</B>
<B>	:endtry</B>
<B>	:echo x</B>

This displays &quot;after fail&quot;.

If the main action of the command does not fail, exceptions from the
<A HREF="autocmd.html#autocommands">autocommands</A> will be catchable by the caller of the command: 

<B>	:autocmd BufWritePost * throw ":-("</B>
<B>	:autocmd BufWritePost * echo "Should not be displayed"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write</B>
<B>	:catch</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>
 

							*<A NAME="except-autocmd-Cmd"></A><B>except-autocmd-Cmd</B>*
For some commands, the normal action can be replaced by a sequence of
<A HREF="autocmd.html#autocommands">autocommands</A>.  Exceptions from that sequence will be catchable by the caller
of the command.
   Example:  For the &quot;<A HREF="editing.html#:write">:write</A>&quot; command, the caller cannot know whether the file
had actually been written when the exception occurred.  You need to tell <A HREF="motion.html#it">it</A> in
some way.

<B>	:if !exists("cnt")</B>
<B>	:  let cnt = 0</B>
<B>	:</B>
<B>	:  autocmd BufWriteCmd * if &amp;modified</B>
<B>	:  autocmd BufWriteCmd *   let cnt = cnt + 1</B>
<B>	:  autocmd BufWriteCmd *   if cnt % 3 == 2</B>
<B>	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</B>
<B>	:  autocmd BufWriteCmd *   endif</B>
<B>	:  autocmd BufWriteCmd *   write | set nomodified</B>
<B>	:  autocmd BufWriteCmd *   if cnt % 3 == 0</B>
<B>	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</B>
<B>	:  autocmd BufWriteCmd *   endif</B>
<B>	:  autocmd BufWriteCmd *   echo "File successfully written!"</B>
<B>	:  autocmd BufWriteCmd * endif</B>
<B>	:endif</B>
<B>	:</B>
<B>	:try</B>
<B>	:	write</B>
<B>	:catch /^BufWriteCmdError$/</B>
<B>	:  if &amp;modified</B>
<B>	:    echo "Error on writing (file contents not changed)"</B>
<B>	:  else</B>
<B>	:    echo "Error after writing"</B>
<B>	:  endif</B>
<B>	:catch /^Vim(write):/</B>
<B>	:    echo "Error on writing"</B>
<B>	:endtry</B>

When this <A HREF="usr_41.html#script">script</A> is sourced several times after making changes, <A HREF="motion.html#it">it</A> displays
first
<B>	File successfully written!</B>
then
<B>	Error on writing (file contents not changed)</B>
then
<B>	Error after writing</B>
etc.


							*<A NAME="except-autocmd-ill"></A><B>except-autocmd-ill</B>*
You cannot spread a try conditional over <A HREF="autocmd.html#autocommands">autocommands</A> for different events.
The following code is ill-formed:

<B>	:autocmd BufWritePre  * try</B>
<B>	:</B>
<B>	:autocmd BufWritePost * catch</B>
<B>	:autocmd BufWritePost *   echo v:exception</B>
<B>	:autocmd BufWritePost * endtry</B>
<B>	:</B>
<B>	:write</B>



EXCEPTION HIERARCHIES AND PARAMETERIZED EXCEPTIONS	*<A NAME="except-hier-param"></A><B>except-hier-param</B>*

Some programming languages allow to use hierarchies of exception classes or to
pass additional information with the object of an exception class.  You can <A HREF="diff.html#do">do</A>
similar things in Vim.
   In order to throw an exception from a hierarchy, just throw the complete
class name with the components separated by a colon, for instance throw the
<A HREF="#string">string</A> &quot;EXCEPT:MATHERR:OVERFLOW&quot; for an overflow in a mathematical library.
   When you want to pass additional information with your exception class, add
<A HREF="motion.html#it">it</A> in parentheses, for instance throw the <A HREF="#string">string</A> &quot;EXCEPT:IO:WRITEERR(myfile)&quot;
for an error when <A HREF="editing.html#writing">writing</A> &quot;myfile&quot;.
   With the appropriate patterns in the &quot;<A HREF="#:catch">:catch</A>&quot; command, you can catch for
base classes or derived classes of your hierarchy.  Additional information in
parentheses can be cut out from |<A HREF="#v:exception">v:exception</A>| with the &quot;<A HREF="change.html#:substitute">:substitute</A>&quot; command.
   Example:

<B>	:function! CheckRange(a, func)</B>
<B>	:  if a:a &lt; 0</B>
<B>	:    throw "EXCEPT:MATHERR:RANGE(" .. a:func .. ")"</B>
<B>	:  endif</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Add(a, b)</B>
<B>	:  call CheckRange(a:a, "Add")</B>
<B>	:  call CheckRange(a:b, "Add")</B>
<B>	:  let c = a:a + a:b</B>
<B>	:  if c &lt; 0</B>
<B>	:    throw "EXCEPT:MATHERR:OVERFLOW"</B>
<B>	:  endif</B>
<B>	:  return c</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Div(a, b)</B>
<B>	:  call CheckRange(a:a, "Div")</B>
<B>	:  call CheckRange(a:b, "Div")</B>
<B>	:  if (a:b == 0)</B>
<B>	:    throw "EXCEPT:MATHERR:ZERODIV"</B>
<B>	:  endif</B>
<B>	:  return a:a / a:b</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Write(file)</B>
<B>	:  try</B>
<B>	:    execute "write" fnameescape(a:file)</B>
<B>	:  catch /^Vim(write):/</B>
<B>	:    throw "EXCEPT:IO(" .. getcwd() .. ", " .. a:file .. "):WRITEERR"</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:try</B>
<B>	:</B>
<B>	:  " something with arithmetic and I/O</B>
<B>	:</B>
<B>	:catch /^EXCEPT:MATHERR:RANGE/</B>
<B>	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")</B>
<B>	:  echo "Range error in" function</B>
<B>	:</B>
<B>	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV</B>
<B>	:  echo "Math error"</B>
<B>	:</B>
<B>	:catch /^EXCEPT:IO/</B>
<B>	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")</B>
<B>	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")</B>
<B>	:  if file !~ '^/'</B>
<B>	:    let file = dir .. "/" .. file</B>
<B>	:  endif</B>
<B>	:  echo 'I/O error for "' .. file .. '"'</B>
<B>	:</B>
<B>	:catch /^EXCEPT/</B>
<B>	:  echo "Unspecified error"</B>
<B>	:</B>
<B>	:endtry</B>

The exceptions raised by Vim itself (on error or when pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>) use
a flat hierarchy:  they are all in the &quot;Vim&quot; class.  You cannot throw yourself
exceptions with the &quot;Vim&quot; prefix; they are reserved for Vim.
   Vim error exceptions are parameterized with the name of the command that
failed, if known.  See |<A HREF="#catch-errors">catch-errors</A>|.


PECULIARITIES

							*<A NAME="except-compat"></A><B>except-compat</B>*
The exception handling concept requires that the command sequence causing the
exception is aborted immediately and <A HREF="intro.html#control">control</A> is transferred to finally clauses
and/or a catch clause.

In the Vim <A HREF="usr_41.html#script">script</A> language there are cases where scripts and <A HREF="#functions">functions</A>
continue after an error: in <A HREF="#functions">functions</A> without the &quot;abort&quot; flag or in a command
after &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;, <A HREF="intro.html#control">control</A> flow goes to the following line, and outside
<A HREF="#functions">functions</A>, <A HREF="intro.html#control">control</A> flow goes to the line following the outermost &quot;<A HREF="#:endwhile">:endwhile</A>&quot;
or &quot;<A HREF="#:endif">:endif</A>&quot;.  On the other hand, <A HREF="message.html#errors">errors</A> should be catchable <A HREF="motion.html#as">as</A> exceptions
(thus, requiring the immediate abortion).

This problem has been solved by converting <A HREF="message.html#errors">errors</A> to exceptions and using
immediate abortion (if not suppressed by &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;) only when a try
conditional is active.  This is no restriction since an (error) exception can
be caught only from an active try conditional.  If you want an immediate
termination without catching the error, just use a try conditional without
catch clause.  (You can cause cleanup code being executed before termination
by specifying a finally clause.)

When no try conditional is active, the usual abortion and continuation
behavior is used instead of immediate abortion.  This ensures compatibility of
scripts written for Vim 6.1 and earlier.

However, when sourcing an existing <A HREF="usr_41.html#script">script</A> that does not use exception handling
commands (or when calling one of its <A HREF="#functions">functions</A>) from inside an active try
conditional of a new <A HREF="usr_41.html#script">script</A>, you might change the <A HREF="intro.html#control">control</A> flow of the existing
<A HREF="usr_41.html#script">script</A> on error.  You get the immediate abortion on error and can catch the
error in the new <A HREF="usr_41.html#script">script</A>.  If however the sourced <A HREF="usr_41.html#script">script</A> suppresses error
<A HREF="message.html#messages">messages</A> by using the &quot;<A HREF="various.html#:silent!">:silent!</A>&quot; command (checking for <A HREF="message.html#errors">errors</A> by <A HREF="testing.html#testing">testing</A>
|<A HREF="#v:errmsg">v:errmsg</A>| if appropriate), its execution path is not changed.  The error is
not converted to an exception.  (See |<A HREF="various.html#:silent">:silent</A>|.)  So the only remaining cause
where this happens is for scripts that don't care about <A HREF="message.html#errors">errors</A> and produce
error <A HREF="message.html#messages">messages</A>.  You probably won't want to use such code from your new
scripts.


							*<A NAME="except-syntax-err"></A><B>except-syntax-err</B>*
<A HREF="autocmd.html#Syntax">Syntax</A> <A HREF="message.html#errors">errors</A> in the exception handling commands are never caught by any of
the &quot;<A HREF="#:catch">:catch</A>&quot; commands of the try conditional they belong to.  Its finally
clauses, however, is executed.
   Example:

<B>	:try</B>
<B>	:  try</B>
<B>	:    throw 4711</B>
<B>	:  catch /\(/</B>
<B>	:    echo "in catch with syntax error"</B>
<B>	:  catch</B>
<B>	:    echo "inner catch-all"</B>
<B>	:  finally</B>
<B>	:    echo "inner finally"</B>
<B>	:  endtry</B>
<B>	:catch</B>
<B>	:  echo 'outer catch-all caught "' .. v:exception .. '"'</B>
<B>	:  finally</B>
<B>	:    echo "outer finally"</B>
<B>	:endtry</B>

This displays:
<B>    inner finally</B>
<B>    outer catch-all caught "Vim(catch):E54: Unmatched \("</B>
<B>    outer finally</B>
The original exception is discarded and an error exception is raised, instead.


							*<A NAME="except-single-line"></A><B>except-single-line</B>*
The &quot;<A HREF="#:try">:try</A>&quot;, &quot;<A HREF="#:catch">:catch</A>&quot;, &quot;<A HREF="#:finally">:finally</A>&quot;, and &quot;<A HREF="#:endtry">:endtry</A>&quot; commands can be put on
a single line, but then <A HREF="syntax.html#syntax">syntax</A> <A HREF="message.html#errors">errors</A> may make <A HREF="motion.html#it">it</A> difficult to recognize the
&quot;catch&quot; line, thus you better avoid this.
   Example:
<B>	:try | unlet! foo # | catch | endtry</B>
raises an error exception for the trailing characters after the &quot;:unlet!&quot;
argument, but does not see the &quot;<A HREF="#:catch">:catch</A>&quot; and &quot;<A HREF="#:endtry">:endtry</A>&quot; commands, so that the
error exception is discarded and the &quot;E488: Trailing characters&quot; message gets
displayed.


							*<A NAME="except-several-errors"></A><B>except-several-errors</B>*
When several <A HREF="message.html#errors">errors</A> appear in a single command, the first error message is
usually the most specific one and therefore converted to the error exception.
   Example:
<B>	echo novar</B>
causes
<B>	E121: Undefined variable: novar</B>
<B>	E15: Invalid expression: novar</B>
The value of the error exception inside try conditionals is:
<B>	Vim(echo):E121: Undefined variable: novar</B>

 							*<A NAME="except-syntax-error"></A><B>except-syntax-error</B>*
But when a <A HREF="syntax.html#syntax">syntax</A> error is detected after a normal error in the same command,
the <A HREF="syntax.html#syntax">syntax</A> error is used for the exception being thrown.
   Example:
<B>	unlet novar #</B>
causes
<B>	E108: No such variable: "novar"</B>
<B>	E488: Trailing characters</B>
The value of the error exception inside try conditionals is:
<B>	Vim(unlet):E488: Trailing characters</B>
This is done because the <A HREF="syntax.html#syntax">syntax</A> error might change the execution path in a way
not intended by the user.  Example:
<B>	try</B>
<B>	    try | unlet novar # | catch | echo v:exception | endtry</B>
<B>	catch /.*/</B>
<B>	    echo "outer catch:" v:exception</B>
<B>	endtry</B>
This displays &quot;outer catch: Vim(unlet):E488: Trailing characters&quot;, and then
a &quot;E600: Missing :endtry&quot; error message is given, see |<A HREF="#except-single-line">except-single-line</A>|.

==============================================================================

9. Examples						*<A NAME="eval-examples"></A><B>eval-examples</B>*

<B><FONT COLOR="PURPLE">Printing in Binary </FONT></B>

<B>  :" The function Nr2Bin() returns the binary string representation of a number.</B>
<B>  :func Nr2Bin(nr)</B>
<B>  :  let n = a:nr</B>
<B>  :  let r = ""</B>
<B>  :  while n</B>
<B>  :    let r = '01'[n % 2] .. r</B>
<B>  :    let n = n / 2</B>
<B>  :  endwhile</B>
<B>  :  return r</B>
<B>  :endfunc</B>

<B>  :" The function String2Bin() converts each character in a string to a</B>
<B>  :" binary string, separated with dashes.</B>
<B>  :func String2Bin(str)</B>
<B>  :  let out = ''</B>
<B>  :  for ix in range(strlen(a:str))</B>
<B>  :    let out = out .. '-' .. Nr2Bin(char2nr(a:str[ix]))</B>
<B>  :  endfor</B>
<B>  :  return out[1:]</B>
<B>  :endfunc</B>

Example of its use:
<B>  :echo Nr2Bin(32)</B>
result: &quot;100000&quot;
<B>  :echo String2Bin("32")</B>
result: &quot;110011-110010&quot;


<B><FONT COLOR="PURPLE">Sorting lines </FONT></B>

This example sorts lines with a specific compare function.

<B>  :func SortBuffer()</B>
<B>  :  let lines = getline(1, '$')</B>
<B>  :  call sort(lines, function("Strcmp"))</B>
<B>  :  call setline(1, lines)</B>
<B>  :endfunction</B>

As a one-liner:
<B>  :call setline(1, sort(getline(1, '$'), function("Strcmp")))</B>


<B><FONT COLOR="PURPLE">scanf() replacement </FONT></B>

							*<A NAME="sscanf"></A><B>sscanf</B>*
There is no sscanf() function in Vim.  If you need to extract parts from a
line, you can use <A HREF="builtin.html#matchstr()">matchstr()</A> and <A HREF="builtin.html#substitute()">substitute()</A> to <A HREF="diff.html#do">do</A> <A HREF="motion.html#it">it</A>.  This example shows
how to get the file name, line number and column number out of a line like
&quot;foobar.txt, 123, 45&quot;.
<B>   :" Set up the match bit</B>
<B>   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'</B>
<B>   :"get the part matching the whole expression</B>
<B>   :let l = matchstr(line, mx)</B>
<B>   :"get each item out of the match</B>
<B>   :let file = substitute(l, mx, '\1', '')</B>
<B>   :let lnum = substitute(l, mx, '\2', '')</B>
<B>   :let col = substitute(l, mx, '\3', '')</B>

The input is in the variable &quot;line&quot;, the results in the <A HREF="#variables">variables</A> &quot;file&quot;,
&quot;lnum&quot; and &quot;col&quot;. (idea from Michael Geddes)


<B><FONT COLOR="PURPLE">getting the scriptnames in a Dictionary </FONT></B>

						*<A NAME="scriptnames-dictionary"></A><B>scriptnames-dictionary</B>*
The |<A HREF="repeat.html#:scriptnames">:scriptnames</A>| command can be used to get a <A HREF="#list">list</A> of all script files that
have been sourced.  There is no equivalent function or variable for this
(because it's rarely needed).  In <A HREF="change.html#case">case</A> you need to manipulate the <A HREF="#list">list</A> this
code can be used:
<B>    " Get the output of ":scriptnames" in the scriptnames_output variable.</B>
<B>    let scriptnames_output = ''</B>
<B>    redir =&gt; scriptnames_output</B>
<B>    silent scriptnames</B>
<B>    redir END</B>

<B>    " Split the output into lines and parse each line.	Add an entry to the</B>
<B>    " "scripts" dictionary.</B>
<B>    let scripts = {}</B>
<B>    for line in split(scriptnames_output, "\n")</B>
<B>      " Only do non-blank lines.</B>
<B>      if line =~ '\S'</B>
<B>	" Get the first number in the line.</B>
<B>	let nr = matchstr(line, '\d\+')</B>
<B>	" Get the file name, remove the script number " 123: ".</B>
<B>	let name = substitute(line, '.\+:\s*', '', '')</B>
<B>	" Add an item to the Dictionary</B>
<B>	let scripts[nr] = name</B>
<B>      endif</B>
<B>    endfor</B>
<B>    unlet scriptnames_output</B>

==============================================================================

10. Vim <A HREF="usr_41.html#script">script</A> versions		*<A NAME="vimscript-version"></A><B>vimscript-version</B>* *<A NAME="vimscript-versions"></A><B>vimscript-versions</B>*

							*<A NAME="scriptversion"></A><B>scriptversion</B>*
Over time many features have been added to Vim <A HREF="usr_41.html#script">script</A>.  This includes <A HREF="intro.html#Ex">Ex</A>
commands, <A HREF="#functions">functions</A>, variable types, etc.  Each individual feature can be
checked with the |<A HREF="builtin.html#has()">has()</A>| and |<A HREF="builtin.html#exists()">exists()</A>| <A HREF="#functions">functions</A>.

Sometimes old <A HREF="syntax.html#syntax">syntax</A> of functionality gets in the way of making Vim better.
When support is taken away this will break older Vim scripts.  To make this
explicit the |<A HREF="repeat.html#:scriptversion">:scriptversion</A>| command can be used.  When a Vim script is not
compatible with older versions of Vim this will give an explicit error,
instead of failing in mysterious ways.

When using a legacy function, defined with `:function`, in |<A HREF="vim9.html#Vim9">Vim9</A>| <A HREF="usr_41.html#script">script</A> then
<A HREF="#scriptversion">scriptversion</A> 4 is used.


							*<A NAME="scriptversion-1"></A><B>scriptversion-1</B>* 
<B> :scriptversion 1</B>
 	This is the original Vim script, same <A HREF="motion.html#as">as</A> not using a |<A HREF="repeat.html#:scriptversion">:scriptversion</A>|
	command.  Can be used to go back to old <A HREF="syntax.html#syntax">syntax</A> for a range of lines.
	Test for support with:
<B>		has('vimscript-1')</B>


 							*<A NAME="scriptversion-2"></A><B>scriptversion-2</B>* 
<B> :scriptversion 2</B>
 	<A HREF="#String">String</A> concatenation with &quot;<A HREF="repeat.html#.">.</A>&quot; is not supported, use &quot;..&quot; instead.
	This avoids the ambiguity using &quot;<A HREF="repeat.html#.">.</A>&quot; for <A HREF="#Dict">Dict</A> member access and
	floating point numbers.  Now &quot;.5&quot; means the number 0.5.


							*<A NAME="scriptversion-3"></A><B>scriptversion-3</B>* 
<B> :scriptversion 3</B>
 	All |<A HREF="#vim-variable">vim-variable</A>|<A HREF="change.html#s">s</A> must be prefixed by &quot;<A HREF="#v:">v:</A>&quot;.  E.g. &quot;version&quot; doesn't
	work <A HREF="motion.html#as">as</A> |<A HREF="#v:version">v:version</A>| anymore, <A HREF="motion.html#it">it</A> can be used <A HREF="motion.html#as">as</A> a normal variable.
	Same for some obvious names <A HREF="motion.html#as">as</A> &quot;<A HREF="intro.html#count">count</A>&quot; and others.

	Test for support with:
<B>		has('vimscript-3')</B>
 

							*<A NAME="scriptversion-4"></A><B>scriptversion-4</B>* 
<B> :scriptversion 4</B>
 	Numbers with a leading zero are not recognized <A HREF="motion.html#as">as</A> <A HREF="#octal">octal</A>.  &quot;<A HREF="#0o">0o</A>&quot; or &quot;0O&quot;
	is still recognized <A HREF="motion.html#as">as</A> <A HREF="#octal">octal</A>.  With the
	previous version you get:
<B>		echo 017   " displays 15 (octal)</B>
<B>		echo 0o17  " displays 15 (octal)</B>
<B>		echo 018   " displays 18 (decimal)</B>
 	with <A HREF="usr_41.html#script">script</A> version 4:
<B>		echo 017   " displays 17 (decimal)</B>
<B>		echo 0o17  " displays 15 (octal)</B>
<B>		echo 018   " displays 18 (decimal)</B>
 	Also, <A HREF="motion.html#it">it</A> is possible to use single <A HREF="quotes.html#quotes">quotes</A> inside numbers to make them
	easier to read:
<B>		echo 1'000'000</B>
 	The <A HREF="quotes.html#quotes">quotes</A> must be surrounded by digits.

	Test for support with:
<B>		has('vimscript-4')</B>

==============================================================================

11. No <A HREF="various.html#+eval">+eval</A> feature				*<A NAME="no-eval-feature"></A><B>no-eval-feature</B>*

When the |<A HREF="various.html#+eval">+eval</A>| feature was disabled at compile time, none of the <A HREF="#expression">expression</A>
evaluation commands are available.  To prevent this from causing Vim scripts
to generate all kinds of <A HREF="message.html#errors">errors</A>, the &quot;<A HREF="#:if">:if</A>&quot; and &quot;<A HREF="#:endif">:endif</A>&quot; commands are still
recognized, though the argument of the &quot;<A HREF="#:if">:if</A>&quot; and everything between the &quot;<A HREF="#:if">:if</A>&quot;
and the matching &quot;<A HREF="#:endif">:endif</A>&quot; is ignored.  Nesting of &quot;<A HREF="#:if">:if</A>&quot; blocks is allowed, but
only if the commands are at the start of the line.  The &quot;<A HREF="#:else">:else</A>&quot; command is not
recognized.

Example of how to avoid executing commands when the |<A HREF="various.html#+eval">+eval</A>| feature is
missing:

<B>	:if 1</B>
<B>	:  echo "Expression evaluation is compiled in"</B>
<B>	:else</B>
<B>	:  echo "You will _never_ see this message"</B>
<B>	:endif</B>

To execute a command only when the |<A HREF="various.html#+eval">+eval</A>| feature is disabled can be done in
two ways.  The simplest is to exit the <A HREF="usr_41.html#script">script</A> (or Vim) prematurely:
<B>	if 1</B>
<B>	   echo "commands executed with +eval"</B>
<B>	   finish</B>
<B>	endif</B>
<B>	args  " command executed without +eval</B>

If you <A HREF="diff.html#do">do</A> not want to abort loading the <A HREF="usr_41.html#script">script</A> you can use a trick, <A HREF="motion.html#as">as</A> this
example shows:

<B>	silent! while 0</B>
<B>	  set history=111</B>
<B>	silent! endwhile</B>

When the |<A HREF="various.html#+eval">+eval</A>| feature is available the command is skipped because of the
&quot;while 0&quot;.  Without the |<A HREF="various.html#+eval">+eval</A>| feature the &quot;while 0&quot; is an error, which is
silently ignored, and the command is executed.

==============================================================================

12. The <A HREF="#sandbox">sandbox</A>					*<A NAME="eval-sandbox"></A><B>eval-sandbox</B>* *<A NAME="sandbox"></A><B>sandbox</B>*

The <A HREF="options.html#'foldexpr'">'foldexpr'</A>, <A HREF="options.html#'formatexpr'">'formatexpr'</A>, <A HREF="options.html#'includeexpr'">'includeexpr'</A>, <A HREF="options.html#'indentexpr'">'indentexpr'</A>, <A HREF="options.html#'statusline'">'statusline'</A> and
<A HREF="options.html#'foldtext'">'foldtext'</A> <A HREF="options.html#options">options</A> may be evaluated in a <A HREF="#sandbox">sandbox</A>.  This means that you are
protected from these expressions having nasty side effects.  This gives some
safety for when these <A HREF="options.html#options">options</A> are set from a <A HREF="options.html#modeline">modeline</A>.  It is also used when
the command from a <A HREF="tagsrch.html#tags">tags</A> file is executed and for <A HREF="undo.html#CTRL-R">CTRL-R</A> = in the command line.
The sandbox is also used for the |<A HREF="#:sandbox">:sandbox</A>| command.

								*<A NAME="E48"></A><B>E48</B>*
These items are not allowed in the <A HREF="#sandbox">sandbox</A>:
	- <A HREF="change.html#changing">changing</A> the buffer text
	- defining or <A HREF="change.html#changing">changing</A> <A HREF="map.html#mapping">mapping</A>, <A HREF="autocmd.html#autocommands">autocommands</A>, user commands
	- setting certain <A HREF="options.html#options">options</A> (see |<A HREF="options.html#option-summary">option-summary</A>|)

	- setting certain v: <A HREF="#variables">variables</A> (see |<A HREF="#v:var">v:var</A>|)  *<A NAME="E794"></A><B>E794</B>*
	- executing a shell command
	- reading or <A HREF="editing.html#writing">writing</A> a file
	- jumping to another buffer or editing a file
	- executing <A HREF="if_pyth.html#Python">Python</A>, <A HREF="if_perl.html#Perl">Perl</A>, etc. commands
This is not guaranteed 100&#37; secure, but <A HREF="motion.html#it">it</A> should block most attacks.


							*<A NAME=":san"></A><B>:san</B>* *<A NAME=":sandbox"></A><B>:sandbox</B>*
:san[dbox] {cmd}	Execute {cmd} in the <A HREF="#sandbox">sandbox</A>.  Useful to evaluate an
			option that may have been set from a <A HREF="options.html#modeline">modeline</A>, e.g.
			<A HREF="options.html#'foldexpr'">'foldexpr'</A>.


							*<A NAME="sandbox-option"></A><B>sandbox-option</B>*
A few <A HREF="options.html#options">options</A> contain an <A HREF="#expression">expression</A>.  When this <A HREF="#expression">expression</A> is evaluated <A HREF="motion.html#it">it</A> may
have to be done in the <A HREF="#sandbox">sandbox</A> to avoid a security risk.  But the <A HREF="#sandbox">sandbox</A> is
restrictive, thus this only happens when the option was set from an insecure
location.  Insecure in this context are:
- sourcing a <A HREF="starting.html#.vimrc">.vimrc</A> or <A HREF="starting.html#.exrc">.exrc</A> in the current directory
- while executing in the <A HREF="#sandbox">sandbox</A>
- value coming from a <A HREF="options.html#modeline">modeline</A>
- executing a function that was defined in the <A HREF="#sandbox">sandbox</A>

Note that when in the <A HREF="#sandbox">sandbox</A> and saving an option value and restoring <A HREF="motion.html#it">it</A>, the
option will still be marked <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> was set in the <A HREF="#sandbox">sandbox</A>.

==============================================================================

13. Textlock							*<A NAME="textlock"></A><B>textlock</B>*

In a few situations <A HREF="motion.html#it">it</A> is not allowed to change the text in the buffer, jump
to another <A HREF="windows.html#window">window</A> and some other things that might confuse or break what Vim
is currently doing.  This mostly applies to things that happen when Vim is
actually doing something else.  For example, evaluating the <A HREF="options.html#'balloonexpr'">'balloonexpr'</A> may
happen any moment the mouse cursor is resting at some position.

This is not allowed when the <A HREF="#textlock">textlock</A> is active:
	- <A HREF="change.html#changing">changing</A> the buffer text
	- jumping to another buffer or <A HREF="windows.html#window">window</A>
	- editing another file
	- closing a <A HREF="windows.html#window">window</A> or quitting Vim
	- etc.


<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
