<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Vim documentation: if_pyth</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Vim documentation: if_pyth</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="if_pyth.txt"></A><B>if_pyth.txt</B>*   For Vim version 9.0.  Last change: 2022 Feb 22


		  VIM REFERENCE MANUAL    by Paul Moore



The <A HREF="#Python">Python</A> Interface to Vim				*<A NAME="python"></A><B>python</B>* *<A NAME="Python"></A><B>Python</B>*

1. Commands					|<A HREF="#python-commands">python-commands</A>|
2. The vim module				|<A HREF="#python-vim">python-vim</A>|
3. Buffer <A HREF="index.html#objects">objects</A>				|<A HREF="#python-buffer">python-buffer</A>|
4. Range <A HREF="index.html#objects">objects</A>				|<A HREF="#python-range">python-range</A>|
5. Window <A HREF="index.html#objects">objects</A>				|<A HREF="#python-window">python-window</A>|
6. <A HREF="intro.html#Tab">Tab</A> page <A HREF="index.html#objects">objects</A>				|<A HREF="#python-tabpage">python-tabpage</A>|
7. vim.bindeval objects				|<A HREF="#python-bindeval-objects">python-bindeval-objects</A>|
8. <A HREF="builtin.html#pyeval()">pyeval()</A>, <A HREF="builtin.html#py3eval()">py3eval()</A> Vim <A HREF="eval.html#functions">functions</A>		|<A HREF="#python-pyeval">python-pyeval</A>|
9. Dynamic loading				|<A HREF="#python-dynamic">python-dynamic</A>|
10. <A HREF="#Python">Python</A> 3					|<A HREF="#python3">python3</A>|
11. <A HREF="#Python">Python</A> X					|<A HREF="#python_x">python_x</A>|
12. Building with <A HREF="#Python">Python</A> support		|<A HREF="#python-building">python-building</A>|

The <A HREF="#Python">Python</A> 2.x interface is available only when Vim was compiled with the
|<A HREF="various.html#+python">+python</A>| feature.
The <A HREF="#Python">Python</A> 3 interface is available only when Vim was compiled with the
|<A HREF="various.html#+python3">+python3</A>| feature.
Both can be available at the same time, but read |<A HREF="#python-2-and-3">python-2-and-3</A>|.

NOTE: <A HREF="#Python">Python</A> 2 is old and no longer being developed.  Using <A HREF="#Python">Python</A> 3 is highly
recommended.  <A HREF="#Python">Python</A> 2 support will be dropped when <A HREF="motion.html#it">it</A> does not work properly
anymore.

==============================================================================

1. Commands						*<A NAME="python-commands"></A><B>python-commands</B>*


					*<A NAME=":python"></A><B>:python</B>* *<A NAME=":py"></A><B>:py</B>* *<A NAME="E263"></A><B>E263</B>* *<A NAME="E264"></A><B>E264</B>* *<A NAME="E887"></A><B>E887</B>*
:[range]py[thon] {stmt}
			Execute <A HREF="#Python">Python</A> statement {stmt}.  A simple check if
			the `:python` command is working:
<B>				:python print "Hello"</B>

:[range]py[thon] <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> [trim] [{endmarker}]
{script}
{endmarker}
			Execute <A HREF="#Python">Python</A> <A HREF="usr_41.html#script">script</A> {script}.
			Note: This command doesn't work when the <A HREF="#Python">Python</A>
			feature wasn't compiled in.  To avoid <A HREF="message.html#errors">errors</A>, see
			|<A HREF="if_perl.html#script-here">script-here</A>|.

If [endmarker] is omitted from after the &quot;<A HREF="change.html#&lt;&lt;">&lt;&lt;</A>&quot;, a dot '<A HREF="repeat.html#.">.</A>' must be used after
{script}, like for the |<A HREF="insert.html#:append">:append</A>| and |<A HREF="insert.html#:insert">:insert</A>| commands.  Refer to
|<A HREF="eval.html#:let-heredoc">:let-heredoc</A>| for more information.

This form of the |<A HREF="#:python">:python</A>| command is mainly useful for including python code
in Vim scripts.

Example:
<B>	function! IcecreamInitialize()</B>
<B>	python &lt;&lt; EOF</B>
<B>	class StrawberryIcecream:</B>
<B>		def __call__(self):</B>
<B>			print 'EAT ME'</B>
<B>	EOF</B>
<B>	endfunction</B>

To see what version of <A HREF="#Python">Python</A> you have:
<B>	:python print(sys.version)</B>

There is no need to import sys, it's done by default.


							*<A NAME="python-environment"></A><B>python-environment</B>*
Environment <A HREF="eval.html#variables">variables</A> set in Vim are not always available in <A HREF="#Python">Python</A>.  This
depends on how Vim and <A HREF="#Python">Python</A> were built.  Also see
https://docs.python.org/3/library/os.html#os.environ

Note: <A HREF="#Python">Python</A> is very sensitive to the indenting.  Make sure the &quot;class&quot; line
and &quot;EOF&quot; <A HREF="diff.html#do">do</A> not have any indent.


							*<A NAME=":pydo"></A><B>:pydo</B>*
:[range]pydo {body}	Execute <A HREF="#Python">Python</A> function &quot;def _vim_pydo(line, linenr):
			{body}&quot; for each line in the <A HREF="cmdline.html#[range]">[range]</A>, with the
			function arguments being set to the text of each line
			in turn, without a trailing <A HREF="intro.html#&lt;EOL&gt;">&lt;EOL&gt;</A>, and the current
			line number. The function should return a <A HREF="eval.html#string">string</A> or
			<A HREF="eval.html#None">None</A>. If a <A HREF="eval.html#string">string</A> is returned, <A HREF="motion.html#it">it</A> becomes the text of
			the line in the current turn. The default for <A HREF="cmdline.html#[range]">[range]</A>
			is the whole file: &quot;1,$&quot;.

Examples:

<B>	:pydo return "%s\t%d" % (line[::-1], len(line))</B>
<B>	:pydo if line: return "%4d: %s" % (linenr, line)</B>
 
One can use `:pydo` in possible conjunction with `:py` to <A HREF="change.html#filter">filter</A> a range using
<A HREF="#python">python</A>. For example:

<B>	:py3 &lt;&lt; EOF</B>
<B>	needle = vim.eval('@a')</B>
<B>	replacement = vim.eval('@b')</B>

<B>	def py_vim_string_replace(str):</B>
<B>		return str.replace(needle, replacement)</B>
<B>	EOF</B>
<B>	:'&lt;,'&gt;py3do return py_vim_string_replace(line)</B>
 

							*<A NAME=":pyfile"></A><B>:pyfile</B>* *<A NAME=":pyf"></A><B>:pyf</B>*
:[range]pyf[ile] <A HREF="editing.html#{file}">{file}</A>
			Execute the <A HREF="#Python">Python</A> <A HREF="usr_41.html#script">script</A> in <A HREF="editing.html#{file}">{file}</A>.  The whole
			argument is used <A HREF="motion.html#as">as</A> a single file name.

Both of these commands <A HREF="diff.html#do">do</A> essentially the same thing - they execute a piece of
<A HREF="#Python">Python</A> code, with the &quot;current range&quot; |<A HREF="#python-range">python-range</A>| set to the given line
range.

In the <A HREF="change.html#case">case</A> of <A HREF="#:python">:python</A>, the code to execute is in the command-line.
In the <A HREF="change.html#case">case</A> of <A HREF="#:pyfile">:pyfile</A>, the code to execute is the contents of the given file.

<A HREF="#Python">Python</A> commands cannot be used in the |<A HREF="eval.html#sandbox">sandbox</A>|.

To pass arguments you need to set sys.argv[] explicitly.  Example:

<B>	:python sys.argv = ["foo", "bar"]</B>
<B>	:pyfile myscript.py</B>


Here are some examples					*<A NAME="python-examples"></A><B>python-examples</B>* 

<B>	:python from vim import *</B>
<B>	:python from string import upper</B>
<B>	:python current.line = upper(current.line)</B>
<B>	:python print "Hello"</B>
<B>	:python str = current.buffer[42]</B>

(Note that changes - like the imports - persist from one command to the next,
just like in the <A HREF="#Python">Python</A> interpreter.)

==============================================================================

2. The vim module					*<A NAME="python-vim"></A><B>python-vim</B>*

<A HREF="#Python">Python</A> code gets all of its access to vim (with one exception - see
|<A HREF="#python-output">python-output</A>| below) via the &quot;vim&quot; module.  The vim module implements two
methods, three constants, and one error object.  You need to import the vim
module before using <A HREF="motion.html#it">it</A>:
<B>	:python import vim</B>

Overview
<B>	:py print "Hello"		# displays a message</B>
<B>	:py vim.command(cmd)		# execute an Ex command</B>
<B>	:py w = vim.windows[n]		# gets window "n"</B>
<B>	:py cw = vim.current.window	# gets the current window</B>
<B>	:py b = vim.buffers[n]		# gets buffer "n"</B>
<B>	:py cb = vim.current.buffer	# gets the current buffer</B>
<B>	:py w.height = lines		# sets the window height</B>
<B>	:py w.cursor = (row, col)	# sets the window cursor position</B>
<B>	:py pos = w.cursor		# gets a tuple (row, col)</B>
<B>	:py name = b.name		# gets the buffer file name</B>
<B>	:py line = b[n]			# gets a line from the buffer</B>
<B>	:py lines = b[n:m]		# gets a list of lines</B>
<B>	:py num = len(b)		# gets the number of lines</B>
<B>	:py b[n] = str			# sets a line in the buffer</B>
<B>	:py b[n:m] = [str1, str2, str3]	# sets a number of lines at once</B>
<B>	:py del b[n]			# deletes a line</B>
<B>	:py del b[n:m]			# deletes a number of lines</B>


Methods of the &quot;vim&quot; module


vim.command(str)					*<A NAME="python-command"></A><B>python-command</B>*
	Executes the vim (ex-mode) command str.  Returns <A HREF="eval.html#None">None</A>.
	Examples:
<B>	    :py vim.command("set tw=72")</B>
<B>	    :py vim.command("%s/aaa/bbb/g")</B>
 	The following definition executes <A HREF="intro.html#Normal">Normal</A> mode commands:
<B>		def normal(str):</B>
<B>			vim.command("normal "+str)</B>
<B>		# Note the use of single quotes to delimit a string containing</B>
<B>		# double quotes</B>
<B>		normal('"a2dd"aP')</B>

 								*<A NAME="E659"></A><B>E659</B>*
	The &quot;<A HREF="#:python">:python</A>&quot; command cannot be used recursively with <A HREF="#Python">Python</A> 2.2 and
	older.  This only works with <A HREF="#Python">Python</A> 2.3 and later:
<B>	    :py vim.command("python print 'Hello again Python'")</B>


vim.eval(str)						*<A NAME="python-eval"></A><B>python-eval</B>*
	Evaluates the <A HREF="eval.html#expression">expression</A> str using the vim internal <A HREF="eval.html#expression">expression</A>
	evaluator (see |<A HREF="eval.html#expression">expression</A>|).  Returns the expression result <A HREF="motion.html#as">as</A>:
	- a <A HREF="eval.html#string">string</A> if the Vim <A HREF="eval.html#expression">expression</A> evaluates to a <A HREF="eval.html#string">string</A> or number
	- a <A HREF="eval.html#list">list</A> if the Vim <A HREF="eval.html#expression">expression</A> evaluates to a Vim <A HREF="eval.html#list">list</A>
	- a dictionary if the Vim <A HREF="eval.html#expression">expression</A> evaluates to a Vim dictionary
	<A HREF="eval.html#Dictionaries">Dictionaries</A> and lists are recursively expanded.
	Examples:
<B>	    :" value of the 'textwidth' option</B>
<B>	    :py text_width = vim.eval("&amp;tw")</B>
<B>	    :</B>
<B>	    :" contents of the 'a' register</B>
<B>	    :py a_reg = vim.eval("@a")</B>
<B>	    :</B>
<B>	    :" Result is a string! Use string.atoi() to convert to a number.</B>
<B>	    :py str = vim.eval("12+12")</B>
<B>	    :</B>
<B>	    :py tagList = vim.eval('taglist("eval_expr")')</B>
 	The latter will return a <A HREF="#python">python</A> <A HREF="eval.html#list">list</A> of <A HREF="#python">python</A> dicts, for instance:
<B><FONT COLOR="PURPLE">	[{'cmd': '/^eval_expr(arg, nextcmd)$/', 'static': 0, 'name': </FONT></B>
<B><FONT COLOR="PURPLE">	'eval_expr', 'kind': 'f', 'filename': './src/eval.c'}] </FONT></B>


vim.bindeval(str)					*<A NAME="python-bindeval"></A><B>python-bindeval</B>*
	Like |<A HREF="#python-eval">python-eval</A>|, but returns special <A HREF="index.html#objects">objects</A> described in
	|<A HREF="#python-bindeval-objects">python-bindeval-objects</A>|. These python objects let you modify (|<A HREF="eval.html#List">List</A>|
	or |<A HREF="eval.html#Dictionary">Dictionary</A>|) or call (|<A HREF="eval.html#Funcref">Funcref</A>|) vim <A HREF="index.html#objects">objects</A>.


vim.strwidth(str)					*<A NAME="python-strwidth"></A><B>python-strwidth</B>*
	Like |strwidth()|: returns number of display cells str occupies, <A HREF="intro.html#tab">tab</A>
	is counted <A HREF="motion.html#as">as</A> one cell.


vim.foreach_rtp(callable)				*<A NAME="python-foreach_rtp"></A><B>python-foreach_rtp</B>*
	Call the given callable for each path in <A HREF="options.html#'runtimepath'">'runtimepath'</A> until either
	callable returns something but <A HREF="eval.html#None">None</A>, the exception is raised or there
	are no longer paths. If stopped in <A HREF="change.html#case">case</A> callable returned non-None,
	vim.foreach_rtp function returns the value returned by callable.

vim.chdir(*args, **kwargs)				*python-chdir*
vim.fchdir(*args, **kwargs)				*python-fchdir*
	Run os.chdir or os.fchdir, then all appropriate vim stuff.
	Note: you should not use these <A HREF="eval.html#functions">functions</A> directly, use os.chdir and
	      os.fchdir instead. Behavior of vim.fchdir is undefined in <A HREF="change.html#case">case</A>
	      os.fchdir does not exist.

Error object of the &quot;vim&quot; module


vim.error						*<A NAME="python-error"></A><B>python-error</B>*
	Upon encountering a Vim error, <A HREF="#Python">Python</A> raises an exception of type
	vim.error.
	Example:
<B>		try:</B>
<B>			vim.command("put a")</B>
<B>		except vim.error:</B>
<B>			# nothing in register a</B>

Constants of the &quot;vim&quot; module

	Note that these are not actually constants - you could reassign them.
	But this is silly, <A HREF="motion.html#as">as</A> you would then lose access to the vim <A HREF="index.html#objects">objects</A>
	to which the <A HREF="eval.html#variables">variables</A> referred.


vim.buffers						*<A NAME="python-buffers"></A><B>python-buffers</B>*
	A <A HREF="map.html#mapping">mapping</A> object providing access to the <A HREF="eval.html#list">list</A> of vim <A HREF="windows.html#buffers">buffers</A>.  The
	object supports the following operations:
<B>	    :py b = vim.buffers[i]	# Indexing (read-only)</B>
<B>	    :py b in vim.buffers	# Membership test</B>
<B>	    :py n = len(vim.buffers)	# Number of elements</B>
<B>	    :py for b in vim.buffers:	# Iterating over buffer list</B>
 

vim.windows						*<A NAME="python-windows"></A><B>python-windows</B>*
	A sequence object providing access to the <A HREF="eval.html#list">list</A> of vim <A HREF="windows.html#windows">windows</A>.  The
	object supports the following operations:
<B>	    :py w = vim.windows[i]	# Indexing (read-only)</B>
<B>	    :py w in vim.windows	# Membership test</B>
<B>	    :py n = len(vim.windows)	# Number of elements</B>
<B>	    :py for w in vim.windows:	# Sequential access</B>
 	Note: vim.windows object always accesses current <A HREF="intro.html#tab">tab</A> page.
	|<A HREF="#python-tabpage">python-tabpage</A>|.windows <A HREF="index.html#objects">objects</A> are bound to parent |<A HREF="#python-tabpage">python-tabpage</A>|
	object and always use <A HREF="windows.html#windows">windows</A> from that <A HREF="intro.html#tab">tab</A> page (or throw vim.error
	in <A HREF="change.html#case">case</A> <A HREF="intro.html#tab">tab</A> page was deleted). You can keep a reference to both
	without keeping a reference to vim module object or |<A HREF="#python-tabpage">python-tabpage</A>|,
	they will not lose their properties in this <A HREF="change.html#case">case</A>.


vim.tabpages						*<A NAME="python-tabpages"></A><B>python-tabpages</B>*
	A sequence object providing access to the <A HREF="eval.html#list">list</A> of vim <A HREF="intro.html#tab">tab</A> pages. The
	object supports the following operations:
<B>	    :py t = vim.tabpages[i]	# Indexing (read-only)</B>
<B>	    :py t in vim.tabpages	# Membership test</B>
<B>	    :py n = len(vim.tabpages)	# Number of elements</B>
<B>	    :py for t in vim.tabpages:	# Sequential access</B>
 

vim.current						*<A NAME="python-current"></A><B>python-current</B>*
	An object providing access (via specific attributes) to various
	&quot;current&quot; <A HREF="index.html#objects">objects</A> available in <A HREF="options.html#vim:">vim:</A>
		vim.current.line	The current line (RW)		<A HREF="eval.html#String">String</A>
		vim.current.buffer	The current buffer (RW)		Buffer
		vim.current.window	The current <A HREF="windows.html#window">window</A> (RW)		Window
		vim.current.tabpage	The current <A HREF="intro.html#tab">tab</A> page (RW)	TabPage
		vim.current.range	The current line range (RO)	Range

	The last <A HREF="change.html#case">case</A> deserves a little explanation.  When the <A HREF="#:python">:python</A> or
	<A HREF="#:pyfile">:pyfile</A> command specifies a range, this range of lines becomes the
	&quot;current range&quot;.  A range is a bit like a buffer, but with all access
	restricted to a subset of lines.  See |<A HREF="#python-range">python-range</A>| for more details.

	Note: When assigning to vim.current.{buffer,window,tabpage} <A HREF="motion.html#it">it</A> expects
	valid |<A HREF="#python-buffer">python-buffer</A>|, |<A HREF="#python-window">python-window</A>| or |<A HREF="#python-tabpage">python-tabpage</A>| <A HREF="index.html#objects">objects</A>
	respectively. Assigning triggers normal (with |<A HREF="autocmd.html#autocommand">autocommand</A>|<A HREF="change.html#s">s</A>)
	switching to given buffer, <A HREF="windows.html#window">window</A> or <A HREF="intro.html#tab">tab</A> page. It is the only way to
	switch UI <A HREF="index.html#objects">objects</A> in <A HREF="#python">python</A>: you can't assign to
	|<A HREF="#python-tabpage">python-tabpage</A>|.window attribute. To switch without triggering
	<A HREF="autocmd.html#autocommands">autocommands</A> use
<B>	    py &lt;&lt; EOF</B>
<B>	    saved_eventignore = vim.options['eventignore']</B>
<B>	    vim.options['eventignore'] = 'all'</B>
<B>	    try:</B>
<B>	        vim.current.buffer = vim.buffers[2] # Switch to buffer 2</B>
<B>	    finally:</B>
<B>	        vim.options['eventignore'] = saved_eventignore</B>
<B>	    EOF</B>
 

vim.vars						*<A NAME="python-vars"></A><B>python-vars</B>*

vim.vvars						*<A NAME="python-vvars"></A><B>python-vvars</B>*
	Dictionary-like <A HREF="index.html#objects">objects</A> holding dictionaries with global (|<A HREF="eval.html#g:">g:</A>|) and
	vim (|<A HREF="eval.html#v:">v:</A>|) <A HREF="eval.html#variables">variables</A> respectively. Identical to `vim.bindeval(&quot;g:&quot;)`,
	but faster.


vim.options						*<A NAME="python-options"></A><B>python-options</B>*
	Object partly supporting <A HREF="map.html#mapping">mapping</A> protocol (supports setting and
	getting items) providing a read-write access to global <A HREF="options.html#options">options</A>.
	Note: unlike |<A HREF="options.html#:set">:set</A>| this provides access only to global <A HREF="options.html#options">options</A>. You
	cannot use this object to obtain or set local options' values or
	access local-only <A HREF="options.html#options">options</A> in any fashion. Raises KeyError if no global
	option with such name exists (i.e. does not raise KeyError for
	|<A HREF="options.html#global-local">global-local</A>| <A HREF="options.html#options">options</A> and global only <A HREF="options.html#options">options</A>, but does for window-
	and buffer-local ones).  Use |<A HREF="#python-buffer">python-buffer</A>| <A HREF="index.html#objects">objects</A> to access to
	buffer-local <A HREF="options.html#options">options</A> and |<A HREF="#python-window">python-window</A>| <A HREF="index.html#objects">objects</A> to access to
	window-local <A HREF="options.html#options">options</A>.

	Type of this object is available via &quot;Options&quot; attribute of vim
	module.


Output from <A HREF="#Python">Python</A>					*<A NAME="python-output"></A><B>python-output</B>*
	Vim displays all <A HREF="#Python">Python</A> code output in the Vim message area.  <A HREF="intro.html#Normal">Normal</A>
	output appears <A HREF="motion.html#as">as</A> information <A HREF="message.html#messages">messages</A>, and error output appears <A HREF="motion.html#as">as</A>
	error <A HREF="message.html#messages">messages</A>.

	In implementation terms, this means that all output to sys.stdout
	(including the output from print statements) appears <A HREF="motion.html#as">as</A> information
	<A HREF="message.html#messages">messages</A>, and all output to sys.stderr (including error tracebacks)
	appears <A HREF="motion.html#as">as</A> error <A HREF="message.html#messages">messages</A>.


							*<A NAME="python-input"></A><B>python-input</B>*
	Input (via sys.stdin, including <A HREF="builtin.html#input()">input()</A> and raw_input()) is not
	supported, and may cause the program to crash.  This should probably be
	fixed.


		    *<A NAME="python2-directory"></A><B>python2-directory</B>* *<A NAME="python3-directory"></A><B>python3-directory</B>* *<A NAME="pythonx-directory"></A><B>pythonx-directory</B>*

<A HREF="#Python">Python</A> <A HREF="options.html#'runtimepath'">'runtimepath'</A> handling				*<A NAME="python-special-path"></A><B>python-special-path</B>*

In <A HREF="#python">python</A> vim.VIM_SPECIAL_PATH special directory is used <A HREF="motion.html#as">as</A> a replacement for
the <A HREF="eval.html#list">list</A> of paths found in <A HREF="options.html#'runtimepath'">'runtimepath'</A>: with this directory in sys.path and
vim.path_hooks in sys.path_hooks <A HREF="#python">python</A> will try to load module from
{rtp}/python2 (or <A HREF="#python3">python3</A>) and {rtp}/pythonx (for both <A HREF="#python">python</A> versions) for
each {rtp} found in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

Implementation is similar to the following, but written in C:

<B>    from imp import find_module, load_module</B>
<B>    import vim</B>
<B>    import sys</B>

<B>    class VimModuleLoader(object):</B>
<B>        def __init__(self, module):</B>
<B>            self.module = module</B>

<B>        def load_module(self, fullname, path=None):</B>
<B>            return self.module</B>

<B>    def _find_module(fullname, oldtail, path):</B>
<B>        idx = oldtail.find('.')</B>
<B>        if idx &gt; 0:</B>
<B>            name = oldtail[:idx]</B>
<B>            tail = oldtail[idx+1:]</B>
<B>            fmr = find_module(name, path)</B>
<B>            module = load_module(fullname[:-len(oldtail)] + name, *fmr)</B>
<B>            return _find_module(fullname, tail, module.__path__)</B>
<B>        else:</B>
<B>            fmr = find_module(fullname, path)</B>
<B>            return load_module(fullname, *fmr)</B>

<B>    # It uses vim module itself in place of VimPathFinder class: it does not</B>
<B>    # matter for python which object has find_module function attached to as</B>
<B>    # an attribute.</B>
<B>    class VimPathFinder(object):</B>
<B>        @classmethod</B>
<B>        def find_module(cls, fullname, path=None):</B>
<B>            try:</B>
<B>                return VimModuleLoader(_find_module(fullname, fullname, path or vim._get_paths()))</B>
<B>            except ImportError:</B>
<B>                return None</B>

<B>        @classmethod</B>
<B>        def load_module(cls, fullname, path=None):</B>
<B>            return _find_module(fullname, fullname, path or vim._get_paths())</B>

<B>    def hook(path):</B>
<B>        if path == vim.VIM_SPECIAL_PATH:</B>
<B>            return VimPathFinder</B>
<B>        else:</B>
<B>            raise ImportError</B>

<B>    sys.path_hooks.append(hook)</B>


vim.VIM_SPECIAL_PATH					*<A NAME="python-VIM_SPECIAL_PATH"></A><B>python-VIM_SPECIAL_PATH</B>*
	<A HREF="eval.html#String">String</A> constant used in conjunction with vim path hook. If path hook
	installed by vim is requested to handle anything but path equal to
	vim.VIM_SPECIAL_PATH constant <A HREF="motion.html#it">it</A> raises ImportError. In the only other
	<A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> uses special loader.

	Note: you must not use value of this constant directly, always use
	      vim.VIM_SPECIAL_PATH object.


vim.find_module(...)					*<A NAME="python-find_module"></A><B>python-find_module</B>*

vim.path_hook(path)					*<A NAME="python-path_hook"></A><B>python-path_hook</B>*
	Methods or <A HREF="index.html#objects">objects</A> used to implement path loading <A HREF="motion.html#as">as</A> described above.
	You should not be using any of these directly except for vim.path_hook
	in <A HREF="change.html#case">case</A> you need to <A HREF="diff.html#do">do</A> something with sys.meta_path. It is not
	guaranteed that any of the <A HREF="index.html#objects">objects</A> will exist in the future vim
	versions.


vim._get_paths						*<A NAME="python-_get_paths"></A><B>python-_get_paths</B>*
	Methods returning a <A HREF="eval.html#list">list</A> of paths which will be searched for by path
	hook. You should not rely on this <A HREF="eval.html#method">method</A> being present in future
	versions, but can use <A HREF="motion.html#it">it</A> for debugging.

	It returns a <A HREF="eval.html#list">list</A> of {rtp}/python2 (or {rtp}/python3) and
	{rtp}/pythonx directories for each {rtp} in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

==============================================================================

3. Buffer <A HREF="index.html#objects">objects</A>					*<A NAME="python-buffer"></A><B>python-buffer</B>*

Buffer <A HREF="index.html#objects">objects</A> represent vim <A HREF="windows.html#buffers">buffers</A>.  You can obtain them in a number of ways:
	- via vim.current.buffer (|<A HREF="#python-current">python-current</A>|)
	- from indexing vim.buffers (|<A HREF="#python-buffers">python-buffers</A>|)
	- from the &quot;buffer&quot; attribute of a window (|<A HREF="#python-window">python-window</A>|)

Buffer <A HREF="index.html#objects">objects</A> have two read-only attributes - name - the full file name for
the buffer, and number - the buffer number.  They also have three methods
(append, <A HREF="motion.html#mark">mark</A>, and range; see below).

You can also treat buffer <A HREF="index.html#objects">objects</A> <A HREF="motion.html#as">as</A> sequence <A HREF="index.html#objects">objects</A>.  In this context, they
act <A HREF="motion.html#as">as</A> if they were lists (yes, they are mutable) of strings, with each
element being a line of the buffer.  All of the usual sequence operations,
including indexing, index assignment, slicing and <A HREF="eval.html#slice">slice</A> assignment, work <A HREF="motion.html#as">as</A>
you would expect.  Note that the result of indexing (slicing) a buffer is a
<A HREF="eval.html#string">string</A> (list of strings).  This has one unusual consequence - b[:] is different
from <A HREF="motion.html#b">b</A>.  In particular, &quot;b[:] = None&quot; deletes the whole of the buffer, whereas
&quot;<A HREF="motion.html#b">b</A> = None&quot; merely updates the variable <A HREF="motion.html#b">b</A>, with no effect on the buffer.

Buffer indexes start at zero, <A HREF="motion.html#as">as</A> is normal in <A HREF="#Python">Python</A>.  This differs from vim
line numbers, which start from 1.  This is particularly relevant when dealing
with marks (see below) which use vim line numbers.

The buffer object attributes are:
	b.vars		Dictionary-like object used to access
			|<A HREF="eval.html#buffer-variable">buffer-variable</A>|<A HREF="change.html#s">s</A>.
	b.options	Mapping object (supports item getting, setting and
			<A HREF="change.html#deleting">deleting</A>) that provides access to buffer-local <A HREF="options.html#options">options</A>
			and buffer-local values of |<A HREF="options.html#global-local">global-local</A>| <A HREF="options.html#options">options</A>. Use
			|<A HREF="#python-window">python-window</A>|.options if option is window-local,
			this object will raise KeyError. If option is
			|<A HREF="options.html#global-local">global-local</A>| and local value is missing getting <A HREF="motion.html#it">it</A>
			will return <A HREF="eval.html#None">None</A>.
	b.name		<A HREF="eval.html#String">String</A>, RW. Contains buffer name (full path).
			Note: when assigning to b.name |<A HREF="autocmd.html#BufFilePre">BufFilePre</A>| and
			|<A HREF="autocmd.html#BufFilePost">BufFilePost</A>| <A HREF="autocmd.html#autocommands">autocommands</A> are launched.
	b.number	Buffer number. Can be used <A HREF="motion.html#as">as</A> |<A HREF="#python-buffers">python-buffers</A>| key.
			Read-only.
	b.valid		True or False. Buffer object becomes invalid when
			corresponding buffer is wiped out.

The buffer object methods are:
	b.append(str)	Append a line to the buffer
	b.append(str, nr)  Idem, below line &quot;nr&quot;
	b.append(list)	Append a <A HREF="eval.html#list">list</A> of lines to the buffer
			Note that the option of supplying a <A HREF="eval.html#list">list</A> of strings to
			the append <A HREF="eval.html#method">method</A> differs from the equivalent <A HREF="eval.html#method">method</A>
			for Python's built-in <A HREF="eval.html#list">list</A> <A HREF="index.html#objects">objects</A>.
	b.append(list, nr)  Idem, below line &quot;nr&quot;
	b.mark(name)	Return a tuple (row,col) representing the position
			of the named <A HREF="motion.html#mark">mark</A> (can also get the []&quot;&lt;&gt; marks)
	b.range(s,e)	Return a range object (see |<A HREF="#python-range">python-range</A>|) which
			represents the part of the given buffer between line
			numbers s and e |<A HREF="motion.html#inclusive">inclusive</A>|.

Note that when adding a line <A HREF="motion.html#it">it</A> must not contain a line break character '\n'.
A trailing '\n' is allowed and ignored, so that you can <A HREF="diff.html#do">do</A>:
<B>	:py b.append(f.readlines())</B>

Buffer object type is available using &quot;Buffer&quot; attribute of vim module.

Examples (assume <A HREF="motion.html#b">b</A> is the current buffer)
<B>	:py print b.name		# write the buffer file name</B>
<B>	:py b[0] = "hello!!!"		# replace the top line</B>
<B>	:py b[:] = None			# delete the whole buffer</B>
<B>	:py del b[:]			# delete the whole buffer</B>
<B>	:py b[0:0] = [ "a line" ]	# add a line at the top</B>
<B>	:py del b[2]			# delete a line (the third)</B>
<B>	:py b.append("bottom")		# add a line at the bottom</B>
<B>	:py n = len(b)			# number of lines</B>
<B>	:py (row,col) = b.mark('a')	# named mark</B>
<B>	:py r = b.range(1,5)		# a sub-range of the buffer</B>
<B>	:py b.vars["foo"] = "bar"	# assign b:foo variable</B>
<B>	:py b.options["ff"] = "dos"	# set fileformat</B>
<B>	:py del b.options["ar"]		# same as :set autoread&lt;</B>

==============================================================================

4. Range <A HREF="index.html#objects">objects</A>					*<A NAME="python-range"></A><B>python-range</B>*

Range <A HREF="index.html#objects">objects</A> represent a part of a vim buffer.  You can obtain them in a
number of ways:
	- via vim.current.range (|<A HREF="#python-current">python-current</A>|)
	- from a buffer's <A HREF="builtin.html#range()">range()</A> <A HREF="eval.html#method">method</A> (|<A HREF="#python-buffer">python-buffer</A>|)

A range object is almost identical in operation to a buffer object.  However,
all operations are restricted to the lines within the range (this line range
can, of course, change <A HREF="motion.html#as">as</A> a result of <A HREF="eval.html#slice">slice</A> assignments, line deletions, or
the range.append() <A HREF="eval.html#method">method</A>).

The range object attributes are:
	r.start		Index of first line into the buffer
	r.end		Index of last line into the buffer

The range object methods are:
	r.append(str)	Append a line to the range
	r.append(str, nr)  Idem, after line &quot;nr&quot;
	r.append(list)	Append a <A HREF="eval.html#list">list</A> of lines to the range
			Note that the option of supplying a <A HREF="eval.html#list">list</A> of strings to
			the append <A HREF="eval.html#method">method</A> differs from the equivalent <A HREF="eval.html#method">method</A>
			for Python's built-in <A HREF="eval.html#list">list</A> <A HREF="index.html#objects">objects</A>.
	r.append(list, nr)  Idem, after line &quot;nr&quot;

Range object type is available using &quot;Range&quot; attribute of vim module.

Example (assume <A HREF="change.html#r">r</A> is the current range):
	# Send all lines in a range to the default printer
	vim.command(&quot;&#37;d,&#37;dhardcopy!&quot; <A HREF="motion.html#&#37;">&#37;</A> (r.start+1,r.end+1))

==============================================================================

5. Window <A HREF="index.html#objects">objects</A>					*<A NAME="python-window"></A><B>python-window</B>*

Window <A HREF="index.html#objects">objects</A> represent vim <A HREF="windows.html#windows">windows</A>.  You can obtain them in a number of ways:
	- via vim.current.window (|<A HREF="#python-current">python-current</A>|)
	- from indexing vim.windows (|<A HREF="#python-windows">python-windows</A>|)
	- from indexing &quot;<A HREF="windows.html#windows">windows</A>&quot; attribute of a tab page (|<A HREF="#python-tabpage">python-tabpage</A>|)
	- from the &quot;<A HREF="windows.html#window">window</A>&quot; attribute of a tab page (|<A HREF="#python-tabpage">python-tabpage</A>|)

You can manipulate <A HREF="windows.html#window">window</A> <A HREF="index.html#objects">objects</A> only through their attributes.  They have no
methods, and no sequence or other interface.

Window attributes are:
	buffer (read-only)	The buffer displayed in this <A HREF="windows.html#window">window</A>
	cursor (read-write)	The current cursor position in the <A HREF="windows.html#window">window</A>
				This is a tuple, (row,col).
	height (read-write)	The <A HREF="windows.html#window">window</A> height, in rows
	width (read-write)	The <A HREF="windows.html#window">window</A> width, in columns
	vars (read-only)	The <A HREF="windows.html#window">window</A> |<A HREF="eval.html#w:">w:</A>| <A HREF="eval.html#variables">variables</A>. Attribute is
				unassignable, but you can change <A HREF="windows.html#window">window</A>
				<A HREF="eval.html#variables">variables</A> this way
	<A HREF="options.html#options">options</A> (read-only)	The window-local <A HREF="options.html#options">options</A>. Attribute is
				unassignable, but you can change <A HREF="windows.html#window">window</A>
				<A HREF="options.html#options">options</A> this way. Provides access only to
				window-local <A HREF="options.html#options">options</A>, for buffer-local use
				|<A HREF="#python-buffer">python-buffer</A>| and for global ones use
				|<A HREF="#python-options">python-options</A>|. If option is |<A HREF="options.html#global-local">global-local</A>|
				and local value is missing getting <A HREF="motion.html#it">it</A> will
				return <A HREF="eval.html#None">None</A>.
	number (read-only)	Window number.  The first <A HREF="windows.html#window">window</A> has number 1.
				This is zero in <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> cannot be determined
				(e.g. when the <A HREF="windows.html#window">window</A> object belongs to other
				<A HREF="intro.html#tab">tab</A> page).
	row, col (read-only)	On-screen <A HREF="windows.html#window">window</A> position in display cells.
				First position is zero.
	<A HREF="tabpage.html#tabpage">tabpage</A> (read-only)	Window <A HREF="intro.html#tab">tab</A> page.
	valid (read-write)	True or False. Window object becomes invalid
				when corresponding <A HREF="windows.html#window">window</A> is closed.

The height attribute is writable only if the screen is split horizontally.
The width attribute is writable only if the screen is split vertically.

Window object type is available using &quot;Window&quot; attribute of vim module.

==============================================================================

6. <A HREF="intro.html#Tab">Tab</A> page <A HREF="index.html#objects">objects</A>					*<A NAME="python-tabpage"></A><B>python-tabpage</B>*

<A HREF="intro.html#Tab">Tab</A> page <A HREF="index.html#objects">objects</A> represent vim <A HREF="intro.html#tab">tab</A> pages. You can obtain them in a number of
ways:
	- via vim.current.tabpage (|<A HREF="#python-current">python-current</A>|)
	- from indexing vim.tabpages (|<A HREF="#python-tabpages">python-tabpages</A>|)

You can use this object to access <A HREF="intro.html#tab">tab</A> page <A HREF="windows.html#windows">windows</A>. They have no methods and
no sequence or other interfaces.

<A HREF="intro.html#Tab">Tab</A> page attributes are:
	number		The <A HREF="intro.html#tab">tab</A> page number like the one returned by
			|<A HREF="builtin.html#tabpagenr()">tabpagenr()</A>|.
	windows		Like |<A HREF="#python-windows">python-windows</A>|, but for current <A HREF="intro.html#tab">tab</A> page.
	vars		The <A HREF="intro.html#tab">tab</A> page |<A HREF="eval.html#t:">t:</A>| <A HREF="eval.html#variables">variables</A>.
	<A HREF="windows.html#window">window</A>		Current <A HREF="tabpage.html#tabpage">tabpage</A> <A HREF="windows.html#window">window</A>.
	valid		True or False. <A HREF="intro.html#Tab">Tab</A> page object becomes invalid when
			corresponding <A HREF="intro.html#tab">tab</A> page is closed.

TabPage object type is available using &quot;TabPage&quot; attribute of vim module.

==============================================================================

7. vim.bindeval <A HREF="index.html#objects">objects</A>				*<A NAME="python-bindeval-objects"></A><B>python-bindeval-objects</B>*


vim.Dictionary object				*<A NAME="python-Dictionary"></A><B>python-Dictionary</B>*
    Dictionary-like object providing access to vim |<A HREF="eval.html#Dictionary">Dictionary</A>| type.
    Attributes:
<B><FONT COLOR="PURPLE">        Attribute  Description </FONT></B>

        locked     One of                       *<A NAME="python-.locked"></A><B>python-.locked</B>*
<B><FONT COLOR="PURPLE">                    Value           Description </FONT></B>
                    zero            Variable is not locked
                    vim.VAR_LOCKED  Variable is locked, but can be unlocked
                    vim.VAR_FIXED   Variable is locked and can't be unlocked
                   Read-write. You can unlock locked variable by assigning
                   `True` or `False` to this attribute. No recursive locking
                   is supported.
        scope      One of
<B><FONT COLOR="PURPLE">                    Value              Description </FONT></B>
                    zero               <A HREF="eval.html#Dictionary">Dictionary</A> is not a scope one
                    vim.VAR_DEF_SCOPE  |<A HREF="eval.html#g:">g:</A>| or |<A HREF="eval.html#l:">l:</A>| dictionary
                    vim.VAR_SCOPE      Other scope dictionary,
                                       see |<A HREF="eval.html#internal-variables">internal-variables</A>|
    Methods (note: methods <A HREF="diff.html#do">do</A> not support keyword arguments):
<B><FONT COLOR="PURPLE">        Method      Description </FONT></B>
        <A HREF="builtin.html#keys()">keys()</A>      Returns a <A HREF="eval.html#list">list</A> with dictionary keys.
        <A HREF="builtin.html#values()">values()</A>    Returns a <A HREF="eval.html#list">list</A> with dictionary values.
        <A HREF="builtin.html#items()">items()</A>     Returns a <A HREF="eval.html#list">list</A> of 2-tuples with dictionary contents.
        update(iterable), update(dictionary), update(**kwargs)
                    Adds keys to dictionary.
        get(key[, default=None])
                    Obtain key from dictionary, returning the default if <A HREF="motion.html#it">it</A> is
                    not present.
        pop(key[, default])
                    Remove specified key from dictionary and return
                    corresponding value. If key is not found and default is
                    given returns the default, otherwise raises KeyError.
        popitem()
                    Remove <A HREF="builtin.html#random">random</A> key from dictionary and return (key, value)
                    pair.
        has_key(key)
                    Check whether dictionary contains specified key, similar
                    to `key in dict`.

        __new__(), __new__(iterable), __new__(dictionary), __new__(update)
                    You can use `vim.Dictionary()` to create new vim
                    dictionaries. `d=vim.Dictionary(arg)` is the same <A HREF="motion.html#as">as</A>
                    `d=vim.bindeval('{}');d.update(arg)`. Without arguments
                    constructs empty dictionary.

    Examples:
<B>        d = vim.Dictionary(food="bar")		# Constructor</B>
<B>        d['a'] = 'b'				# Item assignment</B>
<B>        print d['a']				# getting item</B>
<B>        d.update({'c': 'd'})			# .update(dictionary)</B>
<B>        d.update(e='f')				# .update(**kwargs)</B>
<B>        d.update((('g', 'h'), ('i', 'j')))	# .update(iterable)</B>
<B>        for key in d.keys():			# .keys()</B>
<B>        for val in d.values():			# .values()</B>
<B>        for key, val in d.items():		# .items()</B>
<B>        print isinstance(d, vim.Dictionary)	# True</B>
<B>        for key in d:				# Iteration over keys</B>
<B>        class Dict(vim.Dictionary):		# Subclassing</B>
 
    Note: when iterating over keys you should not modify dictionary.


vim.List object					*<A NAME="python-List"></A><B>python-List</B>*
    Sequence-like object providing access to vim |<A HREF="eval.html#List">List</A>| type.
    Supports `.locked` attribute, see |<A HREF="python-.html">python-.locked</A>|. Also supports the
    following methods:
<B><FONT COLOR="PURPLE">        Method          Description </FONT></B>
        extend(item)    Add items to the <A HREF="eval.html#list">list</A>.

        __new__(), __new__(iterable)
                        You can use `vim.List()` to create new vim lists.
                        `l=vim.List(iterable)` is the same <A HREF="motion.html#as">as</A>
                        `l=vim.bindeval('[]');l.extend(iterable)`. Without
                        arguments constructs empty <A HREF="eval.html#list">list</A>.
    Examples:
<B>        l = vim.List("abc")		# Constructor, result: ['a', 'b', 'c']</B>
<B>        l.extend(['abc', 'def'])	# .extend() method</B>
<B>        print l[1:]			# slicing</B>
<B>        l[:0] = ['ghi', 'jkl']		# slice assignment</B>
<B>        print l[0]			# getting item</B>
<B>        l[0] = 'mno'			# assignment</B>
<B>        for i in l:			# iteration</B>
<B>        print isinstance(l, vim.List)	# True</B>
<B>        class List(vim.List):		# Subclassing</B>


vim.Function object				*<A NAME="python-Function"></A><B>python-Function</B>*
    Function-like object, acting like vim |<A HREF="eval.html#Funcref">Funcref</A>| object. Accepts special
    keyword argument `self`, see |<A HREF="eval.html#Dictionary-function">Dictionary-function</A>|. You can also use
    `vim.Function(name)` constructor, <A HREF="motion.html#it">it</A> is the same <A HREF="motion.html#as">as</A>
    `vim.bindeval('function(&#37;s)'&#37;json.dumps(name))`.

    Attributes (read-only):
<B><FONT COLOR="PURPLE">        Attribute    Description </FONT></B>
        name         Function name.
        args         `None` or a |<A HREF="#python-List">python-List</A>| object with arguments.  Note
                     that this is a copy of the arguments <A HREF="eval.html#list">list</A>, constructed
                     each time you request this attribute. Modifications made
                     to the <A HREF="eval.html#list">list</A> will be ignored (but not to the containers
                     inside argument <A HREF="eval.html#list">list</A>: this is like |<A HREF="builtin.html#copy()">copy()</A>| and not
                     |<A HREF="builtin.html#deepcopy()">deepcopy()</A>|).
        <A HREF="eval.html#self">self</A>         `None` or a |<A HREF="#python-Dictionary">python-Dictionary</A>| object with <A HREF="eval.html#self">self</A>
                     dictionary. Note that explicit `self` keyword used when
                     calling resulting object overrides this attribute.
        auto_rebind  <A HREF="eval.html#Boolean">Boolean</A>. True if <A HREF="builtin.html#partial">partial</A> created from this <A HREF="#Python">Python</A> object
                     and stored in the Vim <A HREF="usr_41.html#script">script</A> dictionary should be
                     automatically rebound to the dictionary <A HREF="motion.html#it">it</A> is stored in
                     when this dictionary is indexed. Exposes Vim internal
                     difference between `dict.func` (auto_rebind=True) and
                     `function(dict.func,dict)` (auto_rebind=False). This
                     attribute makes no sense if `self` attribute is `None`.

    Constructor additionally accepts `args`, `self` and `auto_rebind`
    keywords.  If `args` and/or `self` argument is given then <A HREF="motion.html#it">it</A> constructs
    a <A HREF="builtin.html#partial">partial</A>, see |<A HREF="builtin.html#function()">function()</A>|.  `auto_rebind` is only used when `self`
    argument is given, otherwise <A HREF="motion.html#it">it</A> is assumed to be `True` regardless of
    whether <A HREF="motion.html#it">it</A> was given or not.  If `self` is given then <A HREF="motion.html#it">it</A> defaults to
    `False`.

    Examples:
<B>        f = vim.Function('tr')			# Constructor</B>
<B>        print f('abc', 'a', 'b')		# Calls tr('abc', 'a', 'b')</B>
<B>        vim.command('''</B>
<B>            function DictFun() dict</B>
<B>                return self</B>
<B>            endfunction</B>
<B>        ''')</B>
<B>        f = vim.bindeval('function("DictFun")')</B>
<B>        print f(self={})			# Like call('DictFun', [], {})</B>
<B>        print isinstance(f, vim.Function)	# True</B>

<B>        p = vim.Function('DictFun', self={})</B>
<B>        print f()</B>
<B>        p = vim.Function('tr', args=['abc', 'a'])</B>
<B>        print f('b')</B>

==============================================================================

8. <A HREF="builtin.html#pyeval()">pyeval()</A> and <A HREF="builtin.html#py3eval()">py3eval()</A> Vim <A HREF="eval.html#functions">functions</A>			*<A NAME="python-pyeval"></A><B>python-pyeval</B>*

To facilitate bi-directional interface, you can use |<A HREF="builtin.html#pyeval()">pyeval()</A>| and |<A HREF="builtin.html#py3eval()">py3eval()</A>|
<A HREF="eval.html#functions">functions</A> to evaluate <A HREF="#Python">Python</A> expressions and pass their values to Vim <A HREF="usr_41.html#script">script</A>.
|<A HREF="builtin.html#pyxeval()">pyxeval()</A>| is also available.

The <A HREF="#Python">Python</A> value &quot;<A HREF="eval.html#None">None</A>&quot; is converted to <A HREF="eval.html#v:none">v:none</A>.

==============================================================================

9. Dynamic loading					*<A NAME="python-dynamic"></A><B>python-dynamic</B>*

On <A HREF="os_win32.html#MS-Windows">MS-Windows</A> and <A HREF="os_unix.html#Unix">Unix</A> the <A HREF="#Python">Python</A> library can be loaded dynamically.  The
|<A HREF="various.html#:version">:version</A>| output then includes |<A HREF="various.html#+python/dyn">+python/dyn</A>| or |<A HREF="various.html#+python3/dyn">+python3/dyn</A>|.

This means that Vim will search for the <A HREF="#Python">Python</A> DLL or shared library file only
when needed.  When you don't use the <A HREF="#Python">Python</A> interface you don't need <A HREF="motion.html#it">it</A>, thus
you can use Vim without this file.


<B><FONT COLOR="PURPLE">MS-Windows </FONT></B>

To use the <A HREF="#Python">Python</A> interface the <A HREF="#Python">Python</A> DLL must be in your search path.  In a
console <A HREF="windows.html#window">window</A> type &quot;path&quot; to see what directories are used.  The <A HREF="options.html#'pythondll'">'pythondll'</A>
or <A HREF="options.html#'pythonthreedll'">'pythonthreedll'</A> option can be also used to specify the <A HREF="#Python">Python</A> DLL.

The name of the DLL should match the <A HREF="#Python">Python</A> version Vim was compiled with.
Currently the name for <A HREF="#Python">Python</A> 2 is &quot;python27.dll&quot;, that is for <A HREF="#Python">Python</A> 2.7.
That is the default value for <A HREF="options.html#'pythondll'">'pythondll'</A>.  For <A HREF="#Python">Python</A> 3 <A HREF="motion.html#it">it</A> is python36.dll
(Python 3.6).  To know for sure edit &quot;gvim.exe&quot; and search for
&quot;python\d*.dll\c&quot;.


<B><FONT COLOR="PURPLE">Unix </FONT></B>

The <A HREF="options.html#'pythondll'">'pythondll'</A> or <A HREF="options.html#'pythonthreedll'">'pythonthreedll'</A> option can be used to specify the <A HREF="#Python">Python</A>
shared library file instead of DYNAMIC_PYTHON_DLL or DYNAMIC_PYTHON3_DLL file
what were specified at compile time.  The version of the shared library must
match the <A HREF="#Python">Python</A> 2.x or <A HREF="#Python">Python</A> 3 version Vim was compiled with.

==============================================================================

10. <A HREF="#Python">Python</A> 3						*<A NAME="python3"></A><B>python3</B>*


							*<A NAME=":py3"></A><B>:py3</B>* *<A NAME=":python3"></A><B>:python3</B>*
:[range]py3 {stmt}
:[range]py3 <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> [trim] [{endmarker}]
{script}
{endmarker}

:[range]python3 {stmt}
:[range]python3 <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> [trim] [{endmarker}]
{script}
{endmarker}
	The `:py3` and `:python3` commands work similar to `:python`.  A
	simple check if the `:py3` command is working:
<B>		:py3 print("Hello")</B>
 
	To see what version of <A HREF="#Python">Python</A> you have:
<B>		:py3 import sys</B>
<B>		:py3 print(sys.version)</B>

 							*<A NAME=":py3file"></A><B>:py3file</B>*
:[range]py3f[ile] <A HREF="editing.html#{file}">{file}</A>
	The `:py3file` command works similar to `:pyfile`.

							*<A NAME=":py3do"></A><B>:py3do</B>*
:[range]py3do {body}
	The `:py3do` command works similar to `:pydo`.


Vim can be built in four ways (:version output):
1. No <A HREF="#Python">Python</A> support	    (-python, -python3)
2. <A HREF="#Python">Python</A> 2 support only    (+python or <A HREF="various.html#+python/dyn">+python/dyn</A>, -python3)
3. <A HREF="#Python">Python</A> 3 support only    (-python, <A HREF="various.html#+python3">+python3</A> or <A HREF="various.html#+python3/dyn">+python3/dyn</A>)
4. <A HREF="#Python">Python</A> 2 and 3 support   (+python/dyn, <A HREF="various.html#+python3/dyn">+python3/dyn</A>)


Some more details on the special <A HREF="change.html#case">case</A> 4:  *<A NAME="python-2-and-3"></A><B>python-2-and-3</B>*

When <A HREF="#Python">Python</A> 2 and <A HREF="#Python">Python</A> 3 are both supported they must be loaded dynamically.

When doing this on Linux/Unix systems and importing global symbols, this leads
to a crash when the second <A HREF="#Python">Python</A> version is used.  So either global symbols
are loaded but only one <A HREF="#Python">Python</A> version is activated, or no global symbols are
loaded. The latter makes Python's &quot;import&quot; fail on libraries that expect the
symbols to be provided by Vim.

							*<A NAME="E836"></A><B>E836</B>* *<A NAME="E837"></A><B>E837</B>*
Vim's configuration <A HREF="usr_41.html#script">script</A> makes a guess for all libraries based on one
standard <A HREF="#Python">Python</A> library (termios).  If importing this library succeeds for
both <A HREF="#Python">Python</A> versions, then both will be made available in Vim at the same
time.  If not, only the version first used in a session will be enabled.
When trying to use the other one you will get the <A HREF="#E836">E836</A> or <A HREF="#E837">E837</A> error message.

Here Vim's behavior depends on the system in which <A HREF="motion.html#it">it</A> was configured.  In a
system where both versions of <A HREF="#Python">Python</A> were configured with --enable-shared,
both versions of <A HREF="#Python">Python</A> will be activated at the same time.  There will still
be problems with other third party libraries that were not linked to
libPython.

To work around such problems there are these <A HREF="options.html#options">options</A>:
1. The problematic library is recompiled to link to the according
   libpython.so.
2. Vim is recompiled for only one <A HREF="#Python">Python</A> version.
3. You undefine PY_NO_RTLD_GLOBAL in auto/config.h after configuration.  This
   may crash Vim though.


							*<A NAME="E880"></A><B>E880</B>*
Raising SystemExit exception in <A HREF="#python">python</A> isn't endorsed way to quit vim, use:
<B>	:py vim.command("qall!")</B>
 

							*<A NAME="E1266"></A><B>E1266</B>*
This error can occur when <A HREF="#Python">Python</A> 3 cannot load the required modules.  This
means that your <A HREF="#Python">Python</A> 3 is not correctly installed or there are some mistakes
in your settings.  Please check the following items:
1. Make sure that <A HREF="#Python">Python</A> 3 is correctly installed.  Also check the version of
   <A HREF="#python">python</A>.
2. Check the <A HREF="options.html#'pythonthreedll'">'pythonthreedll'</A> option.
3. Check the <A HREF="options.html#'pythonthreehome'">'pythonthreehome'</A> option.
4. Check the PATH environment variable if you don't set <A HREF="options.html#'pythonthreedll'">'pythonthreedll'</A>.
   On <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, you can use where.exe to check which dll will be loaded.
   E.g.
<B>	where.exe python310.dll</B>
5. Check the PYTHONPATH and PYTHONHOME environment <A HREF="eval.html#variables">variables</A>.


							*<A NAME="has-python"></A><B>has-python</B>*
You can test what <A HREF="#Python">Python</A> version is available with:
<B>	if has('python')</B>
<B>	  echo 'there is Python 2.x'</B>
<B>	endif</B>
<B>  	if has('python3')</B>
<B>	  echo 'there is Python 3.x'</B>
<B>	endif</B>

Note however, that when <A HREF="#Python">Python</A> 2 and 3 are both available and loaded
dynamically, these <A HREF="builtin.html#has()">has()</A> calls will try to load them.  If only one can be
loaded at a time, just checking if <A HREF="#Python">Python</A> 2 or 3 are available will prevent
the other one from being available.

To avoid loading the dynamic library, only check if Vim was compiled with
<A HREF="#python">python</A> support:
<B>	if has('python_compiled')</B>
<B>	  echo 'compiled with Python 2.x support'</B>
<B>	  if has('python_dynamic')</B>
<B>	    echo 'Python 2.x dynamically loaded'</B>
<B>	  endif</B>
<B>	endif</B>
<B>  	if has('python3_compiled')</B>
<B>	  echo 'compiled with Python 3.x support'</B>
<B>	  if has('python3_dynamic')</B>
<B>	    echo 'Python 3.x dynamically loaded'</B>
<B>	  endif</B>
<B>	endif</B>

This also tells you whether <A HREF="#Python">Python</A> is dynamically loaded, which will fail if
the runtime library cannot be found.

==============================================================================

11. <A HREF="#Python">Python</A> X						*<A NAME="python_x"></A><B>python_x</B>* *<A NAME="pythonx"></A><B>pythonx</B>*

Because most <A HREF="#python">python</A> code can be written so that <A HREF="motion.html#it">it</A> works with <A HREF="#Python">Python</A> 2.6+ and
<A HREF="#Python">Python</A> 3 the pyx* <A HREF="eval.html#functions">functions</A> and commands have been written.  They work exactly
the same <A HREF="motion.html#as">as</A> the <A HREF="#Python">Python</A> 2 and 3 variants, but select the <A HREF="#Python">Python</A> version using
the <A HREF="options.html#'pyxversion'">'pyxversion'</A> setting.

You should set <A HREF="options.html#'pyxversion'">'pyxversion'</A> in your |<A HREF="starting.html#.vimrc">.vimrc</A>| to prefer <A HREF="#Python">Python</A> 2 or <A HREF="#Python">Python</A> 3
for <A HREF="#Python">Python</A> commands. If you change this setting at runtime you may risk that
state of plugins (such <A HREF="motion.html#as">as</A> <A HREF="starting.html#initialization">initialization</A>) may be lost.

If you want to use a module, you can put <A HREF="motion.html#it">it</A> in the {rtp}/pythonx directory.
See |<A HREF="#pythonx-directory">pythonx-directory</A>|.


							*<A NAME=":pyx"></A><B>:pyx</B>* *<A NAME=":pythonx"></A><B>:pythonx</B>*
The `:pyx` and `:pythonx` commands work similar to `:python`.  A simple check
if the `:pyx` command is working:
<B>	:pyx print("Hello")</B>

To see what version of <A HREF="#Python">Python</A> is being used:
<B>	:pyx import sys</B>
<B>	:pyx print(sys.version)</B>
 

					*<A NAME=":pyxfile"></A><B>:pyxfile</B>* *<A NAME="python_x-special-comments"></A><B>python_x-special-comments</B>*
The `:pyxfile` command works similar to `:pyfile`.  However you can add one of
these comments to force Vim using `:pyfile` or `:py3file`:
<B>  #!/any string/python2		" Shebang. Must be the first line of the file.</B>
<B>  #!/any string/python3		" Shebang. Must be the first line of the file.</B>
<B>  # requires python 2.x		" Maximum lines depend on 'modelines'.</B>
<B>  # requires python 3.x		" Maximum lines depend on 'modelines'.</B>
Unlike normal modelines, the bottom of the file is not checked.
If none of them are found, the <A HREF="options.html#'pyxversion'">'pyxversion'</A> setting is used.

							*<A NAME="W20"></A><B>W20</B>* *<A NAME="W21"></A><B>W21</B>*
If Vim does not support the selected <A HREF="#Python">Python</A> version a silent message will be
printed.  Use `:messages` to read them.


							*<A NAME=":pyxdo"></A><B>:pyxdo</B>*
The `:pyxdo` command works similar to `:pydo`.


							*<A NAME="has-pythonx"></A><B>has-pythonx</B>*
You can test if pyx* commands are available with:
<B>	if has('pythonx')</B>
<B>	  echo 'pyx* commands are available. (Python ' .. &amp;pyx .. ')'</B>
<B>	endif</B>

When compiled with only one of |<A HREF="various.html#+python">+python</A>| or |<A HREF="various.html#+python3">+python3</A>|, the <A HREF="builtin.html#has()">has()</A> returns 1.
When compiled with both |<A HREF="various.html#+python">+python</A>| and |<A HREF="various.html#+python3">+python3</A>|, the test depends on the
<A HREF="options.html#'pyxversion'">'pyxversion'</A> setting.  If <A HREF="options.html#'pyxversion'">'pyxversion'</A> is 0, <A HREF="motion.html#it">it</A> tests <A HREF="#Python">Python</A> 3 first, and if
<A HREF="motion.html#it">it</A> is not available then <A HREF="#Python">Python</A> 2.  If <A HREF="options.html#'pyxversion'">'pyxversion'</A> is 2 or 3, <A HREF="motion.html#it">it</A> tests only
<A HREF="#Python">Python</A> 2 or 3 respectively.

Note that for `has('pythonx')` to work <A HREF="motion.html#it">it</A> may try to dynamically load <A HREF="#Python">Python</A> 3
or 2.  This may have side effects, especially when Vim can only load one of
the two.

If a user prefers <A HREF="#Python">Python</A> 2 and want to fallback to <A HREF="#Python">Python</A> 3, he needs to set
<A HREF="options.html#'pyxversion'">'pyxversion'</A> explicitly in his |<A HREF="starting.html#.vimrc">.vimrc</A>|.  E.g.:
<B>	if has('python')</B>
<B>	  set pyx=2</B>
<B>	elseif has('python3')</B>
<B>	  set pyx=3</B>
<B>	endif</B>

==============================================================================

12. Building with <A HREF="#Python">Python</A> support			*<A NAME="python-building"></A><B>python-building</B>*

A few hints for building with <A HREF="#Python">Python</A> 2 or 3 support.

UNIX

See src/Makefile for how to enable including the <A HREF="#Python">Python</A> interface.

On Ubuntu you will want to <A HREF="usr_90.html#install">install</A> these <A HREF="repeat.html#packages">packages</A> for <A HREF="#Python">Python</A> 2:
	<A HREF="#python">python</A>
	python-dev
For <A HREF="#Python">Python</A> 3:
	<A HREF="#python3">python3</A>
	python3-dev
For <A HREF="#Python">Python</A> 3.6:
	python3.6
	python3.6-dev

If you have more than one version of <A HREF="#Python">Python</A> 3, you need to link <A HREF="#python3">python3</A> to the
one you prefer, before running configure.

==============================================================================
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
